/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.2.0 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/requirejs/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.2.0',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, multi, multiText, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

define("requireLib", function(){});

!function(){function t(t){this.message=t}var r="undefined"!=typeof exports?exports:self,e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";t.prototype=new Error,t.prototype.name="InvalidCharacterError",r.btoa||(r.btoa=function(r){for(var o,n,a=String(r),i=0,c=e,d="";a.charAt(0|i)||(c="=",i%1);d+=c.charAt(63&o>>8-i%1*8)){if(n=a.charCodeAt(i+=.75),n>255)throw new t("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");o=o<<8|n}return d}),r.atob||(r.atob=function(r){var o=String(r).replace(/=+$/,"");if(o.length%4==1)throw new t("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,a,i=0,c=0,d="";a=o.charAt(c++);~a&&(n=i%4?64*n+a:a,i++%4)?d+=String.fromCharCode(255&n>>(-2*i&6)):0)a=e.indexOf(a);return d})}();
define("lib/base64.min.js", function(){});

window.browserDetect = {
    init: function () {
        this.browser = this.searchString(this.dataBrowser) || "Other";
        this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "Unknown";
        // detect IE 11
        if (this.browser == 'Explorer' && this.version == '7' && navigator.userAgent.match(/Trident/i)) {
            this.version = this.searchVersionIE();
        }
    },

    searchString: function (data) {
        for (var i = 0 ; i < data.length ; i++) {
            var dataString = data[i].string;
            this.versionSearchString = data[i].subString;

            if (dataString.indexOf(data[i].subString) != -1) {
                return data[i].identity;
            }
        }
    },

    searchVersion: function (dataString) {
        var index = dataString.indexOf(this.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
    },

    searchVersionIE: function() {
        var ua = navigator.userAgent.toString().toLowerCase(),
            match = /(trident)(?:.*rv:([\w.]+))?/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ['', null, -1],
            ver;
        try {
            ver = (match[2]).split('.')[0]; // version
        }
        catch (err) {
            ver = 'unknown'; //
        }
        return ver;
    },

    dataBrowser:
        [
            { string: navigator.userAgent, subString: "Chrome", identity: "Chrome" },
            { string: navigator.userAgent, subString: "MSIE", identity: "Explorer" },
            { string: navigator.userAgent, subString: "Trident", identity: "Explorer" },
            { string: navigator.userAgent, subString: "Firefox", identity: "Firefox" },
            { string: navigator.userAgent, subString: "Safari", identity: "Safari" },
            { string: navigator.userAgent, subString: "Opera", identity: "Opera" }
        ]

};

window.browserDetect.init();
define("lib/browserdetect.js", function(){});

(function(a){(jQuery.browser=jQuery.browser||{}).mobile=/(android|bb\d+|meego).+mobile|avantgo|bada\/|android|ipad|playbook|silk|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))})(navigator.userAgent||navigator.vendor||window.opera);
define("lib/detectmobilebrowser.js", function(){});

/*!
 * jQuery-ajaxTransport-XDomainRequest - v1.0.4 - 2015-03-05
 * https://github.com/MoonScript/jQuery-ajaxTransport-XDomainRequest
 * Copyright (c) 2015 Jason Moon (@JSONMOON)
 * Licensed MIT (/blob/master/LICENSE.txt)
 */
(function(factory) {
    //if (typeof define === 'function' && define.amd) {
    //    // AMD. Register as anonymous module.
    //    define(['jquery'], factory);
    //} else if (typeof exports === 'object') {
    //    // CommonJS
    //    module.exports = factory(require('jquery'));
    //} else {
        // Browser globals.
        factory(jQuery);
    //}
}(function($) {

// Only continue if we're on IE8/IE9 with jQuery 1.5+ (contains the ajaxTransport function)
    if ($.support.cors || !$.ajaxTransport || !window.XDomainRequest) {
        return $;
    }

    var httpRegEx = /^(https?:)?\/\//i;
    var getOrPostRegEx = /^get|post$/i;
    var sameSchemeRegEx = new RegExp('^(\/\/|' + location.protocol + ')', 'i');

// ajaxTransport exists in jQuery 1.5+
    $.ajaxTransport('* text html xml json', function(options, userOptions, jqXHR) {

        // Only continue if the request is: asynchronous, uses GET or POST method, has HTTP or HTTPS protocol, and has the same scheme as the calling page
        if (!options.crossDomain || !options.async || !getOrPostRegEx.test(options.type) || !httpRegEx.test(options.url) || !sameSchemeRegEx.test(options.url)) {
            return;
        }

        var xdr = null;

        return {
            send: function(headers, complete) {
                var postData = '';
                var userType = (userOptions.dataType || '').toLowerCase();

                xdr = new XDomainRequest();
                if (/^\d+$/.test(userOptions.timeout)) {
                    xdr.timeout = userOptions.timeout;
                }

                xdr.ontimeout = function() {
                    complete(500, 'timeout');
                };

                xdr.onload = function() {
                    var allResponseHeaders = 'Content-Length: ' + xdr.responseText.length + '\r\nContent-Type: ' + xdr.contentType;
                    var status = {
                        code: 200,
                        message: 'success'
                    };
                    var responses = {
                        text: xdr.responseText
                    };
                    try {
                        if (userType === 'html' || /text\/html/i.test(xdr.contentType)) {
                            responses.html = xdr.responseText;
                        } else if (userType === 'json' || (userType !== 'text' && /\/json/i.test(xdr.contentType))) {
                            try {
                                responses.json = $.parseJSON(xdr.responseText);
                            } catch(e) {
                                status.code = 500;
                                status.message = 'parseerror';
                                //throw 'Invalid JSON: ' + xdr.responseText;
                            }
                        } else if (userType === 'xml' || (userType !== 'text' && /\/xml/i.test(xdr.contentType))) {
                            var doc = new ActiveXObject('Microsoft.XMLDOM');
                            doc.async = false;
                            try {
                                doc.loadXML(xdr.responseText);
                            } catch(e) {
                                doc = undefined;
                            }
                            if (!doc || !doc.documentElement || doc.getElementsByTagName('parsererror').length) {
                                status.code = 500;
                                status.message = 'parseerror';
                                throw 'Invalid XML: ' + xdr.responseText;
                            }
                            responses.xml = doc;
                        }
                    } catch(parseMessage) {
                        throw parseMessage;
                    } finally {
                        complete(status.code, status.message, responses, allResponseHeaders);
                    }
                };

                // set an empty handler for 'onprogress' so requests don't get aborted
                xdr.onprogress = function(){};
                xdr.onerror = function() {
                    complete(401, 'error', {
                        text: xdr.responseText
                    });
                };

                if (userOptions.data) {
                    postData = ($.type(userOptions.data) === 'string') ? userOptions.data : $.param(userOptions.data);
                }
                xdr.open(options.type, options.url);
                xdr.send(postData);
            },
            abort: function() {
                if (xdr) {
                    xdr.abort();
                }
            }
        };
    });

    return $;

}));

define("lib/jquery.xdomainrequest.js", function(){});

/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-input-inputtypes-cssclasses-load
 */
/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-input-inputtypes-cssclasses-cors-load
 * (add Non-core detects: cors)
 */
;window.Modernizr=function(a,b,c){function v(a){j.cssText=a}function w(a,b){return v(prefixes.join(a+";")+(b||""))}function x(a,b){return typeof a===b}function y(a,b){return!!~(""+a).indexOf(b)}function z(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:x(f,"function")?f.bind(d||b):f}return!1}function A(){e.input=function(c){for(var d=0,e=c.length;d<e;d++)p[c[d]]=c[d]in k;return p.list&&(p.list=!!b.createElement("datalist")&&!!a.HTMLDataListElement),p}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),e.inputtypes=function(a){for(var d=0,e,f,h,i=a.length;d<i;d++)k.setAttribute("type",f=a[d]),e=k.type!=="text",e&&(k.value=l,k.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(f)&&k.style.WebkitAppearance!==c?(g.appendChild(k),h=b.defaultView,e=h.getComputedStyle&&h.getComputedStyle(k,null).WebkitAppearance!=="textfield"&&k.offsetHeight!==0,g.removeChild(k)):/^(search|tel)$/.test(f)||(/^(url|email)$/.test(f)?e=k.checkValidity&&k.checkValidity()===!1:e=k.value!=l)),o[a[d]]=!!e;return o}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var d="2.8.3",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k=b.createElement("input"),l=":)",m={}.toString,n={},o={},p={},q=[],r=q.slice,s,t={}.hasOwnProperty,u;!x(t,"undefined")&&!x(t.call,"undefined")?u=function(a,b){return t.call(a,b)}:u=function(a,b){return b in a&&x(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=r.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(r.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(r.call(arguments)))};return e});for(var B in n)u(n,B)&&(s=B.toLowerCase(),e[s]=n[B](),q.push((e[s]?"":"no-")+s));return e.input||A(),e.addTest=function(a,b){if(typeof a=="object")for(var d in a)u(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},v(""),i=k=null,e._version=d,g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+q.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))},Modernizr.addTest("cors",!!(window.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest));
define("lib/modernizr.js", function(){});

var __extends=this&&this.__extends||function(){var r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(r,e){r.__proto__=e}||function(r,e){for(var t in e)e.hasOwnProperty(t)&&(r[t]=e[t])};return function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}}(),exjs;!function(r){r.version="0.5.1"}(exjs||(exjs={}));var exjs;!function(r){Array.isArray||(Array.isArray=function(r){return"[object Array]"===Object.prototype.toString.call(r)})}(exjs||(exjs={}));var exjs;!function(r){var e=function(){function r(){}return r.prototype.getEnumerator=function(){return{moveNext:function(){return!1},current:void 0}},r.prototype.aggregate=function(r,e){for(var t=r,n=this.getEnumerator();n.moveNext();)t=e(t,n.current);return t},r.prototype.all=function(r){if(r)for(var e=this.getEnumerator(),t=0;e.moveNext();){if(!r(e.current,t))return!1;t++}return!0},r.prototype.any=function(r){for(var e=this.getEnumerator(),t=0;e.moveNext();){if(!r)return!0;if(r(e.current,t))return!0;t++}return!1},r.prototype.append=function(){for(var r=[],e=0;e<arguments.length;e++)r[e]=arguments[e];throw new Error("Not implemented")},r.prototype.apply=function(r){throw new Error("Not implemented")},r.prototype.at=function(r){for(var e=this.getEnumerator(),t=0;e.moveNext();){if(t===r)return e.current;t++}},r.prototype.average=function(r){var e=0,t=0;r=r||function(r){if("number"!=typeof r)throw new Error("Object is not a number.");return r};for(var n=this.getEnumerator();n.moveNext();)t+=r(n.current),e++;return 0===e?0:t/e},r.prototype.concat=function(r){throw new Error("Not implemented")},r.prototype.count=function(r){for(var e=0,t=this.getEnumerator();t.moveNext();)r&&!r(t.current)||e++;return e},r.prototype.difference=function(r,e){return e=e||function(r,e){return r===e},r instanceof Array&&(r=r.en()),{intersection:this.intersect(r,e).toArray().en(),aNotB:this.except(r,e).toArray().en(),bNotA:r.except(this,e).toArray().en()}},r.prototype.distinct=function(r){throw new Error("Not implemented")},r.prototype.except=function(r,e){throw new Error("Not implemented")},r.prototype.first=function(r){for(var e=this.getEnumerator();e.moveNext();)if(!r||r(e.current))return e.current},r.prototype.firstIndex=function(r){for(var e=this.getEnumerator(),t=0;e.moveNext();t++)if(!r||r(e.current))return t;return-1},r.prototype.forEach=function(r){for(var e=this.getEnumerator();e.moveNext();)r(e.current)},r.prototype.groupBy=function(r,e){throw new Error("Not implemented")},r.prototype.intersect=function(r,e){throw new Error("Not implemented")},r.prototype.join=function(r,e,t,n,o){throw new Error("Not implemented")},r.prototype.last=function(r){for(var e,t=this.getEnumerator();t.moveNext();)r&&!r(t.current)||(e=t.current);return e},r.prototype.lastIndex=function(r){for(var e=-1,t=this.getEnumerator(),n=0;t.moveNext();n++)r&&!r(t.current)||(e=n);return e},r.prototype.max=function(r){var e=this.getEnumerator();if(!e.moveNext())return 0;r=r||function(r){if("number"!=typeof r)throw new Error("Object is not a number.");return r};for(var t=r(e.current);e.moveNext();)t=Math.max(t,r(e.current));return t},r.prototype.min=function(r){var e=this.getEnumerator();if(!e.moveNext())return 0;r=r||function(r){if("number"!=typeof r)throw new Error("Object is not a number.");return r};for(var t=r(e.current);e.moveNext();)t=Math.min(t,r(e.current));return t},r.prototype.orderBy=function(r,e){throw new Error("Not implemented")},r.prototype.orderByDescending=function(r,e){throw new Error("Not implemented")},r.prototype.prepend=function(){for(var r=[],e=0;e<arguments.length;e++)r[e]=arguments[e];throw new Error("Not implemented")},r.prototype.reverse=function(){throw new Error("Not implemented")},r.prototype.select=function(r){throw new Error("Not implemented")},r.prototype.selectMany=function(r){throw new Error("Not implemented")},r.prototype.skip=function(r){throw new Error("Not implemented")},r.prototype.skipWhile=function(r){throw new Error("Not implemented")},r.prototype.standardDeviation=function(r){var e=this.average(r),t=0,n=0;r=r||function(r){if("number"!=typeof r)throw new Error("Object is not a number.");return r};for(var o=this.getEnumerator();o.moveNext();){var u=r(o.current)-e;t+=u*u,n++}return Math.sqrt(t/n)},r.prototype.sum=function(r){var e=0;r=r||function(r){if("number"!=typeof r)throw new Error("Object is not a number.");return r};for(var t=this.getEnumerator();t.moveNext();)e+=r(t.current);return e},r.prototype.take=function(r){throw new Error("Not implemented")},r.prototype.takeWhile=function(r){throw new Error("Not implemented")},r.prototype.traverse=function(r){throw new Error("Not implemented")},r.prototype.traverseUnique=function(r,e){throw new Error("Not implemented")},r.prototype.toArray=function(){for(var r=[],e=this.getEnumerator();e.moveNext();)r.push(e.current);return r},r.prototype.toMap=function(r,e){throw new Error("Not implemented")},r.prototype.toList=function(){throw new Error("Not implemented")},r.prototype.union=function(r,e){throw new Error("Not implemented")},r.prototype.where=function(r){throw new Error("Not implemented")},r.prototype.zip=function(r,e){throw new Error("Not implemented")},r}();r.Enumerable=e}(exjs||(exjs={}));var exjs;!function(r){var e=function(){function e(r){this.size=0,this._keys=[],this._values=[];var e;if(r instanceof Array?e=r.en():r&&r.getEnumerator instanceof Function&&(e=r),e)for(var t=e.getEnumerator();t&&t.moveNext();)this.set(t.current[0],t.current[1])}return e.prototype.clear=function(){this._keys.length=0,this._values.length=0,this.size=0},e.prototype.delete=function(r){var e=this._keys.indexOf(r);return e>-1&&(this._keys.splice(e,1),this._values.splice(e,1),this.size--,!0)},e.prototype.entries=function(){var e=this;return r.range(0,this.size).select(function(r){return[e._keys[r],e._values[r]]})},e.prototype.forEach=function(r,e){null==e&&(e=this);for(var t=0,n=this._keys,o=this._values,u=n.length;t<u;t++)r.call(e,o[t],n[t],this)},e.prototype.get=function(r){var e=this._keys.indexOf(r);return this._values[e]},e.prototype.has=function(r){return this._keys.indexOf(r)>-1},e.prototype.keys=function(){return this._keys.en()},e.prototype.set=function(r,e){var t=this._keys.indexOf(r);t>-1?this._values[t]=e:(this._keys.push(r),this._values.push(e),this.size++)},e.prototype.values=function(){return this._values.en()},e}();r.Map3=e,r.Enumerable.prototype.toMap=function(r,t){for(var n=new e,o=this.getEnumerator();o.moveNext();)n.set(r(o.current),t(o.current));return n},r.List&&(r.List.prototype.toMap=r.Enumerable.prototype.toMap)}(exjs||(exjs={})),function(r){r.Map||(r.Map=exjs.Map3)}("undefined"==typeof window?global:window);var exjs;!function(r){function e(e){var t=new r.Enumerable;return t.getEnumerator=function(){var r={current:void 0,moveNext:function(){return e(r)}};return r},t}r.anonymous=e}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n,o=1,u={current:void 0,moveNext:function(){if(o<2){if(t=t||r.getEnumerator(),t.moveNext())return u.current=t.current,!0;o++}return n=n||e.en().getEnumerator(),n.moveNext()?(u.current=n.current,!0):(u.current=void 0,!1)}};return u}r.Enumerable.prototype.append=function(){for(var t=this,n=[],o=0;o<arguments.length;o++)n[o]=arguments[o];var u=new r.Enumerable;return u.getEnumerator=function(){return e(t,n)},u},r.List&&(r.List.prototype.append=r.Enumerable.prototype.append)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n=0,o={current:void 0,moveNext:function(){return t||(t=r.getEnumerator()),!!t.moveNext()&&(e(o.current=t.current,n),n++,!0)}};return o}r.Enumerable.prototype.apply=function(t){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return e(n,t)},o},r.List&&(r.List.prototype.apply=r.Enumerable.prototype.apply)}(exjs||(exjs={}));var exjs;!function(r){function e(r){var e=r.length,t={moveNext:void 0,current:void 0},n=-1;return t.moveNext=function(){return n++,n>=e?(t.current=void 0,!1):(t.current=r[n],!0)},t}function t(){return this&&Array.isArray(this)?new n(this):new r.Enumerable}var n=function(r){function t(t){var n=r.call(this)||this;return n.getEnumerator=function(){return e(t)},n.toArray=function(){return t.slice(0)},n}return __extends(t,r),t}(r.Enumerable);try{Object.defineProperty(Array.prototype,"en",{value:t,enumerable:!1,writable:!1,configurable:!1})}catch(r){Array.prototype.en=t}}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n=!1,o={current:void 0,moveNext:function(){return t||(t=r.getEnumerator()),o.current=void 0,t.moveNext()?(o.current=t.current,!0):!n&&(n=!0,t=e.getEnumerator(),!!t.moveNext()&&(o.current=t.current,!0))}};return o}r.Enumerable.prototype.concat=function(t){var n=this,o=t instanceof Array?t.en():t,u=new r.Enumerable;return u.getEnumerator=function(){return e(n,o)},u},r.List&&(r.List.prototype.concat=r.Enumerable.prototype.concat)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n=[],o={current:void 0,moveNext:function(){if(t||(t=r.getEnumerator()),o.current=void 0,!e){for(;t.moveNext();)if(n.indexOf(t.current)<0)return n.push(o.current=t.current),!0;return!1}for(;t.moveNext();){for(var u=0,i=n.length,c=!1;u<i&&!c;u++)c=!!e(n[u],t.current);if(!c)return n.push(o.current=t.current),!0}return!1}};return o}r.Enumerable.prototype.distinct=function(t){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return e(n,t)},o},r.List&&(r.List.prototype.distinct=r.Enumerable.prototype.distinct)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e,t){t=t||function(r,e){return r===e};var n,o={current:void 0,moveNext:function(){for(n||(n=r.getEnumerator()),o.current=void 0;n.moveNext();){for(var u=!1,i=e.getEnumerator();i.moveNext()&&!u;)u=t(n.current,i.current);if(!u)return o.current=n.current,!0}return!1}};return o}r.Enumerable.prototype.except=function(t,n){var o=this,u=t instanceof Array?t.en():t,i=new r.Enumerable;return i.getEnumerator=function(){return e(o,u,n)},i},r.List&&(r.List.prototype.except=r.Enumerable.prototype.except)}(exjs||(exjs={})),Function.prototype.fromJson=function(r,e){function t(r,e){if(null==r)return r;if(e instanceof Function)return e(r);if(e instanceof Array){if(e=e[0],!(e instanceof Function&&r instanceof Array))return;for(var t=[],n=0;n<r.length;n++)t.push(e(r[n]));return t}}var n=new this;if(null==r)return n;var o=[];for(var u in e){var i=t(r[u],e[u]);void 0!==i&&(n[u]=i,o.push(u))}for(var u in this.$jsonMappings)if(!(o.indexOf(u)>-1)){var i=t(r[u],this.$jsonMappings[u]);void 0!==i&&(n[u]=i,o.push(u))}for(var u in r)o.indexOf(u)>-1||(n[u]=r[u]);return n};var exjs;!function(r){function e(r,e,n){var o,u=0,i={current:void 0,moveNext:function(){return o||(o=t(r,e,n)),i.current=void 0,!(u>=o.length)&&(i.current=o[u],u++,!0)}};return i}function t(r,e,t){t=t||function(r,e){return r===e};for(var o,u=[],i=[],c=r.getEnumerator();c.moveNext();){o=e(c.current);for(var a=-1,p=0,f=i.length;p<f;p++)if(t(o,i[p])){a=p;break}var s;a<0?(i.push(o),u.push(s=new n(o))):s=u[a],s._add(c.current)}return u}var n=function(r){function e(e){var t=r.call(this)||this;return t.key=e,t._arr=[],t.getEnumerator=function(){return t._arr.en().getEnumerator()},t}return __extends(e,r),e.prototype._add=function(r){this._arr.push(r)},e}(r.Enumerable);r.Enumerable.prototype.groupBy=function(t,n){var o=this,u=new r.Enumerable;return u.getEnumerator=function(){return e(o,t,n)},u},r.List&&(r.List.prototype.groupBy=r.Enumerable.prototype.groupBy)}(exjs||(exjs={}));var exjs;!function(r){function e(e,t,n){n=n||function(r,e){return r===e};var o,u={current:void 0,moveNext:function(){for(o||(o=r.en(e).distinct().getEnumerator()),u.current=void 0;o.moveNext();){for(var i=!1,c=t.getEnumerator();c.moveNext()&&!i;)i=n(o.current,c.current);if(i)return u.current=o.current,!0}return!1}};return u}r.Enumerable.prototype.intersect=function(t,n){var o=this,u=t instanceof Array?t.en():t,i=new r.Enumerable;return i.getEnumerator=function(){return e(o,u,n)},i},r.List&&(r.List.prototype.intersect=r.Enumerable.prototype.intersect)}(exjs||(exjs={}));var exjs;!function(r){function e(e,t,n,o,u,i){i=i||function(r,e){return r===e};var c,a,p=0,f={current:void 0,moveNext:function(){if(f.current=void 0,!c){if(c=e.getEnumerator(),!c.moveNext())return!1;a=r.en(t).toArray()}var s;do{for(;p<a.length;p++)if(s=a[p],i(n(c.current),o(s)))return p++,f.current=u(c.current,s),!0;p=0}while(c.moveNext());return!1}};return f}r.Enumerable.prototype.join=function(t,n,o,u,i){var c=this,a=t instanceof Array?t.en():t,p=new r.Enumerable;return p.getEnumerator=function(){return e(c,a,n,o,u,i)},p},r.List&&(r.List.prototype.join=r.Enumerable.prototype.join)}(exjs||(exjs={}));var exjs;!function(r){function e(){this.constructor=t}r.Enumerable.prototype.toList=function(){for(var r=new t,e=this.getEnumerator();e.moveNext();)r.push(e.current);return r};var t=function(r){function e(){return null!==r&&r.apply(this,arguments)||this}return __extends(e,r),e.prototype.toString=function(){throw new Error("Not implemented")},e.prototype.toLocaleString=function(){throw new Error("Not implemented")},e.prototype.pop=function(){throw new Error("Not implemented")},e.prototype.push=function(){for(var r=[],e=0;e<arguments.length;e++)r[e]=arguments[e];throw new Error("Not implemented")},e.prototype.shift=function(){throw new Error("Not implemented")},e.prototype.slice=function(r,e){throw new Error("Not implemented")},e.prototype.sort=function(r){throw new Error("Not implemented")},e.prototype.splice=function(){throw new Error("Not implemented")},e.prototype.unshift=function(){for(var r=[],e=0;e<arguments.length;e++)r[e]=arguments[e];throw new Error("Not implemented")},e.prototype.indexOf=function(r,e){throw new Error("Not implemented")},e.prototype.lastIndexOf=function(r,e){throw new Error("Not implemented")},e.prototype.every=function(r,e){throw new Error("Not implemented")},e.prototype.some=function(r,e){throw new Error("Not implemented")},e.prototype.forEach=function(r,e){throw new Error("Not implemented")},e.prototype.map=function(r,e){throw new Error("Not implemented")},e.prototype.filter=function(r,e){throw new Error("Not implemented")},e.prototype.reduce=function(r,e){throw new Error("Not implemented")},e.prototype.reduceRight=function(r,e){throw new Error("Not implemented")},e.prototype.remove=function(r){throw new Error("Not implemented")},e.prototype.removeWhere=function(r){throw new Error("Not implemented")},e}(r.Enumerable);r.List=t;for(var n in Array)Array.hasOwnProperty(n)&&(t[n]=Array[n]);e.prototype=Array.prototype,t.prototype=new e;for(var o in r.Enumerable.prototype)"getEnumerator"!==o&&(t.prototype[o]=r.Enumerable.prototype[o]);t.prototype.getEnumerator=function(){var r=this,e=r.length,t={moveNext:void 0,current:void 0},n=-1;return t.moveNext=function(){return n++,n>=e?(t.current=void 0,!1):(t.current=r[n],!0)},t},t.prototype.remove=function(r){return this.removeWhere(function(e){return e===r}).any()},t.prototype.removeWhere=function(r){for(var e,t=[],n=this.length-1;n>=0;n--)e=this[n],r(e,n)===!0&&(this.splice(n,1),t.push(e));return t.en().reverse()}}(exjs||(exjs={}));var exjs;!function(r){function e(r,e,n,o){return new t(r,e,n,o)}var t=function(e){function t(r,t,n,o){var u=e.call(this)||this;u.Source=r,o=o||function(r,e){return r>e?1:r<e?-1:0};var i=n===!0?-1:1;return u.Sorter=function(r,e){return i*o(t(r),t(e))},u}return __extends(t,e),t.prototype.getEnumerator=function(){var e,t=this.Source,n=this.Sorter,o=0,u={current:void 0,moveNext:function(){return e||(e=r.en(t).toArray(),e.sort(n)),u.current=void 0,!(o>=e.length)&&(u.current=e[o],o++,!0)}};return u},t.prototype.thenBy=function(r,e){return new n(this,r,!1,e)},t.prototype.thenByDescending=function(r,e){return new n(this,r,!0,e)},t}(r.Enumerable),n=function(r){function e(e,t,n,o){var u=r.call(this,e,t,n,o)||this,i=e.Sorter,c=u.Sorter;return u.Sorter=function(r,e){return i(r,e)||c(r,e)},u}return __extends(e,r),e}(t),o=r.Enumerable.prototype;o.orderBy=function(r,t){return e(this,r,!1,t)},o.orderByDescending=function(r,t){return e(this,r,!0,t)},r.List&&(r.List.prototype.orderBy=r.Enumerable.prototype.orderBy,r.List.prototype.orderByDescending=r.Enumerable.prototype.orderByDescending)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n,o=1,u={current:void 0,moveNext:function(){if(o<2){if(t=t||e.en().getEnumerator(),t.moveNext())return u.current=t.current,!0;o++}return n=n||r.getEnumerator(),n.moveNext()?(u.current=n.current,!0):(u.current=void 0,!1)}};return u}r.Enumerable.prototype.prepend=function(){for(var t=this,n=[],o=0;o<arguments.length;o++)n[o]=arguments[o];var u=new r.Enumerable;return u.getEnumerator=function(){return e(t,n)},u},r.List&&(r.List.prototype.prepend=r.Enumerable.prototype.prepend)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e,t){var n=r-t,o={current:void 0,moveNext:function(){return n+=t,!(n>=e)&&(o.current=n,!0)}};return o}function t(t,n,o){if(t=t||0,n=n||0,t>n)throw new Error("Start cannot be greater than end.");null==o&&(o=1);var u=new r.Enumerable;return u.getEnumerator=function(){return e(t,n,o)},u}r.range=t}(exjs||(exjs={}));var exjs;!function(r){function e(e){var t,n=0,o={current:void 0,moveNext:function(){return t||(t=r.en(e).toArray(),n=t.length),n--,o.current=t[n],n>=0}};return o}r.Enumerable.prototype.reverse=function(){var t=this,n=new r.Enumerable;return n.getEnumerator=function(){return e(t)},n},r.List&&(r.List.prototype.reverse=r.Enumerable.prototype.reverse)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){if(e=e||0,0===e)return Math.round(r);var t=Math.pow(10,e);return Math.round(r*t)/t}r.round=e}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n=0,o={current:void 0,moveNext:function(){return t||(t=r.getEnumerator()),!!t.moveNext()&&(o.current=e(t.current,n),n++,!0)}};return o}function t(e,t){var n,o,u={current:void 0,moveNext:function(){for(u.current=void 0,n||(n=e.getEnumerator());!o||!o.moveNext();){if(!n.moveNext())return!1;o=r.selectorEnumerator(t(n.current))}return u.current=o.current,!0}};return u}r.Enumerable.prototype.select=function(t){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return e(n,t)},o},r.Enumerable.prototype.selectMany=function(e){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return t(n,e)},o},r.List&&(r.List.prototype.select=r.Enumerable.prototype.select,r.List.prototype.selectMany=r.Enumerable.prototype.selectMany)}(exjs||(exjs={}));var exjs;!function(r){function e(r){return Array.isArray(r)?r.en().getEnumerator():null!=r&&"function"==typeof r.getEnumerator?r.getEnumerator():null}r.selectorEnumerator=e}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n={current:void 0,moveNext:function(){if(!t){t=r.getEnumerator();for(var o=0;o<e;o++)if(!t.moveNext())return!1}return t.moveNext()?(n.current=t.current,!0):(n.current=void 0,!1)}};return n}function t(r,e){var t,n={current:void 0,moveNext:function(){if(!t){t=r.getEnumerator();for(var o=0;t.moveNext();o++)if(!e(n.current=t.current,o))return!0;return n.current=void 0,!1}return t.moveNext()?(n.current=t.current,!0):(n.current=void 0,!1)}};return n}r.Enumerable.prototype.skip=function(t){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return e(n,t)},o},r.Enumerable.prototype.skipWhile=function(e){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return t(n,e)},o},r.List&&(r.List.prototype.skip=r.Enumerable.prototype.skip,r.List.prototype.skipWhile=r.Enumerable.prototype.skipWhile)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n=0,o={current:void 0,moveNext:function(){return t||(t=r.getEnumerator()),n++,!(n>e)&&(o.current=void 0,!!t.moveNext()&&(o.current=t.current,!0))}};return o}function t(r,e){var t,n=0,o={current:void 0,moveNext:function(){return t||(t=r.getEnumerator()),t.moveNext()&&e(t.current,n)?(n++,o.current=t.current,!0):(o.current=void 0,!1)}};return o}r.Enumerable.prototype.take=function(t){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return e(n,t)},o},r.Enumerable.prototype.takeWhile=function(e){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return t(n,e)},o},r.List&&(r.List.prototype.take=r.Enumerable.prototype.take,r.List.prototype.takeWhile=r.Enumerable.prototype.takeWhile)}(exjs||(exjs={}));var exjs;!function(r){function e(e,t){var n,o=!1,u=[],i={current:void 0,moveNext:function(){if(o){if(null==n)return!1;u.push(n),n=r.selectorEnumerator(t(i.current))}else n=e.getEnumerator(),o=!0;for(;!(n&&n.moveNext()||u.length<1);)n=u.pop();return i.current=null==n?void 0:n.current,void 0!==i.current}};return i}function t(e,t,n){var o,u=!1,i=[],c={current:void 0,moveNext:function(){if(u){if(null==o)return!1;i.push(o),o=r.selectorEnumerator(t(c.current))}else o=e.getEnumerator(),u=!0;do{for(;!(o&&o.moveNext()||i.length<1);)o=i.pop();c.current=null==o?void 0:o.current}while(n(c.current));return void 0!==c.current}};return c}r.Enumerable.prototype.traverse=function(t){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return e(n,t)},o},r.Enumerable.prototype.traverseUnique=function(e,n){var o=this,u=[],i=new r.Enumerable;return n?i.getEnumerator=function(){return t(o,e,function(r){return!!u.some(function(e){return n(r,e)})||(u.push(r),!1)})}:i.getEnumerator=function(){return t(o,e,function(r){return u.indexOf(r)>-1||(u.push(r),!1)})},i},r.List&&(r.List.prototype.traverse=r.Enumerable.prototype.traverse,r.List.prototype.traverseUnique=r.Enumerable.prototype.traverseUnique)}(exjs||(exjs={}));var exjs;!function(r){function e(e,t,n){n=n||function(r,e){return r===e};var o,u,i=[],c={current:void 0,moveNext:function(){if(o||(o=r.en(e).distinct().getEnumerator()),c.current=void 0,!u&&o.moveNext())return i.push(c.current=o.current),!0;for(u=u||r.en(t).distinct().getEnumerator();u.moveNext();){for(var a=0,p=!1,f=i.length;a<f&&!p;a++)p=n(i[a],u.current);if(!p)return c.current=u.current,!0}return!1}};return c}r.Enumerable.prototype.union=function(t,n){var o=this,u=t instanceof Array?t.en():t,i=new r.Enumerable;return i.getEnumerator=function(){return e(o,u,n)},i},r.List&&(r.List.prototype.union=r.Enumerable.prototype.union)}(exjs||(exjs={}));var exjs;!function(r){function e(r,e){var t,n={current:void 0,moveNext:function(){t||(t=r.getEnumerator());for(var o;t.moveNext();)if(e(o=t.current))return n.current=o,!0;return!1}};return n}r.Enumerable.prototype.where=function(t){var n=this,o=new r.Enumerable;return o.getEnumerator=function(){return e(n,t)},o},r.List&&(r.List.prototype.where=r.Enumerable.prototype.where)}(exjs||(exjs={}));var exjs;!function(r){function e(e){var n=new r.Enumerable;return n.getEnumerator=function(){return t(e)},n}function t(r){var e=r.getEnumerator(),t={current:void 0,moveNext:void 0};return t.moveNext=function(){return e.moveNext()?(t.current=e.current,!0):(t.current=void 0,!1)},t}r.en=e}(exjs||(exjs={}));var ex=exjs.en,exjs;!function(r){function e(r,e,t){var n,o,u={current:void 0,moveNext:function(){return n||(n=r.getEnumerator()),o||(o=e.getEnumerator()),u.current=void 0,!(!n.moveNext()||!o.moveNext())&&(u.current=t(n.current,o.current),!0)}};return u}r.Enumerable.prototype.zip=function(t,n){var o=this,u=t instanceof Array?t.en():t,i=new r.Enumerable;return i.getEnumerator=function(){return e(o,u,n)},i},r.List&&(r.List.prototype.zip=r.Enumerable.prototype.zip)}(exjs||(exjs={}));
//# sourceMappingURL=ex.es3.min.js.map

define("lib/ex.es3.min.js", function(){});

var _Components;
(function (_Components) {
    var BaseComponent = /** @class */ (function () {
        function BaseComponent(options) {
            this.options = options;
            this.options.data = $.extend(this.data(), options.data);
        }
        BaseComponent.prototype._init = function () {
            this._$element = $(this.options.target);
            if (!this._$element.length) {
                console.warn('element not found');
                return false;
            }
            this._$element.empty();
            return true;
        };
        BaseComponent.prototype.data = function () {
            return {};
        };
        BaseComponent.prototype.on = function (name, callback, ctx) {
            var e = this._e || (this._e = {});
            (e[name] || (e[name] = [])).push({
                fn: callback,
                ctx: ctx
            });
        };
        BaseComponent.prototype.fire = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var data = [].slice.call(arguments, 1);
            var evtArr = ((this._e || (this._e = {}))[name] || []).slice();
            var i = 0;
            var len = evtArr.length;
            for (i; i < len; i++) {
                evtArr[i].fn.apply(evtArr[i].ctx, data);
            }
        };
        BaseComponent.prototype._resize = function () {
        };
        BaseComponent.prototype.set = function (data) {
        };
        return BaseComponent;
    }());
    _Components.BaseComponent = BaseComponent;
})(_Components || (_Components = {}));
(function (g) {
    if (!g._Components) {
        g._Components = _Components;
    }
})(window);

define("lib/BaseComponent.js", function(){});

var KeyCodes;
(function (KeyCodes) {
    var KeyDown;
    (function (KeyDown) {
        KeyDown.Backspace = 8;
        KeyDown.Tab = 9;
        KeyDown.Enter = 13;
        KeyDown.Shift = 16;
        KeyDown.Ctrl = 17;
        KeyDown.Alt = 18;
        KeyDown.PauseBreak = 19;
        KeyDown.CapsLock = 20;
        KeyDown.Escape = 27;
        KeyDown.Spacebar = 32;
        KeyDown.PageUp = 33;
        KeyDown.PageDown = 34;
        KeyDown.End = 35;
        KeyDown.Home = 36;
        KeyDown.LeftArrow = 37;
        KeyDown.UpArrow = 38;
        KeyDown.RightArrow = 39;
        KeyDown.DownArrow = 40;
        KeyDown.PrintScrn = 44;
        KeyDown.Insert = 45;
        KeyDown.Delete = 46;
        KeyDown.Zero = 48;
        KeyDown.One = 49;
        KeyDown.Two = 50;
        KeyDown.Three = 51;
        KeyDown.Four = 52;
        KeyDown.Five = 53;
        KeyDown.Six = 54;
        KeyDown.Seven = 55;
        KeyDown.Eight = 56;
        KeyDown.Nine = 57;
        KeyDown.a = 65;
        KeyDown.b = 66;
        KeyDown.c = 67;
        KeyDown.d = 68;
        KeyDown.e = 69;
        KeyDown.f = 70;
        KeyDown.g = 71;
        KeyDown.h = 72;
        KeyDown.i = 73;
        KeyDown.j = 74;
        KeyDown.k = 75;
        KeyDown.l = 76;
        KeyDown.m = 77;
        KeyDown.n = 78;
        KeyDown.o = 79;
        KeyDown.p = 80;
        KeyDown.q = 81;
        KeyDown.r = 82;
        KeyDown.s = 83;
        KeyDown.t = 84;
        KeyDown.u = 85;
        KeyDown.v = 86;
        KeyDown.w = 87;
        KeyDown.x = 88;
        KeyDown.y = 89;
        KeyDown.z = 90;
        KeyDown.LeftWindowKey = 91;
        KeyDown.RightWindowKey = 92;
        KeyDown.SelectKey = 93;
        KeyDown.Numpad0 = 96;
        KeyDown.Numpad1 = 97;
        KeyDown.Numpad2 = 98;
        KeyDown.Numpad3 = 99;
        KeyDown.Numpad4 = 100;
        KeyDown.Numpad5 = 101;
        KeyDown.Numpad6 = 102;
        KeyDown.Numpad7 = 103;
        KeyDown.Numpad8 = 104;
        KeyDown.Numpad9 = 105;
        KeyDown.Multiply = 106;
        KeyDown.NumpadPlus = 107;
        KeyDown.NumpadMinus = 109;
        KeyDown.DecimalPoint = 110;
        KeyDown.Divide = 111;
        KeyDown.F1 = 112;
        KeyDown.F2 = 113;
        KeyDown.F3 = 114;
        KeyDown.F4 = 115;
        KeyDown.F5 = 116;
        KeyDown.F6 = 117;
        KeyDown.F7 = 118;
        KeyDown.F8 = 119;
        KeyDown.F9 = 120;
        KeyDown.F10 = 121;
        KeyDown.F11 = 122;
        KeyDown.F12 = 123;
        KeyDown.NumLock = 144;
        KeyDown.ScrollLock = 145;
        KeyDown.Semicolon = 186;
        KeyDown.Equals = 187;
        KeyDown.Comma = 188;
        KeyDown.LessThan = 188;
        KeyDown.Dash = 189;
        KeyDown.Period = 190;
        KeyDown.GreaterThan = 190;
        KeyDown.ForwardSlash = 191;
        KeyDown.QuestionMark = 191;
        KeyDown.GraveAccent = 192;
        KeyDown.Tilde = 192;
        KeyDown.OpenCurlyBracket = 219;
        KeyDown.OpenSquareBracket = 219;
        KeyDown.BackSlash = 220;
        KeyDown.VerticalPipe = 220;
        KeyDown.CloseCurlyBracket = 221;
        KeyDown.CloseSquareBracket = 221;
        KeyDown.Quote = 222;
        KeyDown.CommandFF = 224;
    })(KeyDown = KeyCodes.KeyDown || (KeyCodes.KeyDown = {}));
})(KeyCodes || (KeyCodes = {}));
(function (KeyCodes) {
    var KeyPress;
    (function (KeyPress) {
        KeyPress.Backspace = 8;
        KeyPress.Enter = 13;
        KeyPress.Spacebar = 32;
        KeyPress.Hash = 35;
        KeyPress.GraveAccent = 39;
        KeyPress.DoubleQuote = 34;
        KeyPress.Asterisk = 42;
        KeyPress.Plus = 43;
        KeyPress.Comma = 44;
        KeyPress.Minus = 45;
        KeyPress.Period = 46;
        KeyPress.ForwardSlash = 47;
        KeyPress.Zero = 48;
        KeyPress.One = 49;
        KeyPress.Two = 50;
        KeyPress.Three = 51;
        KeyPress.Four = 52;
        KeyPress.Five = 53;
        KeyPress.Six = 54;
        KeyPress.Seven = 55;
        KeyPress.Eight = 56;
        KeyPress.Nine = 57;
        KeyPress.Colon = 58;
        KeyPress.Semicolon = 59;
        KeyPress.LessThan = 60;
        KeyPress.Equals = 61;
        KeyPress.GreaterThan = 62;
        KeyPress.QuestionMark = 63;
        KeyPress.At = 64;
        KeyPress.OpenSquareBracket = 91;
        KeyPress.BackSlash = 92;
        KeyPress.CloseSquareBracket = 93;
        KeyPress.a = 97;
        KeyPress.b = 98;
        KeyPress.c = 99;
        KeyPress.d = 100;
        KeyPress.e = 101;
        KeyPress.f = 102;
        KeyPress.g = 103;
        KeyPress.h = 104;
        KeyPress.i = 105;
        KeyPress.j = 106;
        KeyPress.k = 107;
        KeyPress.l = 108;
        KeyPress.m = 109;
        KeyPress.n = 110;
        KeyPress.o = 111;
        KeyPress.p = 112;
        KeyPress.q = 113;
        KeyPress.r = 114;
        KeyPress.s = 115;
        KeyPress.t = 116;
        KeyPress.u = 117;
        KeyPress.v = 118;
        KeyPress.w = 119;
        KeyPress.x = 120;
        KeyPress.y = 121;
        KeyPress.z = 122;
        KeyPress.OpenCurlyBracket = 123;
        KeyPress.VerticalPipe = 124;
        KeyPress.CloseCurlyBracket = 125;
        KeyPress.Tilde = 126;
    })(KeyPress = KeyCodes.KeyPress || (KeyCodes.KeyPress = {}));
})(KeyCodes || (KeyCodes = {}));
(function (g) {
    if (!g.KeyCodes) {
        g.KeyCodes = KeyCodes;
    }
})(window);

define("lib/KeyCodes.js", function(){});

var HTTPStatusCode;
(function (HTTPStatusCode) {
    HTTPStatusCode.CONTINUE = 100;
    HTTPStatusCode.SWITCHING_PROTOCOLS = 101;
    HTTPStatusCode.PROCESSING = 102;
    HTTPStatusCode.OK = 200;
    HTTPStatusCode.CREATED = 201;
    HTTPStatusCode.ACCEPTED = 202;
    HTTPStatusCode.NON_AUTHORITATIVE_INFORMATION = 203;
    HTTPStatusCode.NO_CONTENT = 204;
    HTTPStatusCode.RESET_CONTENT = 205;
    HTTPStatusCode.PARTIAL_CONTENT = 206;
    HTTPStatusCode.MULTI_STATUS = 207;
    HTTPStatusCode.MULTIPLE_CHOICES = 300;
    HTTPStatusCode.MOVED_PERMANENTLY = 301;
    HTTPStatusCode.MOVED_TEMPORARILY = 302;
    HTTPStatusCode.SEE_OTHER = 303;
    HTTPStatusCode.NOT_MODIFIED = 304;
    HTTPStatusCode.USE_PROXY = 305;
    HTTPStatusCode.TEMPORARY_REDIRECT = 307;
    HTTPStatusCode.BAD_REQUEST = 400;
    HTTPStatusCode.UNAUTHORIZED = 401;
    HTTPStatusCode.PAYMENT_REQUIRED = 402;
    HTTPStatusCode.FORBIDDEN = 403;
    HTTPStatusCode.NOT_FOUND = 404;
    HTTPStatusCode.METHOD_NOT_ALLOWED = 405;
    HTTPStatusCode.NOT_ACCEPTABLE = 406;
    HTTPStatusCode.PROXY_AUTHENTICATION_REQUIRED = 407;
    HTTPStatusCode.REQUEST_TIME_OUT = 408;
    HTTPStatusCode.CONFLICT = 409;
    HTTPStatusCode.GONE = 410;
    HTTPStatusCode.LENGTH_REQUIRED = 411;
    HTTPStatusCode.PRECONDITION_FAILED = 412;
    HTTPStatusCode.REQUEST_ENTITY_TOO_LARGE = 413;
    HTTPStatusCode.REQUEST_URI_TOO_LARGE = 414;
    HTTPStatusCode.UNSUPPORTED_MEDIA_TYPE = 415;
    HTTPStatusCode.REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    HTTPStatusCode.EXPECTATION_FAILED = 417;
    HTTPStatusCode.IM_A_TEAPOT = 418;
    HTTPStatusCode.UNPROCESSABLE_ENTITY = 422;
    HTTPStatusCode.LOCKED = 423;
    HTTPStatusCode.FAILED_DEPENDENCY = 424;
    HTTPStatusCode.UNORDERED_COLLECTION = 425;
    HTTPStatusCode.UPGRADE_REQUIRED = 426;
    HTTPStatusCode.PRECONDITION_REQUIRED = 428;
    HTTPStatusCode.TOO_MANY_REQUESTS = 429;
    HTTPStatusCode.REQUEST_HEADER_FIELDS_TOO_LARGE = 431;
    HTTPStatusCode.INTERNAL_SERVER_ERROR = 500;
    HTTPStatusCode.NOT_IMPLEMENTED = 501;
    HTTPStatusCode.BAD_GATEWAY = 502;
    HTTPStatusCode.SERVICE_UNAVAILABLE = 503;
    HTTPStatusCode.GATEWAY_TIME_OUT = 504;
    HTTPStatusCode.HTTP_VERSION_NOT_SUPPORTED = 505;
    HTTPStatusCode.VARIANT_ALSO_NEGOTIATES = 506;
    HTTPStatusCode.INSUFFICIENT_STORAGE = 507;
    HTTPStatusCode.BANDWIDTH_LIMIT_EXCEEDED = 509;
    HTTPStatusCode.NOT_EXTENDED = 510;
    HTTPStatusCode.NETWORK_AUTHENTICATION_REQUIRED = 511;
})(HTTPStatusCode || (HTTPStatusCode = {}));
(function (g) {
    if (!g.HTTPStatusCode) {
        g.HTTPStatusCode = HTTPStatusCode;
    }
})(window);

define("lib/HTTPStatusCode.js", function(){});

(function ($) {
    $.fn.checkboxButton = function (onClick) {
        return this.each(function () {
            var $this = $(this);
            $this.on('click', function (e) {
                var tagName = e.target.tagName;
                var $checkbox = $(this).find(':checkbox');
                if (tagName !== "INPUT") {
                    e.preventDefault();
                    $checkbox.prop('checked', !$checkbox.prop('checked'));
                }
                var checked = $checkbox.is(':checked');
                onClick.call(this, checked);
            });
        });
    };
    $.fn.disable = function () {
        return this.each(function () {
            var $this = $(this);
            $this.addClass('disabled');
            $this.data('tabindex', $this.attr('tabindex'));
            $this.removeAttr('tabindex');
        });
    };
    $.fn.ellipsis = function (chars) {
        return this.each(function () {
            var $self = $(this);
            var text = $self.text();
            if (text.length > chars) {
                var trimmedText = text.substr(0, chars);
                trimmedText = trimmedText.substr(0, Math.min(trimmedText.length, trimmedText.lastIndexOf(" ")));
                $self.empty().html(trimmedText + "&hellip;");
            }
        });
    };
    $.fn.ellipsisFill = function (text) {
        var textPassed = true;
        if (!text)
            textPassed = false;
        return this.each(function () {
            var $self = $(this);
            if (!textPassed)
                text = $self.text();
            $self.empty();
            var $spanElem = $('<span title="' + text + '"></span>');
            $self.append($spanElem);
            $self.css('overflow', 'hidden');
            $spanElem.css('white-space', 'nowrap');
            $spanElem.html(text);
            // get the width of the span.
            // if it's wider than the container, remove a word until it's not.
            if ($spanElem.width() > $self.width()) {
                var lastText = null;
                while ($spanElem.width() > $self.width()) {
                    var t = $spanElem.html();
                    t = t.substring(0, t.lastIndexOf(' ')) + '&hellip;';
                    if (t === lastText)
                        break;
                    $spanElem.html(t);
                    lastText = t;
                }
            }
        });
    };
    // Truncates to a certain number of letters, while ignoring and preserving HTML
    $.fn.ellipsisHtmlFixed = function (chars, cb) {
        return this.each(function () {
            var $self = $(this);
            var expandedText = $self.html();
            var $trunc = $('<span></span>');
            $trunc.html($self.html().replace(/\s[\s]*/g, ' ').trim());
            if ($trunc.text().trim().length <= chars) {
                return; // do nothing if we're under the limit!
            }
            while ($trunc.text().trim().length > chars) {
                $trunc.removeLastWord(chars);
            }
            var collapsedText = $trunc.html();
            // Toggle function
            var expanded = false;
            $self.toggle = function () {
                $self.empty();
                var $toggleButton = $('<a href="#" class="toggle"></a>');
                if (expanded) {
                    $self.html(expandedText + " ");
                    $toggleButton.text("less");
                    $toggleButton.switchClass("less", "more");
                }
                else {
                    $self.html(collapsedText + "&hellip; ");
                    $toggleButton.text("more");
                    $toggleButton.switchClass("more", "less");
                }
                $toggleButton.one('click', function (e) {
                    e.preventDefault();
                    $self.toggle();
                });
                expanded = !expanded;
                $self.append($toggleButton);
                if (cb)
                    cb();
            };
            $self.toggle();
        });
    };
    $.fn.enable = function () {
        return this.each(function () {
            var $self = $(this);
            $self.removeClass('disabled');
            $self.attr('tabindex', $self.data('tabindex'));
        });
    };
    $.fn.equaliseHeight = function (reset, average) {
        var maxHeight = -1;
        var minHeight = Number.MAX_VALUE;
        var heights = [];
        // reset all heights to auto first so they can be re-measured.
        if (reset) {
            this.each(function () {
                $(this).height('auto');
            });
        }
        this.each(function () {
            var currentHeight = $(this).height();
            heights.push(currentHeight);
            maxHeight = maxHeight > currentHeight ? maxHeight : currentHeight;
            minHeight = minHeight < currentHeight ? minHeight : currentHeight;
        });
        var finalHeight = maxHeight;
        if (average) {
            heights.sort(function (a, b) { return a - b; });
            var half = Math.floor(heights.length / 2);
            if (heights.length % 2) {
                finalHeight = heights[half];
            }
            else {
                finalHeight = (heights[half - 1] + heights[half]) / 2.0;
            }
        }
        this.each(function () {
            $(this).height(finalHeight);
        });
        return this;
    };
    $.fn.getVisibleElementWithGreatestTabIndex = function () {
        var $self = $(this);
        var maxTabIndex = 0;
        var $elementWithGreatestTabIndex = null;
        $self.find('*:visible[tabindex]').each(function (index, el) {
            var $el = $(el);
            var tabIndex = parseInt($el.attr('tabindex'));
            if (tabIndex > maxTabIndex) {
                maxTabIndex = tabIndex;
                $elementWithGreatestTabIndex = $el;
            }
        });
        return $elementWithGreatestTabIndex;
    };
    $.fn.horizontalMargins = function () {
        var $self = $(this);
        return parseInt($self.css('marginLeft')) + parseInt($self.css('marginRight'));
    };
    $.fn.leftMargin = function () {
        var $self = $(this);
        return parseInt($self.css('marginLeft'));
    };
    $.fn.rightMargin = function () {
        var $self = $(this);
        return parseInt($self.css('marginRight'));
    };
    $.fn.horizontalPadding = function () {
        var $self = $(this);
        return parseInt($self.css('paddingLeft')) + parseInt($self.css('paddingRight'));
    };
    $.fn.leftPadding = function () {
        var $self = $(this);
        return parseInt($self.css('paddingLeft'));
    };
    $.fn.rightPadding = function () {
        var $self = $(this);
        return parseInt($self.css('paddingRight'));
    };
    $.mlp = { x: 0, y: 0 }; // Mouse Last Position
    function documentHandler() {
        var $current = this === document ? $(this) : $(this).contents();
        $current.mousemove(function (e) { jQuery.mlp = { x: e.pageX, y: e.pageY }; });
        $current.find('iframe').on('load', documentHandler);
    }
    $(documentHandler);
    $.fn.ismouseover = function () {
        var result = false;
        this.eq(0).each(function () {
            var $current = $(this).is("iframe") ? $(this).contents().find("body") : $(this);
            var offset = $current.offset();
            result = offset.left <= $.mlp.x && offset.left + $current.outerWidth() > $.mlp.x &&
                offset.top <= $.mlp.y && offset.top + $current.outerHeight() > $.mlp.y;
        });
        return result;
    };
    var on = $.fn.on;
    var timer;
    $.fn.on = function () {
        var args = Array.apply(null, arguments);
        var last = args[args.length - 1];
        if (isNaN(last) || (last === 1 && args.pop()))
            return on.apply(this, args);
        var delay = args.pop();
        var fn = args.pop();
        args.push(function () {
            var self = this;
            var params = arguments;
            clearTimeout(timer);
            timer = setTimeout(function () {
                fn.apply(self, params);
            }, delay);
        });
        return on.apply(this, args);
    };
    $.fn.onEnter = function (cb) {
        return this.each(function () {
            var $this = $(this);
            $this.on('keyup', function (e) {
                if (e.keyCode === 13) {
                    e.preventDefault();
                    cb();
                }
            });
        });
    };
    $.fn.onPressed = function (cb) {
        return this.each(function () {
            var $this = $(this);
            $this.on('touchstart click', function (e) {
                e.preventDefault();
                cb(e);
            });
            $this.on('keyup', function (e) {
                if (e.keyCode === 13) {
                    e.preventDefault();
                    cb(e);
                }
            });
        });
    };
    // Recursively removes the last empty element (img, audio, etc) or word in an element
    $.fn.removeLastWord = function (chars, depth) {
        if (chars === void 0) { chars = 8; }
        if (depth === void 0) { depth = 0; }
        return this.each(function () {
            var $self = $(this);
            if ($self.contents().length > 0) {
                var $lastElement = $self.contents().last();
                if ($lastElement[0].nodeType === 3) {
                    var words = $lastElement.text().trim().split(' ');
                    if (words.length > 1) {
                        words.splice(words.length - 1, 1);
                        $lastElement[0].data = words.join(' '); // textnode.data
                        return;
                    }
                    else if ('undefined' !== typeof chars && words.length === 1 && words[0].length > chars) {
                        $lastElement[0].data = words.join(' ').substring(0, chars);
                        return;
                    }
                }
                $lastElement.removeLastWord(chars, depth + 1); // Element
            }
            else if (depth > 0) {
                // Empty element
                $self.remove();
            }
        });
    };
    $.fn.switchClass = function (class1, class2) {
        return this.each(function () {
            $(this).removeClass(class1).addClass(class2);
        });
    };
    $.fn.targetBlank = function () {
        return this.each(function () {
            $(this).find('a').prop('target', '_blank');
        });
    };
    $.fn.toggleExpandText = function (chars, lessText, moreText, cb) {
        return this.each(function () {
            var $self = $(this);
            var expandedText = $self.html();
            if (chars > expandedText.length)
                return;
            var expanded = false;
            var collapsedText = expandedText.substr(0, chars);
            collapsedText = collapsedText.substr(0, Math.min(collapsedText.length, collapsedText.lastIndexOf(" ")));
            $self.toggle = function () {
                $self.empty();
                var $toggleButton = $('<a href="#" class="toggle"></a>');
                if (expanded) {
                    $self.html(expandedText + "&nbsp;");
                    $toggleButton.text(lessText);
                    $toggleButton.switchClass("less", "more");
                }
                else {
                    $self.html(collapsedText + "&nbsp;");
                    $toggleButton.text(moreText);
                    $toggleButton.switchClass("more", "less");
                }
                $toggleButton.one('click', function (e) {
                    e.preventDefault();
                    $self.toggle();
                });
                expanded = !expanded;
                $self.append($toggleButton);
                if (cb)
                    cb();
            };
            $self.toggle();
        });
    };
    // Toggle expansion by number of lines
    $.fn.toggleExpandTextByLines = function (lines, lessText, moreText, cb) {
        return this.each(function () {
            var $self = $(this);
            var expandedText = $self.html();
            // add 'pad' to account for the right margin in the sidebar
            var $buttonPad = $('<span>&hellip; <a href="#" class="toggle more">morepad</a></span>');
            // when height changes, store string, then pick from line counts
            var stringsByLine = [expandedText];
            var lastHeight = $self.height();
            // Until empty
            while ($self.text().length > 0) {
                $self.removeLastWord();
                var html = $self.html();
                $self.append($buttonPad);
                if (lastHeight > $self.height()) {
                    stringsByLine.unshift(html);
                    lastHeight = $self.height();
                }
                $buttonPad.remove();
            }
            if (stringsByLine.length <= lines) {
                $self.html(expandedText);
                return;
            }
            var collapsedText = stringsByLine[lines - 1];
            // Toggle function
            var expanded = false;
            $self.toggle = function () {
                $self.empty();
                var $toggleButton = $('<a href="#" class="toggle"></a>');
                if (expanded) {
                    $self.html(expandedText + " ");
                    $toggleButton.text(lessText);
                    $toggleButton.switchClass("less", "more");
                }
                else {
                    $self.html(collapsedText + "&hellip; ");
                    $toggleButton.text(moreText);
                    $toggleButton.switchClass("more", "less");
                }
                $toggleButton.one('click', function (e) {
                    e.preventDefault();
                    $self.toggle();
                });
                expanded = !expanded;
                $self.append($toggleButton);
                if (cb)
                    cb();
            };
            $self.toggle();
        });
    };
    $.fn.toggleText = function (text1, text2) {
        return this.each(function () {
            var $self = $(this);
            if ($self.text() === text1) {
                $(this).text(text2);
            }
            else {
                $(this).text(text1);
            }
        });
    };
    $.fn.updateAttr = function (attrName, oldVal, newVal) {
        return this.each(function () {
            var $self = $(this);
            var attr = $self.attr(attrName);
            if (attr && attr.indexOf(oldVal) === 0) {
                attr = attr.replace(oldVal, newVal);
                $self.attr(attrName, attr);
            }
        });
    };
    $.fn.verticalMargins = function () {
        var $self = $(this);
        return parseInt($self.css('marginTop')) + parseInt($self.css('marginBottom'));
    };
    $.fn.verticalPadding = function () {
        var $self = $(this);
        return parseInt($self.css('paddingTop')) + parseInt($self.css('paddingBottom'));
    };
})(jQuery);

define("lib/jquery-plugins.js", function(){});

/*! Tiny Pub/Sub - v0.7.0 - 2018-10-11
* https://github.com/cowboy/jquery-tiny-pubsub
* Copyright (c) 2018 "Cowboy" Ben Alman; Licensed MIT */
(function($) {

  var o = null;

  $.initPubSub = function() {
    o = $({});
  };

  $.subscribe = function() {
    if (!o) {
      $.initPubSub();
    }

    o.on.apply(o, arguments);
  };

  $.unsubscribe = function() {
    if (!o) {
      $.initPubSub();
    }

    o.off.apply(o, arguments);
  };

  $.disposePubSub = function() {
    o = null;
  };

  $.publish = function() {
    if (!o) {
      $.initPubSub();
    }

    o.trigger.apply(o, arguments);
  };

}(jQuery));
define("lib/ba-tiny-pubsub.js", function(){});

// manifesto v3.0.12 https://github.com/iiif-commons/manifesto
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('lib/manifesto.js',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.manifesto = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){

var Manifesto;
(function (Manifesto) {
    var StringValue = /** @class */ (function () {
        function StringValue(value) {
            this.value = "";
            if (value) {
                this.value = value.toLowerCase();
            }
        }
        StringValue.prototype.toString = function () {
            return this.value;
        };
        return StringValue;
    }());
    Manifesto.StringValue = StringValue;
})(Manifesto || (Manifesto = {}));

var Manifesto;
(function (Manifesto) {
    var Duration = /** @class */ (function () {
        function Duration(start, end) {
            this.start = start;
            this.end = end;
        }
        Duration.prototype.getLength = function () {
            return this.end - this.start;
        };
        return Duration;
    }());
    Manifesto.Duration = Duration;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var AnnotationMotivation = /** @class */ (function (_super) {
        __extends(AnnotationMotivation, _super);
        function AnnotationMotivation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        AnnotationMotivation.prototype.bookmarking = function () {
            return new AnnotationMotivation(AnnotationMotivation.BOOKMARKING.toString());
        };
        AnnotationMotivation.prototype.classifying = function () {
            return new AnnotationMotivation(AnnotationMotivation.CLASSIFYING.toString());
        };
        AnnotationMotivation.prototype.commenting = function () {
            return new AnnotationMotivation(AnnotationMotivation.COMMENTING.toString());
        };
        AnnotationMotivation.prototype.describing = function () {
            return new AnnotationMotivation(AnnotationMotivation.DESCRIBING.toString());
        };
        AnnotationMotivation.prototype.editing = function () {
            return new AnnotationMotivation(AnnotationMotivation.EDITING.toString());
        };
        AnnotationMotivation.prototype.highlighting = function () {
            return new AnnotationMotivation(AnnotationMotivation.HIGHLIGHTING.toString());
        };
        AnnotationMotivation.prototype.identifying = function () {
            return new AnnotationMotivation(AnnotationMotivation.IDENTIFYING.toString());
        };
        AnnotationMotivation.prototype.linking = function () {
            return new AnnotationMotivation(AnnotationMotivation.LINKING.toString());
        };
        AnnotationMotivation.prototype.moderating = function () {
            return new AnnotationMotivation(AnnotationMotivation.MODERATING.toString());
        };
        AnnotationMotivation.prototype.painting = function () {
            return new AnnotationMotivation(AnnotationMotivation.PAINTING.toString());
        };
        AnnotationMotivation.prototype.questioning = function () {
            return new AnnotationMotivation(AnnotationMotivation.QUESTIONING.toString());
        };
        AnnotationMotivation.prototype.replying = function () {
            return new AnnotationMotivation(AnnotationMotivation.REPLYING.toString());
        };
        AnnotationMotivation.prototype.tagging = function () {
            return new AnnotationMotivation(AnnotationMotivation.TAGGING.toString());
        };
        AnnotationMotivation.prototype.transcribing = function () {
            return new AnnotationMotivation(AnnotationMotivation.TRANSCRIBING.toString());
        };
        AnnotationMotivation.BOOKMARKING = new AnnotationMotivation("oa:bookmarking");
        AnnotationMotivation.CLASSIFYING = new AnnotationMotivation("oa:classifying");
        AnnotationMotivation.COMMENTING = new AnnotationMotivation("oa:commenting");
        AnnotationMotivation.DESCRIBING = new AnnotationMotivation("oa:describing");
        AnnotationMotivation.EDITING = new AnnotationMotivation("oa:editing");
        AnnotationMotivation.HIGHLIGHTING = new AnnotationMotivation("oa:highlighting");
        AnnotationMotivation.IDENTIFYING = new AnnotationMotivation("oa:identifying");
        AnnotationMotivation.LINKING = new AnnotationMotivation("oa:linking");
        AnnotationMotivation.MODERATING = new AnnotationMotivation("oa:moderating");
        AnnotationMotivation.PAINTING = new AnnotationMotivation("sc:painting");
        AnnotationMotivation.QUESTIONING = new AnnotationMotivation("oa:questioning");
        AnnotationMotivation.REPLYING = new AnnotationMotivation("oa:replying");
        AnnotationMotivation.TAGGING = new AnnotationMotivation("oa:tagging");
        AnnotationMotivation.TRANSCRIBING = new AnnotationMotivation("oad:transcribing");
        return AnnotationMotivation;
    }(Manifesto.StringValue));
    Manifesto.AnnotationMotivation = AnnotationMotivation;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Behavior = /** @class */ (function (_super) {
        __extends(Behavior, _super);
        function Behavior() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        Behavior.prototype.autoadvance = function () {
            return new Behavior(Behavior.AUTOADVANCE.toString());
        };
        Behavior.prototype.nonav = function () {
            return new Behavior(Behavior.NONAV.toString());
        };
        Behavior.prototype.paged = function () {
            return new Behavior(Behavior.PAGED.toString());
        };
        Behavior.AUTOADVANCE = new Behavior("auto-advance");
        Behavior.NONAV = new Behavior("no-nav");
        Behavior.PAGED = new Behavior("paged");
        return Behavior;
    }(Manifesto.StringValue));
    Manifesto.Behavior = Behavior;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var IIIFResourceType = /** @class */ (function (_super) {
        __extends(IIIFResourceType, _super);
        function IIIFResourceType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        IIIFResourceType.prototype.annotation = function () {
            return new IIIFResourceType(IIIFResourceType.ANNOTATION.toString());
        };
        IIIFResourceType.prototype.canvas = function () {
            return new IIIFResourceType(IIIFResourceType.CANVAS.toString());
        };
        IIIFResourceType.prototype.collection = function () {
            return new IIIFResourceType(IIIFResourceType.COLLECTION.toString());
        };
        IIIFResourceType.prototype.manifest = function () {
            return new IIIFResourceType(IIIFResourceType.MANIFEST.toString());
        };
        IIIFResourceType.prototype.range = function () {
            return new IIIFResourceType(IIIFResourceType.RANGE.toString());
        };
        IIIFResourceType.prototype.sequence = function () {
            return new IIIFResourceType(IIIFResourceType.SEQUENCE.toString());
        };
        IIIFResourceType.ANNOTATION = new IIIFResourceType("annotation");
        IIIFResourceType.CANVAS = new IIIFResourceType("canvas");
        IIIFResourceType.COLLECTION = new IIIFResourceType("collection");
        IIIFResourceType.MANIFEST = new IIIFResourceType("manifest");
        IIIFResourceType.RANGE = new IIIFResourceType("range");
        IIIFResourceType.SEQUENCE = new IIIFResourceType("sequence");
        return IIIFResourceType;
    }(Manifesto.StringValue));
    Manifesto.IIIFResourceType = IIIFResourceType;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var ManifestType = /** @class */ (function (_super) {
        __extends(ManifestType, _super);
        function ManifestType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        ManifestType.prototype.empty = function () {
            return new ManifestType(ManifestType.EMPTY.toString());
        };
        ManifestType.prototype.manuscript = function () {
            return new ManifestType(ManifestType.MANUSCRIPT.toString());
        };
        ManifestType.prototype.monograph = function () {
            return new ManifestType(ManifestType.MONOGRAPH.toString());
        };
        ManifestType.EMPTY = new ManifestType("");
        ManifestType.MANUSCRIPT = new ManifestType("manuscript");
        ManifestType.MONOGRAPH = new ManifestType("monograph");
        return ManifestType;
    }(Manifesto.StringValue));
    Manifesto.ManifestType = ManifestType;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var RenderingFormat = /** @class */ (function (_super) {
        __extends(RenderingFormat, _super);
        function RenderingFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        RenderingFormat.prototype.pdf = function () {
            return new RenderingFormat(RenderingFormat.PDF.toString());
        };
        RenderingFormat.prototype.doc = function () {
            return new RenderingFormat(RenderingFormat.DOC.toString());
        };
        RenderingFormat.prototype.docx = function () {
            return new RenderingFormat(RenderingFormat.DOCX.toString());
        };
        RenderingFormat.PDF = new RenderingFormat("application/pdf");
        RenderingFormat.DOC = new RenderingFormat("application/msword");
        RenderingFormat.DOCX = new RenderingFormat("application/vnd.openxmlformats-officedocument.wordprocessingml.document");
        return RenderingFormat;
    }(Manifesto.StringValue));
    Manifesto.RenderingFormat = RenderingFormat;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var MediaType = /** @class */ (function (_super) {
        __extends(MediaType, _super);
        function MediaType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        MediaType.prototype.jpg = function () {
            return new MediaType(MediaType.JPG.toString());
        };
        MediaType.prototype.mp4 = function () {
            return new MediaType(MediaType.MP4.toString());
        };
        MediaType.prototype.pdf = function () {
            return new MediaType(MediaType.PDF.toString());
        };
        MediaType.prototype.threejs = function () {
            return new MediaType(MediaType.THREEJS.toString());
        };
        MediaType.prototype.webm = function () {
            return new MediaType(MediaType.WEBM.toString());
        };
        MediaType.JPG = new MediaType("image/jpeg");
        MediaType.MP4 = new MediaType("video/mp4");
        MediaType.PDF = new MediaType("application/pdf");
        MediaType.THREEJS = new MediaType("application/vnd.threejs+json");
        MediaType.WEBM = new MediaType("video/webm");
        return MediaType;
    }(Manifesto.StringValue));
    Manifesto.MediaType = MediaType;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var ResourceType = /** @class */ (function (_super) {
        __extends(ResourceType, _super);
        function ResourceType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        ResourceType.prototype.canvas = function () {
            return new ResourceType(ResourceType.CANVAS.toString());
        };
        ResourceType.prototype.choice = function () {
            return new ResourceType(ResourceType.CHOICE.toString());
        };
        ResourceType.prototype.document = function () {
            return new ResourceType(ResourceType.DOCUMENT.toString());
        };
        ResourceType.prototype.image = function () {
            return new ResourceType(ResourceType.IMAGE.toString());
        };
        ResourceType.prototype.movingimage = function () {
            return new ResourceType(ResourceType.MOVINGIMAGE.toString());
        };
        ResourceType.prototype.physicalobject = function () {
            return new ResourceType(ResourceType.PHYSICALOBJECT.toString());
        };
        ResourceType.prototype.sound = function () {
            return new ResourceType(ResourceType.SOUND.toString());
        };
        ResourceType.prototype.text = function () {
            return new ResourceType(ResourceType.TEXT.toString());
        };
        ResourceType.CANVAS = new ResourceType("canvas");
        ResourceType.CHOICE = new ResourceType("choice");
        ResourceType.DOCUMENT = new ResourceType("document");
        ResourceType.IMAGE = new ResourceType("image");
        ResourceType.MOVINGIMAGE = new ResourceType("movingimage");
        ResourceType.PHYSICALOBJECT = new ResourceType("physicalobject");
        ResourceType.SOUND = new ResourceType("sound");
        ResourceType.TEXT = new ResourceType("textualbody");
        return ResourceType;
    }(Manifesto.StringValue));
    Manifesto.ResourceType = ResourceType;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var ServiceProfile = /** @class */ (function (_super) {
        __extends(ServiceProfile, _super);
        function ServiceProfile() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        ServiceProfile.prototype.auth1Clickthrough = function () {
            return new ServiceProfile(ServiceProfile.AUTH1CLICKTHROUGH.toString());
        };
        ServiceProfile.prototype.auth1External = function () {
            return new ServiceProfile(ServiceProfile.AUTH1EXTERNAL.toString());
        };
        ServiceProfile.prototype.auth1Kiosk = function () {
            return new ServiceProfile(ServiceProfile.AUTH1KIOSK.toString());
        };
        ServiceProfile.prototype.auth1Login = function () {
            return new ServiceProfile(ServiceProfile.AUTH1LOGIN.toString());
        };
        ServiceProfile.prototype.auth1Logout = function () {
            return new ServiceProfile(ServiceProfile.AUTH1LOGOUT.toString());
        };
        ServiceProfile.prototype.auth1Probe = function () {
            return new ServiceProfile(ServiceProfile.AUTH1PROBE.toString());
        };
        ServiceProfile.prototype.auth1Token = function () {
            return new ServiceProfile(ServiceProfile.AUTH1TOKEN.toString());
        };
        ServiceProfile.prototype.autoComplete = function () {
            return new ServiceProfile(ServiceProfile.AUTOCOMPLETE.toString());
        };
        ServiceProfile.prototype.iiif1ImageLevel1 = function () {
            return new ServiceProfile(ServiceProfile.IIIF1IMAGELEVEL1.toString());
        };
        ServiceProfile.prototype.iiif1ImageLevel2 = function () {
            return new ServiceProfile(ServiceProfile.IIIF1IMAGELEVEL2.toString());
        };
        ServiceProfile.prototype.iiif2ImageLevel1 = function () {
            return new ServiceProfile(ServiceProfile.IIIF2IMAGELEVEL1.toString());
        };
        ServiceProfile.prototype.iiif2ImageLevel2 = function () {
            return new ServiceProfile(ServiceProfile.IIIF2IMAGELEVEL2.toString());
        };
        ServiceProfile.prototype.ixif = function () {
            return new ServiceProfile(ServiceProfile.IXIF.toString());
        };
        ServiceProfile.prototype.login = function () {
            return new ServiceProfile(ServiceProfile.AUTHLOGIN.toString());
        };
        ServiceProfile.prototype.clickThrough = function () {
            return new ServiceProfile(ServiceProfile.AUTHCLICKTHROUGH.toString());
        };
        ServiceProfile.prototype.restricted = function () {
            return new ServiceProfile(ServiceProfile.AUTHRESTRICTED.toString());
        };
        ServiceProfile.prototype.logout = function () {
            return new ServiceProfile(ServiceProfile.AUTHLOGOUT.toString());
        };
        ServiceProfile.prototype.otherManifestations = function () {
            return new ServiceProfile(ServiceProfile.OTHERMANIFESTATIONS.toString());
        };
        ServiceProfile.prototype.search = function () {
            return new ServiceProfile(ServiceProfile.SEARCH.toString());
        };
        ServiceProfile.prototype.stanfordIIIFImageCompliance1 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE1.toString());
        };
        ServiceProfile.prototype.stanfordIIIFImageCompliance2 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE2.toString());
        };
        ServiceProfile.prototype.stanfordIIIFImageConformance1 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIFIMAGECONFORMANCE1.toString());
        };
        ServiceProfile.prototype.stanfordIIIFImageConformance2 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIFIMAGECONFORMANCE2.toString());
        };
        ServiceProfile.prototype.stanfordIIIF1ImageCompliance1 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE1.toString());
        };
        ServiceProfile.prototype.stanfordIIIF1ImageCompliance2 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE2.toString());
        };
        ServiceProfile.prototype.stanfordIIIF1ImageConformance1 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE1.toString());
        };
        ServiceProfile.prototype.stanfordIIIF1ImageConformance2 = function () {
            return new ServiceProfile(ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE2.toString());
        };
        ServiceProfile.prototype.token = function () {
            return new ServiceProfile(ServiceProfile.AUTHTOKEN.toString());
        };
        ServiceProfile.prototype.trackingExtensions = function () {
            return new ServiceProfile(ServiceProfile.TRACKINGEXTENSIONS.toString());
        };
        ServiceProfile.prototype.uiExtensions = function () {
            return new ServiceProfile(ServiceProfile.UIEXTENSIONS.toString());
        };
        ServiceProfile.prototype.printExtensions = function () {
            return new ServiceProfile(ServiceProfile.PRINTEXTENSIONS.toString());
        };
        ServiceProfile.prototype.shareExtensions = function () {
            return new ServiceProfile(ServiceProfile.SHAREEXTENSIONS.toString());
        };
        // image api
        ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE0 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/compliance.html#level0");
        ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE1 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/compliance.html#level1");
        ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE2 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/compliance.html#level2");
        ServiceProfile.STANFORDIIIFIMAGECONFORMANCE0 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/conformance.html#level0");
        ServiceProfile.STANFORDIIIFIMAGECONFORMANCE1 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/conformance.html#level1");
        ServiceProfile.STANFORDIIIFIMAGECONFORMANCE2 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/conformance.html#level2");
        ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE0 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0");
        ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE1 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1");
        ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE2 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2");
        ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE0 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0");
        ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE1 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1");
        ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE2 = new ServiceProfile("http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2");
        ServiceProfile.IIIF1IMAGELEVEL0 = new ServiceProfile("http://iiif.io/api/image/1/level0.json");
        ServiceProfile.IIIF1IMAGELEVEL0PROFILE = new ServiceProfile("http://iiif.io/api/image/1/profiles/level0.json");
        ServiceProfile.IIIF1IMAGELEVEL1 = new ServiceProfile("http://iiif.io/api/image/1/level1.json");
        ServiceProfile.IIIF1IMAGELEVEL1PROFILE = new ServiceProfile("http://iiif.io/api/image/1/profiles/level1.json");
        ServiceProfile.IIIF1IMAGELEVEL2 = new ServiceProfile("http://iiif.io/api/image/1/level2.json");
        ServiceProfile.IIIF1IMAGELEVEL2PROFILE = new ServiceProfile("http://iiif.io/api/image/1/profiles/level2.json");
        ServiceProfile.IIIF2IMAGELEVEL0 = new ServiceProfile("http://iiif.io/api/image/2/level0.json");
        ServiceProfile.IIIF2IMAGELEVEL0PROFILE = new ServiceProfile("http://iiif.io/api/image/2/profiles/level0.json");
        ServiceProfile.IIIF2IMAGELEVEL1 = new ServiceProfile("http://iiif.io/api/image/2/level1.json");
        ServiceProfile.IIIF2IMAGELEVEL1PROFILE = new ServiceProfile("http://iiif.io/api/image/2/profiles/level1.json");
        ServiceProfile.IIIF2IMAGELEVEL2 = new ServiceProfile("http://iiif.io/api/image/2/level2.json");
        ServiceProfile.IIIF2IMAGELEVEL2PROFILE = new ServiceProfile("http://iiif.io/api/image/2/profiles/level2.json");
        // auth api
        ServiceProfile.AUTHCLICKTHROUGH = new ServiceProfile("http://iiif.io/api/auth/0/login/clickthrough");
        ServiceProfile.AUTHLOGIN = new ServiceProfile("http://iiif.io/api/auth/0/login");
        ServiceProfile.AUTHLOGOUT = new ServiceProfile("http://iiif.io/api/auth/0/logout");
        ServiceProfile.AUTHRESTRICTED = new ServiceProfile("http://iiif.io/api/auth/0/login/restricted");
        ServiceProfile.AUTHTOKEN = new ServiceProfile("http://iiif.io/api/auth/0/token");
        ServiceProfile.AUTH1CLICKTHROUGH = new ServiceProfile("http://iiif.io/api/auth/1/clickthrough");
        ServiceProfile.AUTH1EXTERNAL = new ServiceProfile("http://iiif.io/api/auth/1/external");
        ServiceProfile.AUTH1KIOSK = new ServiceProfile("http://iiif.io/api/auth/1/kiosk");
        ServiceProfile.AUTH1LOGIN = new ServiceProfile("http://iiif.io/api/auth/1/login");
        ServiceProfile.AUTH1LOGOUT = new ServiceProfile("http://iiif.io/api/auth/1/logout");
        ServiceProfile.AUTH1PROBE = new ServiceProfile("http://iiif.io/api/auth/1/probe");
        ServiceProfile.AUTH1TOKEN = new ServiceProfile("http://iiif.io/api/auth/1/token");
        // search api
        ServiceProfile.AUTOCOMPLETE = new ServiceProfile("http://iiif.io/api/search/0/autocomplete");
        ServiceProfile.SEARCH = new ServiceProfile("http://iiif.io/api/search/0/search");
        // extensions
        ServiceProfile.TRACKINGEXTENSIONS = new ServiceProfile("http://universalviewer.io/tracking-extensions-profile");
        ServiceProfile.UIEXTENSIONS = new ServiceProfile("http://universalviewer.io/ui-extensions-profile");
        ServiceProfile.PRINTEXTENSIONS = new ServiceProfile("http://universalviewer.io/print-extensions-profile");
        ServiceProfile.SHAREEXTENSIONS = new ServiceProfile("http://universalviewer.io/share-extensions-profile");
        // other
        ServiceProfile.OTHERMANIFESTATIONS = new ServiceProfile("http://iiif.io/api/otherManifestations.json");
        ServiceProfile.IXIF = new ServiceProfile("http://wellcomelibrary.org/ld/ixif/0/alpha.json");
        return ServiceProfile;
    }(Manifesto.StringValue));
    Manifesto.ServiceProfile = ServiceProfile;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var ViewingDirection = /** @class */ (function (_super) {
        __extends(ViewingDirection, _super);
        function ViewingDirection() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        ViewingDirection.prototype.leftToRight = function () {
            return new ViewingDirection(ViewingDirection.LEFTTORIGHT.toString());
        };
        ViewingDirection.prototype.rightToLeft = function () {
            return new ViewingDirection(ViewingDirection.RIGHTTOLEFT.toString());
        };
        ViewingDirection.prototype.topToBottom = function () {
            return new ViewingDirection(ViewingDirection.TOPTOBOTTOM.toString());
        };
        ViewingDirection.prototype.bottomToTop = function () {
            return new ViewingDirection(ViewingDirection.BOTTOMTOTOP.toString());
        };
        ViewingDirection.LEFTTORIGHT = new ViewingDirection("left-to-right");
        ViewingDirection.RIGHTTOLEFT = new ViewingDirection("right-to-left");
        ViewingDirection.TOPTOBOTTOM = new ViewingDirection("top-to-bottom");
        ViewingDirection.BOTTOMTOTOP = new ViewingDirection("bottom-to-top");
        return ViewingDirection;
    }(Manifesto.StringValue));
    Manifesto.ViewingDirection = ViewingDirection;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var ViewingHint = /** @class */ (function (_super) {
        __extends(ViewingHint, _super);
        function ViewingHint() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        ViewingHint.prototype.continuous = function () {
            return new ViewingHint(ViewingHint.CONTINUOUS.toString());
        };
        ViewingHint.prototype.empty = function () {
            return new ViewingHint(ViewingHint.EMPTY.toString());
        };
        ViewingHint.prototype.individuals = function () {
            return new ViewingHint(ViewingHint.INDIVIDUALS.toString());
        };
        ViewingHint.prototype.nonPaged = function () {
            return new ViewingHint(ViewingHint.NONPAGED.toString());
        };
        ViewingHint.prototype.paged = function () {
            return new ViewingHint(ViewingHint.PAGED.toString());
        };
        ViewingHint.prototype.top = function () {
            return new ViewingHint(ViewingHint.TOP.toString());
        };
        ViewingHint.CONTINUOUS = new ViewingHint("continuous");
        ViewingHint.EMPTY = new ViewingHint("");
        ViewingHint.INDIVIDUALS = new ViewingHint("individuals");
        ViewingHint.NONPAGED = new ViewingHint("non-paged");
        ViewingHint.PAGED = new ViewingHint("paged");
        ViewingHint.TOP = new ViewingHint("top");
        return ViewingHint;
    }(Manifesto.StringValue));
    Manifesto.ViewingHint = ViewingHint;
})(Manifesto || (Manifesto = {}));

var Manifesto;
(function (Manifesto) {
    var JSONLDResource = /** @class */ (function () {
        function JSONLDResource(jsonld) {
            this.__jsonld = jsonld;
            this.context = this.getProperty('context');
            this.id = this.getProperty('id');
        }
        JSONLDResource.prototype.getProperty = function (name) {
            var prop = null;
            if (this.__jsonld) {
                prop = this.__jsonld[name];
                if (!prop) {
                    // property may have a prepended '@'
                    prop = this.__jsonld['@' + name];
                }
            }
            return prop;
        };
        return JSONLDResource;
    }());
    Manifesto.JSONLDResource = JSONLDResource;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var ManifestResource = /** @class */ (function (_super) {
        __extends(ManifestResource, _super);
        function ManifestResource(jsonld, options) {
            var _this = _super.call(this, jsonld) || this;
            _this.options = options;
            return _this;
        }
        ManifestResource.prototype.getIIIFResourceType = function () {
            return new Manifesto.IIIFResourceType(Manifesto.Utils.normaliseType(this.getProperty('type')));
        };
        ManifestResource.prototype.getLabel = function () {
            var label = this.getProperty('label');
            if (label) {
                return Manifesto.LanguageMap.parse(label, this.options.locale);
            }
            return [];
        };
        ManifestResource.prototype.getDefaultLabel = function () {
            return Manifesto.LanguageMap.getValue(this.getLabel());
        };
        ManifestResource.prototype.getMetadata = function () {
            var _metadata = this.getProperty('metadata');
            var metadata = [];
            if (!_metadata)
                return metadata;
            for (var i = 0; i < _metadata.length; i++) {
                var item = _metadata[i];
                var metadataItem = new Manifesto.LabelValuePair(this.options.locale);
                metadataItem.parse(item);
                metadata.push(metadataItem);
            }
            return metadata;
        };
        ManifestResource.prototype.getRendering = function (format) {
            var renderings = this.getRenderings();
            // normalise format to string
            if (typeof (format) !== 'string') {
                format = format.toString();
            }
            for (var i = 0; i < renderings.length; i++) {
                var rendering = renderings[i];
                if (rendering.getFormat().toString() === format) {
                    return rendering;
                }
            }
            return null;
        };
        ManifestResource.prototype.getRenderings = function () {
            var rendering;
            // if passing a manifesto-parsed object, use the __jsonld.rendering property,
            // otherwise look for a rendering property
            if (this.__jsonld) {
                rendering = this.__jsonld.rendering;
            }
            else {
                rendering = this.rendering;
            }
            var renderings = [];
            if (!rendering)
                return renderings;
            // coerce to array
            if (!Array.isArray(rendering)) {
                rendering = [rendering];
            }
            for (var i = 0; i < rendering.length; i++) {
                var r = rendering[i];
                renderings.push(new Manifesto.Rendering(r, this.options));
            }
            return renderings;
        };
        ManifestResource.prototype.getService = function (profile) {
            return Manifesto.Utils.getService(this, profile);
        };
        ManifestResource.prototype.getServices = function () {
            return Manifesto.Utils.getServices(this);
        };
        ManifestResource.prototype.getThumbnail = function () {
            var thumbnail = this.getProperty('thumbnail');
            if (Array.isArray(thumbnail)) {
                thumbnail = thumbnail[0];
            }
            if (thumbnail) {
                return new Manifesto.Thumbnail(thumbnail, this.options);
            }
            return null;
        };
        ManifestResource.prototype.isAnnotation = function () {
            return this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.ANNOTATION.toString();
        };
        ManifestResource.prototype.isCanvas = function () {
            return this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.CANVAS.toString();
        };
        ManifestResource.prototype.isCollection = function () {
            return this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.COLLECTION.toString();
        };
        ManifestResource.prototype.isManifest = function () {
            return this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.MANIFEST.toString();
        };
        ManifestResource.prototype.isRange = function () {
            return this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.RANGE.toString();
        };
        ManifestResource.prototype.isSequence = function () {
            return this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.SEQUENCE.toString();
        };
        return ManifestResource;
    }(Manifesto.JSONLDResource));
    Manifesto.ManifestResource = ManifestResource;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Resource = /** @class */ (function (_super) {
        __extends(Resource, _super);
        function Resource(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        Resource.prototype.getFormat = function () {
            var format = this.getProperty('format');
            if (format) {
                return new Manifesto.MediaType(format.toLowerCase());
            }
            return null;
        };
        Resource.prototype.getResources = function () {
            var resources = [];
            if (!this.__jsonld.resources)
                return resources;
            for (var i = 0; i < this.__jsonld.resources.length; i++) {
                var a = this.__jsonld.resources[i];
                var annotation = new Manifesto.Annotation(a, this.options);
                resources.push(annotation);
            }
            return resources;
        };
        Resource.prototype.getType = function () {
            var type = this.getProperty('type');
            if (type) {
                return new Manifesto.ResourceType(Manifesto.Utils.normaliseType(type));
            }
            return null;
        };
        Resource.prototype.getWidth = function () {
            return this.getProperty('width');
        };
        Resource.prototype.getHeight = function () {
            return this.getProperty('height');
        };
        Resource.prototype.getMaxWidth = function () {
            return this.getProperty('maxWidth');
        };
        Resource.prototype.getMaxHeight = function () {
            var maxHeight = this.getProperty('maxHeight');
            // if a maxHeight hasn't been specified, default to maxWidth.
            // maxWidth in essence becomes maxEdge
            if (!maxHeight) {
                return this.getMaxWidth();
            }
            return null;
        };
        return Resource;
    }(Manifesto.ManifestResource));
    Manifesto.Resource = Resource;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Canvas = /** @class */ (function (_super) {
        __extends(Canvas, _super);
        function Canvas(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        // http://iiif.io/api/image/2.1/#canonical-uri-syntax
        Canvas.prototype.getCanonicalImageUri = function (w) {
            var id = null;
            var region = 'full';
            var rotation = 0;
            var quality = 'default';
            var width = w;
            var size;
            // if an info.json has been loaded
            if (this.externalResource && this.externalResource.data && this.externalResource.data['@id']) {
                id = this.externalResource.data['@id'];
                if (!width) {
                    width = this.externalResource.data.width;
                }
                if (this.externalResource.data['@context']) {
                    if (this.externalResource.data['@context'].indexOf('/1.0/context.json') > -1 ||
                        this.externalResource.data['@context'].indexOf('/1.1/context.json') > -1 ||
                        this.externalResource.data['@context'].indexOf('/1/context.json') > -1) {
                        quality = 'native';
                    }
                }
            }
            else {
                // info.json hasn't been loaded yet
                var images = this.getImages();
                if (images && images.length) {
                    var firstImage = images[0];
                    var resource = firstImage.getResource();
                    var services = resource.getServices();
                    if (!width) {
                        width = resource.getWidth();
                    }
                    if (services.length) {
                        var service = services[0];
                        id = service.id;
                        quality = Manifesto.Utils.getImageQuality(service.getProfile());
                    }
                    else if (width === resource.getWidth()) {
                        // if the passed width is the same as the resource width
                        // i.e. not looking for a thumbnail
                        // return the full size image.
                        // used for download options when loading static images.
                        return resource.id;
                    }
                }
                // todo: should this be moved to getThumbUri?
                if (!id) {
                    var thumbnail = this.getProperty('thumbnail');
                    if (thumbnail) {
                        if (typeof (thumbnail) === 'string') {
                            return thumbnail;
                        }
                        else {
                            if (thumbnail['@id']) {
                                return thumbnail['@id'];
                            }
                            else if (thumbnail.length) {
                                return thumbnail[0].id;
                            }
                        }
                    }
                }
            }
            size = width + ',';
            // trim off trailing '/'
            if (id && id.endsWith('/')) {
                id = id.substr(0, id.length - 1);
            }
            var uri = [id, region, size, rotation, quality + '.jpg'].join('/');
            return uri;
        };
        Canvas.prototype.getMaxDimensions = function () {
            var maxDimensions = null;
            var profile;
            if (this.externalResource && this.externalResource.data && this.externalResource.data.profile) {
                profile = this.externalResource.data.profile;
                if (Array.isArray(profile)) {
                    profile = profile.filter(function (p) { return p["maxWidth" || "maxwidth"]; })[0];
                    if (profile) {
                        maxDimensions = new Manifesto.Size(profile.maxWidth, profile.maxHeight ? profile.maxHeight : profile.maxWidth);
                    }
                }
            }
            return maxDimensions;
        };
        // Presentation API 3.0
        Canvas.prototype.getContent = function () {
            var content = [];
            var items = this.__jsonld.items || this.__jsonld.content;
            if (!items)
                return content;
            // should be contained in an AnnotationPage
            var annotationPage = null;
            if (items.length) {
                annotationPage = new Manifesto.AnnotationPage(items[0], this.options);
            }
            if (!annotationPage) {
                return content;
            }
            var annotations = annotationPage.getItems();
            for (var i = 0; i < annotations.length; i++) {
                var a = annotations[i];
                var annotation = new Manifesto.Annotation(a, this.options);
                content.push(annotation);
            }
            return content;
        };
        Canvas.prototype.getDuration = function () {
            return this.getProperty('duration');
        };
        Canvas.prototype.getImages = function () {
            var images = [];
            if (!this.__jsonld.images)
                return images;
            for (var i = 0; i < this.__jsonld.images.length; i++) {
                var a = this.__jsonld.images[i];
                var annotation = new Manifesto.Annotation(a, this.options);
                images.push(annotation);
            }
            return images;
        };
        Canvas.prototype.getIndex = function () {
            return this.getProperty('index');
        };
        Canvas.prototype.getOtherContent = function () {
            var _this = this;
            var otherContent = Array.isArray(this.getProperty('otherContent')) ?
                this.getProperty('otherContent') :
                [this.getProperty('otherContent')];
            var canonicalComparison = function (typeA, typeB) {
                if (typeof typeA !== 'string' || typeof typeB !== 'string') {
                    return false;
                }
                return typeA.toLowerCase() === typeA.toLowerCase();
            };
            var otherPromises = otherContent
                .filter(function (otherContent) { return otherContent && canonicalComparison(otherContent['@type'], 'sc:AnnotationList'); })
                .map(function (annotationList, i) { return ((new Manifesto.AnnotationList(annotationList['label'] || "Annotation list " + i, annotationList, _this.options))); })
                .map(function (annotationList) { return annotationList.load(); });
            return Promise.all(otherPromises);
        };
        // Prefer thumbnail service to image service if supplied and if
        // the thumbnail service can provide a satisfactory size +/- x pixels.
        // this is used to get thumb URIs *before* the info.json has been requested
        // and populate thumbnails in a viewer.
        // the publisher may also provide pre-computed fixed-size thumbs for better performance.
        //getThumbUri(width: number): string {
        //
        //    var uri;
        //    var images: IAnnotation[] = this.getImages();
        //
        //    if (images && images.length) {
        //        var firstImage = images[0];
        //        var resource: IResource = firstImage.getResource();
        //        var services: IService[] = resource.getServices();
        //
        //        for (let i = 0; i < services.length; i++) {
        //            var service: IService = services[i];
        //            var id = service.id;
        //
        //            if (!_endsWith(id, '/')) {
        //                id += '/';
        //            }
        //
        //            uri = id + 'full/' + width + ',/0/' + Utils.getImageQuality(service.getProfile()) + '.jpg';
        //        }
        //    }
        //
        //    return uri;
        //}
        //getType(): CanvasType {
        //    return new CanvasType(this.getProperty('@type').toLowerCase());
        //}
        Canvas.prototype.getWidth = function () {
            return this.getProperty('width');
        };
        Canvas.prototype.getHeight = function () {
            return this.getProperty('height');
        };
        return Canvas;
    }(Manifesto.Resource));
    Manifesto.Canvas = Canvas;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var IIIFResource = /** @class */ (function (_super) {
        __extends(IIIFResource, _super);
        function IIIFResource(jsonld, options) {
            var _this = _super.call(this, jsonld, options) || this;
            _this.index = -1;
            _this.isLoaded = false;
            var defaultOptions = {
                defaultLabel: '-',
                locale: 'en-GB',
                resource: _this,
                pessimisticAccessControl: false
            };
            _this.options = Object.assign(defaultOptions, options);
            return _this;
        }
        IIIFResource.prototype.getAttribution = function () {
            console.warn('getAttribution will be deprecated, use getRequiredStatement instead.');
            var attribution = this.getProperty('attribution');
            if (attribution) {
                return Manifesto.LanguageMap.parse(attribution, this.options.locale);
            }
            return [];
        };
        IIIFResource.prototype.getDescription = function () {
            var description = this.getProperty('description');
            if (description) {
                return Manifesto.LanguageMap.parse(description, this.options.locale);
            }
            return [];
        };
        IIIFResource.prototype.getIIIFResourceType = function () {
            return new Manifesto.IIIFResourceType(Manifesto.Utils.normaliseType(this.getProperty('type')));
        };
        IIIFResource.prototype.getLogo = function () {
            var logo = this.getProperty('logo');
            if (!logo)
                return null;
            if (typeof (logo) === 'string')
                return logo;
            if (Array.isArray(logo) && logo.length) {
                logo = logo[0];
            }
            return logo['@id'] || logo.id;
        };
        IIIFResource.prototype.getLicense = function () {
            return Manifesto.Utils.getLocalisedValue(this.getProperty('license'), this.options.locale);
        };
        IIIFResource.prototype.getNavDate = function () {
            return new Date(this.getProperty('navDate'));
        };
        IIIFResource.prototype.getRelated = function () {
            return this.getProperty('related');
        };
        IIIFResource.prototype.getSeeAlso = function () {
            return this.getProperty('seeAlso');
        };
        IIIFResource.prototype.getTrackingLabel = function () {
            var service = this.getService(Manifesto.ServiceProfile.TRACKINGEXTENSIONS);
            if (service) {
                return service.getProperty('trackingLabel');
            }
            return '';
        };
        IIIFResource.prototype.getDefaultTree = function () {
            this.defaultTree = new Manifesto.TreeNode('root');
            this.defaultTree.data = this;
            return this.defaultTree;
        };
        IIIFResource.prototype.getRequiredStatement = function () {
            var requiredStatement = null;
            var _requiredStatement = this.getProperty('requiredStatement');
            if (_requiredStatement) {
                requiredStatement = new Manifesto.LabelValuePair(this.options.locale);
                requiredStatement.parse(_requiredStatement);
            }
            else {
                // fall back to attribution (if it exists)
                var attribution = this.getAttribution();
                if (attribution) {
                    requiredStatement = new Manifesto.LabelValuePair(this.options.locale);
                    requiredStatement.value = attribution;
                }
            }
            return requiredStatement;
        };
        IIIFResource.prototype.isCollection = function () {
            if (this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.COLLECTION.toString()) {
                return true;
            }
            return false;
        };
        IIIFResource.prototype.isManifest = function () {
            if (this.getIIIFResourceType().toString() === Manifesto.IIIFResourceType.MANIFEST.toString()) {
                return true;
            }
            return false;
        };
        IIIFResource.prototype.load = function () {
            var that = this;
            return new Promise(function (resolve, reject) {
                if (that.isLoaded) {
                    resolve(that);
                }
                else {
                    var options_1 = that.options;
                    options_1.navDate = that.getNavDate();
                    var id = that.__jsonld.id;
                    if (!id) {
                        id = that.__jsonld['@id'];
                    }
                    Manifesto.Utils.loadResource(id).then(function (data) {
                        that.parentLabel = Manifesto.LanguageMap.getValue(that.getLabel(), options_1.locale);
                        var parsed = Manifesto.Deserialiser.parse(data, options_1);
                        that = Object.assign(that, parsed);
                        //that.parentCollection = options.resource.parentCollection;
                        that.index = options_1.index;
                        resolve(that);
                    });
                }
            });
        };
        return IIIFResource;
    }(Manifesto.ManifestResource));
    Manifesto.IIIFResource = IIIFResource;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Manifest = /** @class */ (function (_super) {
        __extends(Manifest, _super);
        function Manifest(jsonld, options) {
            var _this = _super.call(this, jsonld, options) || this;
            _this.index = 0;
            _this._allRanges = null;
            _this.items = [];
            _this._topRanges = [];
            if (_this.__jsonld.structures && _this.__jsonld.structures.length) {
                var topRanges = _this._getTopRanges();
                for (var i = 0; i < topRanges.length; i++) {
                    var range = topRanges[i];
                    _this._parseRanges(range, String(i));
                }
            }
            return _this;
        }
        Manifest.prototype.getPosterCanvas = function () {
            var posterCanvas = this.getProperty('posterCanvas');
            if (posterCanvas) {
                posterCanvas = new Manifesto.Canvas(posterCanvas, this.options);
            }
            return posterCanvas;
        };
        Manifest.prototype.getBehavior = function () {
            var behavior = this.getProperty('behavior');
            if (Array.isArray(behavior)) {
                behavior = behavior[0];
            }
            if (behavior) {
                return new Manifesto.Behavior(behavior);
            }
            return null;
        };
        Manifest.prototype.getDefaultTree = function () {
            _super.prototype.getDefaultTree.call(this);
            this.defaultTree.data.type = Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.MANIFEST.toString());
            if (!this.isLoaded) {
                return this.defaultTree;
            }
            var topRanges = this.getTopRanges();
            // if there are any ranges in the manifest, default to the first 'top' range or generated placeholder
            if (topRanges.length) {
                topRanges[0].getTree(this.defaultTree);
            }
            Manifesto.Utils.generateTreeNodeIds(this.defaultTree);
            return this.defaultTree;
        };
        Manifest.prototype._getTopRanges = function () {
            var topRanges = [];
            if (this.__jsonld.structures && this.__jsonld.structures.length) {
                for (var i = 0; i < this.__jsonld.structures.length; i++) {
                    var json = this.__jsonld.structures[i];
                    if (json.viewingHint === Manifesto.ViewingHint.TOP.toString()) {
                        topRanges.push(json);
                    }
                }
                // if no viewingHint="top" range was found, create a default one
                if (!topRanges.length) {
                    var range = {};
                    range.ranges = this.__jsonld.structures;
                    topRanges.push(range);
                }
            }
            return topRanges;
        };
        Manifest.prototype.getTopRanges = function () {
            return this._topRanges;
        };
        Manifest.prototype._getRangeById = function (id) {
            if (this.__jsonld.structures && this.__jsonld.structures.length) {
                for (var i = 0; i < this.__jsonld.structures.length; i++) {
                    var r = this.__jsonld.structures[i];
                    if (r['@id'] === id || r.id === id) {
                        return r;
                    }
                }
            }
            return null;
        };
        //private _parseRangeCanvas(json: any, range: IRange): void {
        // todo: currently this isn't needed
        //var canvas: IJSONLDResource = new JSONLDResource(json);
        //range.items.push(<IManifestResource>canvas);
        //}
        Manifest.prototype._parseRanges = function (r, path, parentRange) {
            var range;
            var id = null;
            if (typeof (r) === 'string') {
                id = r;
                r = this._getRangeById(id);
            }
            if (!r) {
                console.warn("Range:", id, "does not exist");
                return;
            }
            range = new Manifesto.Range(r, this.options);
            range.parentRange = parentRange;
            range.path = path;
            if (!parentRange) {
                this._topRanges.push(range);
            }
            else {
                parentRange.items.push(range);
            }
            var items = r.items || r.members;
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    // todo: use an ItemType constant?
                    if (item['@type'] && item['@type'].toLowerCase() === 'sc:range' || item['type'] && item['type'].toLowerCase() === 'range') {
                        this._parseRanges(item, path + '/' + i, range);
                    }
                    else if (item['@type'] && item['@type'].toLowerCase() === 'sc:canvas' || item['type'] && item['type'].toLowerCase() === 'canvas') {
                        // store the ids on the __jsonld object to be used by Range.getCanvasIds()
                        if (!range.canvases) {
                            range.canvases = [];
                        }
                        var id_1 = item.id || item['@id'];
                        range.canvases.push(id_1);
                    }
                }
            }
            else if (r.ranges) {
                for (var i = 0; i < r.ranges.length; i++) {
                    this._parseRanges(r.ranges[i], path + '/' + i, range);
                }
            }
        };
        Manifest.prototype.getAllRanges = function () {
            if (this._allRanges != null)
                return this._allRanges;
            this._allRanges = [];
            var topRanges = this.getTopRanges();
            var _loop_1 = function (i) {
                var topRange = topRanges[i];
                if (topRange.id) {
                    this_1._allRanges.push(topRange); // it might be a placeholder root range
                }
                var reducer = function (acc, next) {
                    acc.add(next);
                    var nextRanges = next.getRanges();
                    if (nextRanges.length) {
                        return nextRanges.reduce(reducer, acc);
                    }
                    return acc;
                };
                var subRanges = Array.from(topRange.getRanges().reduce(reducer, new Set()));
                this_1._allRanges = this_1._allRanges.concat(subRanges);
            };
            var this_1 = this;
            for (var i = 0; i < topRanges.length; i++) {
                _loop_1(i);
            }
            return this._allRanges;
        };
        Manifest.prototype.getRangeById = function (id) {
            var ranges = this.getAllRanges();
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (range.id === id) {
                    return range;
                }
            }
            return null;
        };
        Manifest.prototype.getRangeByPath = function (path) {
            var ranges = this.getAllRanges();
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (range.path === path) {
                    return range;
                }
            }
            return null;
        };
        Manifest.prototype.getSequences = function () {
            if (this.items.length) {
                return this.items;
            }
            // IxIF mediaSequences overrode sequences, so need to be checked first.
            // deprecate this when presentation 3 ships
            var items = this.__jsonld.mediaSequences || this.__jsonld.sequences;
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    var s = items[i];
                    var sequence = new Manifesto.Sequence(s, this.options);
                    this.items.push(sequence);
                }
            }
            else if (this.__jsonld.items) {
                var sequence = new Manifesto.Sequence(this.__jsonld.items, this.options);
                this.items.push(sequence);
            }
            return this.items;
        };
        Manifest.prototype.getSequenceByIndex = function (sequenceIndex) {
            return this.getSequences()[sequenceIndex];
        };
        Manifest.prototype.getTotalSequences = function () {
            return this.getSequences().length;
        };
        Manifest.prototype.getManifestType = function () {
            var service = this.getService(Manifesto.ServiceProfile.UIEXTENSIONS);
            if (service) {
                return new Manifesto.ManifestType(service.getProperty('manifestType'));
            }
            return new Manifesto.ManifestType('');
        };
        Manifest.prototype.isMultiSequence = function () {
            return this.getTotalSequences() > 1;
        };
        Manifest.prototype.isPagingEnabled = function () {
            var viewingHint = this.getViewingHint();
            if (viewingHint) {
                return viewingHint.toString() === Manifesto.ViewingHint.PAGED.toString();
            }
            var behavior = this.getBehavior();
            if (behavior) {
                return behavior.toString() === Manifesto.Behavior.PAGED.toString();
            }
            return false;
        };
        Manifest.prototype.getViewingDirection = function () {
            if (this.getProperty('viewingDirection')) {
                return new Manifesto.ViewingDirection(this.getProperty('viewingDirection'));
            }
            return null;
        };
        Manifest.prototype.getViewingHint = function () {
            if (this.getProperty('viewingHint')) {
                return new Manifesto.ViewingHint(this.getProperty('viewingHint'));
            }
            return null;
        };
        return Manifest;
    }(Manifesto.IIIFResource));
    Manifesto.Manifest = Manifest;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Collection = /** @class */ (function (_super) {
        __extends(Collection, _super);
        function Collection(jsonld, options) {
            var _this = _super.call(this, jsonld, options) || this;
            _this.items = [];
            _this._collections = null;
            _this._manifests = null;
            jsonld.__collection = _this;
            return _this;
        }
        Collection.prototype.getCollections = function () {
            if (this._collections) {
                return this._collections;
            }
            return this._collections = this.items.filter(function (m) { return m.isCollection(); });
        };
        Collection.prototype.getManifests = function () {
            if (this._manifests) {
                return this._manifests;
            }
            return this._manifests = this.items.filter(function (m) { return m.isManifest(); });
        };
        Collection.prototype.getCollectionByIndex = function (collectionIndex) {
            var collections = this.getCollections();
            var collection;
            for (var i = 0; i < collections.length; i++) {
                var c = collections[i];
                if (c.index === collectionIndex) {
                    collection = c;
                }
            }
            if (collection) {
                collection.options.index = collectionIndex;
                // id for collection MUST be dereferenceable
                return collection.load();
            }
            else {
                throw new Error("Collection index not found");
            }
        };
        Collection.prototype.getManifestByIndex = function (manifestIndex) {
            var manifests = this.getManifests();
            var manifest;
            for (var i = 0; i < manifests.length; i++) {
                var m = manifests[i];
                if (m.index === manifestIndex) {
                    manifest = m;
                }
            }
            if (manifest) {
                manifest.options.index = manifestIndex;
                return manifest.load();
            }
            else {
                throw new Error("Manifest index not found");
            }
        };
        Collection.prototype.getTotalCollections = function () {
            return this.getCollections().length;
        };
        Collection.prototype.getTotalManifests = function () {
            return this.getManifests().length;
        };
        Collection.prototype.getTotalItems = function () {
            return this.items.length;
        };
        Collection.prototype.getViewingDirection = function () {
            if (this.getProperty('viewingDirection')) {
                return new Manifesto.ViewingDirection(this.getProperty('viewingDirection'));
            }
            return Manifesto.ViewingDirection.LEFTTORIGHT;
        };
        /**
         * Get a tree of sub collections and manifests, using each child manifest's first 'top' range.
         */
        Collection.prototype.getDefaultTree = function () {
            _super.prototype.getDefaultTree.call(this);
            //console.log("get default tree for ", this.id);
            this.defaultTree.data.type = Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.COLLECTION.toString());
            this._parseManifests(this);
            this._parseCollections(this);
            Manifesto.Utils.generateTreeNodeIds(this.defaultTree);
            return this.defaultTree;
        };
        Collection.prototype._parseManifests = function (parentCollection) {
            //console.log("parse manifests for ", parentCollection.id);
            if (parentCollection.getManifests() && parentCollection.getManifests().length) {
                for (var i = 0; i < parentCollection.getManifests().length; i++) {
                    var manifest = parentCollection.getManifests()[i];
                    var tree = manifest.getDefaultTree();
                    tree.label = manifest.parentLabel || Manifesto.LanguageMap.getValue(manifest.getLabel(), this.options.locale) || 'manifest ' + (i + 1);
                    tree.navDate = manifest.getNavDate();
                    tree.data.id = manifest.id;
                    tree.data.type = Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.MANIFEST.toString());
                    parentCollection.defaultTree.addNode(tree);
                }
            }
        };
        Collection.prototype._parseCollections = function (parentCollection) {
            //console.log("parse collections for ", parentCollection.id);
            if (parentCollection.getCollections() && parentCollection.getCollections().length) {
                for (var i = 0; i < parentCollection.getCollections().length; i++) {
                    var collection = parentCollection.getCollections()[i];
                    var tree = collection.getDefaultTree();
                    tree.label = collection.parentLabel || Manifesto.LanguageMap.getValue(collection.getLabel(), this.options.locale) || 'collection ' + (i + 1);
                    tree.navDate = collection.getNavDate();
                    tree.data.id = collection.id;
                    tree.data.type = Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.COLLECTION.toString());
                    parentCollection.defaultTree.addNode(tree);
                }
            }
        };
        return Collection;
    }(Manifesto.IIIFResource));
    Manifesto.Collection = Collection;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Range = /** @class */ (function (_super) {
        __extends(Range, _super);
        function Range(jsonld, options) {
            var _this = _super.call(this, jsonld, options) || this;
            _this._ranges = null;
            _this.canvases = null;
            _this.items = [];
            return _this;
        }
        Range.prototype.getCanvasIds = function () {
            if (this.__jsonld.canvases) {
                return this.__jsonld.canvases;
            }
            else if (this.canvases) {
                return this.canvases;
            }
            return [];
        };
        Range.prototype.getDuration = function () {
            var start;
            var end;
            if (this.canvases && this.canvases.length) {
                for (var i = 0; i < this.canvases.length; i++) {
                    var canvas = this.canvases[i];
                    var temporal = Manifesto.Utils.getTemporalComponent(canvas);
                    if (temporal && temporal.length > 1) {
                        if (i === 0) {
                            start = Number(temporal[0]);
                        }
                        if (i === this.canvases.length - 1) {
                            end = Number(temporal[1]);
                        }
                    }
                }
            }
            else {
                // get child ranges and calculate the start and end based on them
                var childRanges = this.getRanges();
                for (var i = 0; i < childRanges.length; i++) {
                    var childRange = childRanges[i];
                    var duration = childRange.getDuration();
                    if (duration) {
                        if (i === 0) {
                            start = duration.start;
                        }
                        if (i === childRanges.length - 1) {
                            end = duration.end;
                        }
                    }
                }
            }
            if (start !== undefined && end !== undefined) {
                return new Manifesto.Duration(start, end);
            }
            return undefined;
        };
        // getCanvases(): ICanvas[] {
        //     if (this._canvases) {
        //         return this._canvases;
        //     }
        //     return this._canvases = <ICanvas[]>this.items.en().where(m => m.isCanvas()).toArray();
        // }
        Range.prototype.getRanges = function () {
            if (this._ranges) {
                return this._ranges;
            }
            return this._ranges = this.items.filter(function (m) { return m.isRange(); });
        };
        Range.prototype.getBehavior = function () {
            var behavior = this.getProperty('behavior');
            if (Array.isArray(behavior)) {
                behavior = behavior[0];
            }
            if (behavior) {
                return new Manifesto.Behavior(behavior);
            }
            return null;
        };
        Range.prototype.getViewingDirection = function () {
            if (this.getProperty('viewingDirection')) {
                return new Manifesto.ViewingDirection(this.getProperty('viewingDirection'));
            }
            return null;
        };
        Range.prototype.getViewingHint = function () {
            if (this.getProperty('viewingHint')) {
                return new Manifesto.ViewingHint(this.getProperty('viewingHint'));
            }
            return null;
        };
        Range.prototype.getTree = function (treeRoot) {
            treeRoot.data = this;
            this.treeNode = treeRoot;
            var ranges = this.getRanges();
            if (ranges && ranges.length) {
                for (var i = 0; i < ranges.length; i++) {
                    var range = ranges[i];
                    var node = new Manifesto.TreeNode();
                    treeRoot.addNode(node);
                    this._parseTreeNode(node, range);
                }
            }
            Manifesto.Utils.generateTreeNodeIds(treeRoot);
            return treeRoot;
        };
        Range.prototype.spansTime = function (time) {
            var duration = this.getDuration();
            if (duration) {
                if (time >= duration.start && time <= duration.end) {
                    return true;
                }
            }
            return false;
        };
        Range.prototype._parseTreeNode = function (node, range) {
            node.label = Manifesto.LanguageMap.getValue(range.getLabel(), this.options.locale);
            node.data = range;
            node.data.type = Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.RANGE.toString());
            range.treeNode = node;
            var ranges = range.getRanges();
            if (ranges && ranges.length) {
                for (var i = 0; i < ranges.length; i++) {
                    var childRange = ranges[i];
                    var behavior = childRange.getBehavior();
                    if (behavior && behavior.toString() === Manifesto.Behavior.NONAV.toString()) {
                        continue;
                    }
                    else {
                        var childNode = new Manifesto.TreeNode();
                        node.addNode(childNode);
                        this._parseTreeNode(childNode, childRange);
                    }
                }
            }
        };
        return Range;
    }(Manifesto.ManifestResource));
    Manifesto.Range = Range;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Rendering = /** @class */ (function (_super) {
        __extends(Rendering, _super);
        function Rendering(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        Rendering.prototype.getFormat = function () {
            return new Manifesto.RenderingFormat(this.getProperty('format'));
        };
        return Rendering;
    }(Manifesto.ManifestResource));
    Manifesto.Rendering = Rendering;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Sequence = /** @class */ (function (_super) {
        __extends(Sequence, _super);
        function Sequence(jsonld, options) {
            var _this = _super.call(this, jsonld, options) || this;
            _this.items = [];
            _this._thumbnails = null;
            return _this;
        }
        Sequence.prototype.getCanvases = function () {
            if (this.items.length) {
                return this.items;
            }
            var items = this.__jsonld.canvases || this.__jsonld.elements;
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    var c = items[i];
                    var canvas = new Manifesto.Canvas(c, this.options);
                    canvas.index = i;
                    this.items.push(canvas);
                }
            }
            else if (this.__jsonld) {
                for (var i = 0; i < this.__jsonld.length; i++) {
                    var c = this.__jsonld[i];
                    var canvas = new Manifesto.Canvas(c, this.options);
                    canvas.index = i;
                    this.items.push(canvas);
                }
            }
            return this.items;
        };
        Sequence.prototype.getCanvasById = function (id) {
            for (var i = 0; i < this.getTotalCanvases(); i++) {
                var canvas = this.getCanvasByIndex(i);
                // normalise canvas id
                var canvasId = Manifesto.Utils.normaliseUrl(canvas.id);
                if (Manifesto.Utils.normaliseUrl(id) === canvasId) {
                    return canvas;
                }
            }
            return null;
        };
        Sequence.prototype.getCanvasByIndex = function (canvasIndex) {
            return this.getCanvases()[canvasIndex];
        };
        Sequence.prototype.getCanvasIndexById = function (id) {
            for (var i = 0; i < this.getTotalCanvases(); i++) {
                var canvas = this.getCanvasByIndex(i);
                if (canvas.id === id) {
                    return i;
                }
            }
            return null;
        };
        Sequence.prototype.getCanvasIndexByLabel = function (label, foliated) {
            label = label.trim();
            if (!isNaN(label)) { // if the label is numeric
                label = parseInt(label, 10).toString(); // trim any preceding zeros.
                if (foliated)
                    label += 'r'; // default to recto
            }
            var doublePageRegExp = /(\d*)\D+(\d*)/;
            var match, regExp, regStr, labelPart1, labelPart2;
            for (var i = 0; i < this.getTotalCanvases(); i++) {
                var canvas = this.getCanvasByIndex(i);
                // check if there's a literal match
                if (Manifesto.LanguageMap.getValue(canvas.getLabel(), this.options.locale) === label) {
                    return i;
                }
                // check if there's a match for double-page spreads e.g. 100-101, 100_101, 100 101
                match = doublePageRegExp.exec(label);
                if (!match)
                    continue;
                labelPart1 = match[1];
                labelPart2 = match[2];
                if (!labelPart2)
                    continue;
                regStr = "^" + labelPart1 + "\\D+" + labelPart2 + "$";
                regExp = new RegExp(regStr);
                if (regExp.test(canvas.getLabel().toString())) {
                    return i;
                }
            }
            return -1;
        };
        Sequence.prototype.getLastCanvasLabel = function (alphanumeric) {
            for (var i = this.getTotalCanvases() - 1; i >= 0; i--) {
                var canvas = this.getCanvasByIndex(i);
                var label = Manifesto.LanguageMap.getValue(canvas.getLabel(), this.options.locale);
                if (alphanumeric) {
                    var regExp = /^[a-zA-Z0-9]*$/;
                    if (regExp.test(label)) {
                        return label;
                    }
                }
                else if (label) {
                    return label;
                }
            }
            return this.options.defaultLabel;
        };
        Sequence.prototype.getLastPageIndex = function () {
            return this.getTotalCanvases() - 1;
        };
        Sequence.prototype.getNextPageIndex = function (canvasIndex, pagingEnabled) {
            var index;
            if (pagingEnabled) {
                var indices = this.getPagedIndices(canvasIndex);
                var viewingDirection = this.getViewingDirection();
                if (viewingDirection && viewingDirection.toString() === Manifesto.ViewingDirection.RIGHTTOLEFT.toString()) {
                    index = indices[0] + 1;
                }
                else {
                    index = indices[indices.length - 1] + 1;
                }
            }
            else {
                index = canvasIndex + 1;
            }
            if (index > this.getLastPageIndex()) {
                return -1;
            }
            return index;
        };
        Sequence.prototype.getPagedIndices = function (canvasIndex, pagingEnabled) {
            var indices = [];
            if (!pagingEnabled) {
                indices.push(canvasIndex);
            }
            else {
                if (this.isFirstCanvas(canvasIndex) || this.isLastCanvas(canvasIndex)) {
                    indices = [canvasIndex];
                }
                else if (canvasIndex % 2) {
                    indices = [canvasIndex, canvasIndex + 1];
                }
                else {
                    indices = [canvasIndex - 1, canvasIndex];
                }
                var viewingDirection = this.getViewingDirection();
                if (viewingDirection && viewingDirection.toString() === Manifesto.ViewingDirection.RIGHTTOLEFT.toString()) {
                    indices = indices.reverse();
                }
            }
            return indices;
        };
        Sequence.prototype.getPrevPageIndex = function (canvasIndex, pagingEnabled) {
            var index;
            if (pagingEnabled) {
                var indices = this.getPagedIndices(canvasIndex);
                var viewingDirection = this.getViewingDirection();
                if (viewingDirection && viewingDirection.toString() === Manifesto.ViewingDirection.RIGHTTOLEFT.toString()) {
                    index = indices[indices.length - 1] - 1;
                }
                else {
                    index = indices[0] - 1;
                }
            }
            else {
                index = canvasIndex - 1;
            }
            return index;
        };
        Sequence.prototype.getStartCanvasIndex = function () {
            var startCanvas = this.getStartCanvas();
            if (startCanvas) {
                // if there's a startCanvas attribute, loop through the canvases and return the matching index.
                for (var i = 0; i < this.getTotalCanvases(); i++) {
                    var canvas = this.getCanvasByIndex(i);
                    if (canvas.id === startCanvas)
                        return i;
                }
            }
            // default to first canvas.
            return 0;
        };
        // todo: deprecate
        Sequence.prototype.getThumbs = function (width, height) {
            console.warn('getThumbs will be deprecated, use getThumbnails instead');
            var thumbs = [];
            var totalCanvases = this.getTotalCanvases();
            for (var i = 0; i < totalCanvases; i++) {
                var canvas = this.getCanvasByIndex(i);
                var thumb = new Manifesto.Thumb(width, canvas);
                thumbs.push(thumb);
            }
            return thumbs;
        };
        Sequence.prototype.getThumbnails = function () {
            if (this._thumbnails != null)
                return this._thumbnails;
            this._thumbnails = [];
            var canvases = this.getCanvases();
            for (var i = 0; i < canvases.length; i++) {
                var thumbnail = canvases[i].getThumbnail();
                if (thumbnail) {
                    this._thumbnails.push(thumbnail);
                }
            }
            return this._thumbnails;
        };
        Sequence.prototype.getStartCanvas = function () {
            return this.getProperty('startCanvas');
        };
        Sequence.prototype.getTotalCanvases = function () {
            return this.getCanvases().length;
        };
        Sequence.prototype.getViewingDirection = function () {
            if (this.getProperty('viewingDirection')) {
                return new Manifesto.ViewingDirection(this.getProperty('viewingDirection'));
            }
            else if (this.options.resource.getViewingDirection) {
                return this.options.resource.getViewingDirection();
            }
            return null;
        };
        Sequence.prototype.getViewingHint = function () {
            if (this.getProperty('viewingHint')) {
                return new Manifesto.ViewingHint(this.getProperty('viewingHint'));
            }
            return null;
        };
        Sequence.prototype.isCanvasIndexOutOfRange = function (canvasIndex) {
            return canvasIndex > this.getTotalCanvases() - 1;
        };
        Sequence.prototype.isFirstCanvas = function (canvasIndex) {
            return canvasIndex === 0;
        };
        Sequence.prototype.isLastCanvas = function (canvasIndex) {
            return canvasIndex === this.getTotalCanvases() - 1;
        };
        Sequence.prototype.isMultiCanvas = function () {
            return this.getTotalCanvases() > 1;
        };
        Sequence.prototype.isPagingEnabled = function () {
            var viewingHint = this.getViewingHint();
            if (viewingHint) {
                return viewingHint.toString() === Manifesto.ViewingHint.PAGED.toString();
            }
            return false;
        };
        // checks if the number of canvases is even - therefore has a front and back cover
        Sequence.prototype.isTotalCanvasesEven = function () {
            return this.getTotalCanvases() % 2 === 0;
        };
        return Sequence;
    }(Manifesto.ManifestResource));
    Manifesto.Sequence = Sequence;
})(Manifesto || (Manifesto = {}));

var Manifesto;
(function (Manifesto) {
    var Deserialiser = /** @class */ (function () {
        function Deserialiser() {
        }
        Deserialiser.parse = function (manifest, options) {
            if (typeof manifest === 'string') {
                manifest = JSON.parse(manifest);
            }
            return this.parseJson(manifest, options);
        };
        Deserialiser.parseJson = function (json, options) {
            var resource;
            // have options been passed for the manifest to inherit?
            if (options) {
                if (options.navDate && !isNaN(options.navDate.getTime())) {
                    json.navDate = options.navDate.toString();
                }
            }
            if (json['@type']) {
                switch (json['@type']) {
                    case 'sc:Collection':
                        resource = this.parseCollection(json, options);
                        break;
                    case 'sc:Manifest':
                        resource = this.parseManifest(json, options);
                        break;
                    default:
                        return null;
                }
            }
            else {
                // presentation 3
                switch (json['type']) {
                    case 'Collection':
                        resource = this.parseCollection(json, options);
                        break;
                    case 'Manifest':
                        resource = this.parseManifest(json, options);
                        break;
                    default:
                        return null;
                }
            }
            // Top-level resource was loaded from a URI, so flag it to prevent
            // unnecessary reload:
            resource.isLoaded = true;
            return resource;
        };
        Deserialiser.parseCollection = function (json, options) {
            var collection = new Manifesto.Collection(json, options);
            if (options) {
                collection.index = options.index || 0;
                if (options.resource) {
                    collection.parentCollection = options.resource.parentCollection;
                }
            }
            else {
                collection.index = 0;
            }
            this.parseCollections(collection, options);
            this.parseManifests(collection, options);
            this.parseItems(collection, options);
            return collection;
        };
        Deserialiser.parseCollections = function (collection, options) {
            var items;
            if (collection.__jsonld.collections) {
                items = collection.__jsonld.collections;
            }
            else if (collection.__jsonld.items) {
                items = collection.__jsonld.items.filter(function (m) { return m.type.toLowerCase() === 'collection'; });
            }
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    if (options) {
                        options.index = i;
                    }
                    var item = this.parseCollection(items[i], options);
                    item.index = i;
                    item.parentCollection = collection;
                    collection.items.push(item);
                }
            }
        };
        Deserialiser.parseManifest = function (json, options) {
            var manifest = new Manifesto.Manifest(json, options);
            return manifest;
        };
        Deserialiser.parseManifests = function (collection, options) {
            var items;
            if (collection.__jsonld.manifests) {
                items = collection.__jsonld.manifests;
            }
            else if (collection.__jsonld.items) {
                items = collection.__jsonld.items.filter(function (m) { return m.type.toLowerCase() === 'manifest'; });
            }
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    var item = this.parseManifest(items[i], options);
                    item.index = i;
                    item.parentCollection = collection;
                    collection.items.push(item);
                }
            }
        };
        Deserialiser.parseItem = function (json, options) {
            if (json['@type']) {
                if (json['@type'].toLowerCase() === 'sc:manifest') {
                    return this.parseManifest(json, options);
                }
                else if (json['@type'].toLowerCase() === 'sc:collection') {
                    return this.parseCollection(json, options);
                }
            }
            else if (json.type) {
                if (json.type.toLowerCase() === 'manifest') {
                    return this.parseManifest(json, options);
                }
                else if (json.type.toLowerCase() === 'collection') {
                    return this.parseCollection(json, options);
                }
            }
            return null;
        };
        Deserialiser.parseItems = function (collection, options) {
            var items = collection.__jsonld.members || collection.__jsonld.items;
            if (items) {
                var _loop_1 = function (i) {
                    if (options) {
                        options.index = i;
                    }
                    var item = this_1.parseItem(items[i], options);
                    if (!item)
                        return { value: void 0 };
                    // only add to items if not already parsed from backwards-compatible collections/manifests arrays
                    if (collection.items.filter(function (m) { return m.id === item.id; })[0]) {
                        return "continue";
                    }
                    item.index = i;
                    item.parentCollection = collection;
                    collection.items.push(item);
                };
                var this_1 = this;
                for (var i = 0; i < items.length; i++) {
                    var state_1 = _loop_1(i);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
        };
        return Deserialiser;
    }());
    Manifesto.Deserialiser = Deserialiser;
    var Serialiser = /** @class */ (function () {
        function Serialiser() {
        }
        Serialiser.serialise = function (manifest) {
            // todo
            return "";
        };
        return Serialiser;
    }());
    Manifesto.Serialiser = Serialiser;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Service = /** @class */ (function (_super) {
        __extends(Service, _super);
        function Service(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        Service.prototype.getProfile = function () {
            var profile = this.getProperty('profile');
            if (!profile) {
                profile = this.getProperty('dcterms:conformsTo');
            }
            if (Array.isArray(profile)) {
                return new Manifesto.ServiceProfile(profile[0]);
            }
            return new Manifesto.ServiceProfile(profile);
        };
        Service.prototype.getConfirmLabel = function () {
            return Manifesto.Utils.getLocalisedValue(this.getProperty('confirmLabel'), this.options.locale);
        };
        Service.prototype.getDescription = function () {
            return Manifesto.Utils.getLocalisedValue(this.getProperty('description'), this.options.locale);
        };
        Service.prototype.getFailureDescription = function () {
            return Manifesto.Utils.getLocalisedValue(this.getProperty('failureDescription'), this.options.locale);
        };
        Service.prototype.getFailureHeader = function () {
            return Manifesto.Utils.getLocalisedValue(this.getProperty('failureHeader'), this.options.locale);
        };
        Service.prototype.getHeader = function () {
            return Manifesto.Utils.getLocalisedValue(this.getProperty('header'), this.options.locale);
        };
        Service.prototype.getServiceLabel = function () {
            return Manifesto.Utils.getLocalisedValue(this.getProperty('label'), this.options.locale);
        };
        Service.prototype.getInfoUri = function () {
            var infoUri = this.id;
            if (!infoUri.endsWith('/')) {
                infoUri += '/';
            }
            infoUri += 'info.json';
            return infoUri;
        };
        return Service;
    }(Manifesto.ManifestResource));
    Manifesto.Service = Service;
})(Manifesto || (Manifesto = {}));


var Manifesto;
(function (Manifesto) {
    // todo: deprecate
    // this is used by Sequence.getThumbs
    var Thumb = /** @class */ (function () {
        function Thumb(width, canvas) {
            this.data = canvas;
            this.index = canvas.index;
            this.width = width;
            var heightRatio = canvas.getHeight() / canvas.getWidth();
            if (heightRatio) {
                this.height = Math.floor(this.width * heightRatio);
            }
            else {
                this.height = width;
            }
            this.uri = canvas.getCanonicalImageUri(width);
            this.label = Manifesto.LanguageMap.getValue(canvas.getLabel()); // todo: pass locale?
        }
        return Thumb;
    }());
    Manifesto.Thumb = Thumb;
})(Manifesto || (Manifesto = {}));


var Manifesto;
(function (Manifesto) {
    var TreeNode = /** @class */ (function () {
        function TreeNode(label, data) {
            this.label = label;
            this.data = data || {};
            this.nodes = [];
        }
        TreeNode.prototype.addNode = function (node) {
            this.nodes.push(node);
            node.parentNode = this;
        };
        TreeNode.prototype.isCollection = function () {
            return this.data.type === Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.COLLECTION.toString());
        };
        TreeNode.prototype.isManifest = function () {
            return this.data.type === Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.MANIFEST.toString());
        };
        TreeNode.prototype.isRange = function () {
            return this.data.type === Manifesto.Utils.normaliseType(Manifesto.TreeNodeType.RANGE.toString());
        };
        return TreeNode;
    }());
    Manifesto.TreeNode = TreeNode;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var TreeNodeType = /** @class */ (function (_super) {
        __extends(TreeNodeType, _super);
        function TreeNodeType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        TreeNodeType.prototype.collection = function () {
            return new TreeNodeType(TreeNodeType.COLLECTION.toString());
        };
        TreeNodeType.prototype.manifest = function () {
            return new TreeNodeType(TreeNodeType.MANIFEST.toString());
        };
        TreeNodeType.prototype.range = function () {
            return new TreeNodeType(TreeNodeType.RANGE.toString());
        };
        TreeNodeType.COLLECTION = new TreeNodeType("collection");
        TreeNodeType.MANIFEST = new TreeNodeType("manifest");
        TreeNodeType.RANGE = new TreeNodeType("range");
        return TreeNodeType;
    }(Manifesto.StringValue));
    Manifesto.TreeNodeType = TreeNodeType;
})(Manifesto || (Manifesto = {}));

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var http = require('http');
var https = require('https');
var url = require('url');
var Manifesto;
(function (Manifesto) {
    var Utils = /** @class */ (function () {
        function Utils() {
        }
        Utils.getMediaType = function (type) {
            type = type.toLowerCase();
            type = type.split(';')[0];
            return type.trim();
        };
        Utils.getImageQuality = function (profile) {
            var p = profile.toString();
            if (p === Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE1.toString() ||
                p === Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE2.toString() ||
                p === Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE1.toString() ||
                p === Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE2.toString() ||
                p === Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE1.toString() ||
                p === Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE2.toString() ||
                p === Manifesto.ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE1.toString() ||
                p === Manifesto.ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE2.toString() ||
                p === Manifesto.ServiceProfile.IIIF1IMAGELEVEL1.toString() ||
                p === Manifesto.ServiceProfile.IIIF1IMAGELEVEL1PROFILE.toString() ||
                p === Manifesto.ServiceProfile.IIIF1IMAGELEVEL2.toString() ||
                p === Manifesto.ServiceProfile.IIIF1IMAGELEVEL2PROFILE.toString()) {
                return 'native';
            }
            return 'default';
        };
        Utils.getInexactLocale = function (locale) {
            if (locale.indexOf('-') !== -1) {
                return locale.substr(0, locale.indexOf('-'));
            }
            return locale;
        };
        Utils.getLocalisedValue = function (resource, locale) {
            // if the resource is not an array of translations, return the string.
            if (!Array.isArray(resource)) {
                return resource;
            }
            // test for exact match
            for (var i = 0; i < resource.length; i++) {
                var value_1 = resource[i];
                var language_1 = value_1['@language'];
                if (locale === language_1) {
                    return value_1['@value'];
                }
            }
            // test for inexact match
            var match = locale.substr(0, locale.indexOf('-'));
            for (var i = 0; i < resource.length; i++) {
                var value = resource[i];
                var language = value['@language'];
                if (language === match) {
                    return value['@value'];
                }
            }
            return null;
        };
        Utils.generateTreeNodeIds = function (treeNode, index) {
            if (index === void 0) { index = 0; }
            var id;
            if (!treeNode.parentNode) {
                id = '0';
            }
            else {
                id = treeNode.parentNode.id + "-" + index;
            }
            treeNode.id = id;
            for (var i = 0; i < treeNode.nodes.length; i++) {
                var n = treeNode.nodes[i];
                Utils.generateTreeNodeIds(n, i);
            }
        };
        Utils.normaliseType = function (type) {
            type = type.toLowerCase();
            if (type.indexOf(':') !== -1) {
                var split = type.split(':');
                return split[1];
            }
            return type;
        };
        Utils.normaliseUrl = function (url) {
            url = url.substr(url.indexOf('://'));
            if (url.indexOf('#') !== -1) {
                url = url.split('#')[0];
            }
            return url;
        };
        Utils.normalisedUrlsMatch = function (url1, url2) {
            return Utils.normaliseUrl(url1) === Utils.normaliseUrl(url2);
        };
        Utils.isImageProfile = function (profile) {
            if (typeof (profile) === 'string') {
                profile = new Manifesto.ServiceProfile(profile);
            }
            if (Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL0PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL1PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL2PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL0PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL1PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL2PROFILE.toString())) {
                return true;
            }
            return false;
        };
        Utils.isLevel0ImageProfile = function (profile) {
            if (typeof (profile) === 'string') {
                profile = new Manifesto.ServiceProfile(profile);
            }
            if (Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL0PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL0.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL0PROFILE.toString())) {
                return true;
            }
            return false;
        };
        Utils.isLevel1ImageProfile = function (profile) {
            if (typeof (profile) === 'string') {
                profile = new Manifesto.ServiceProfile(profile);
            }
            if (Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL1PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL1.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL1PROFILE.toString())) {
                return true;
            }
            return false;
        };
        Utils.isLevel2ImageProfile = function (profile) {
            if (typeof (profile) === 'string') {
                profile = new Manifesto.ServiceProfile(profile);
            }
            if (Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECOMPLIANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECOMPLIANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIFIMAGECONFORMANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.STANFORDIIIF1IMAGECONFORMANCE2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF1IMAGELEVEL2PROFILE.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL2.toString()) ||
                Utils.normalisedUrlsMatch(profile.toString(), Manifesto.ServiceProfile.IIIF2IMAGELEVEL2PROFILE.toString())) {
                return true;
            }
            return false;
        };
        Utils.loadResource = function (uri) {
            return new Promise(function (resolve, reject) {
                var u = url.parse(uri);
                var req;
                var opts = {
                    host: u.hostname,
                    port: u.port,
                    path: u.path,
                    method: "GET",
                    withCredentials: false
                };
                switch (u.protocol) {
                    case 'https:':
                        req = https.request(opts, function (response) {
                            var result = "";
                            response.on('data', function (chunk) {
                                result += chunk;
                            });
                            response.on('end', function () {
                                resolve(result);
                            });
                        });
                        req.on('error', function (error) {
                            reject(error);
                        });
                        req.end();
                        break;
                    case 'dat:':
                        var xhr_1 = new XMLHttpRequest();
                        xhr_1.onreadystatechange = function () {
                            if (xhr_1.readyState === 4) {
                                resolve(xhr_1.response);
                            }
                        };
                        xhr_1.open("GET", uri, true);
                        xhr_1.send();
                        break;
                    default:
                        req = http.request(opts, function (response) {
                            var result = "";
                            response.on('data', function (chunk) {
                                result += chunk;
                            });
                            response.on('end', function () {
                                resolve(result);
                            });
                        });
                        req.on('error', function (error) {
                            reject(error);
                        });
                        req.end();
                        break;
                }
            });
        };
        Utils.loadExternalResourcesAuth1 = function (resources, openContentProviderInteraction, openTokenService, getStoredAccessToken, userInteractedWithContentProvider, getContentProviderInteraction, handleMovedTemporarily, showOutOfOptionsMessages) {
            return new Promise(function (resolve, reject) {
                var promises = resources.map(function (resource) {
                    return Utils.loadExternalResourceAuth1(resource, openContentProviderInteraction, openTokenService, getStoredAccessToken, userInteractedWithContentProvider, getContentProviderInteraction, handleMovedTemporarily, showOutOfOptionsMessages);
                });
                Promise.all(promises)
                    .then(function () {
                    resolve(resources);
                })["catch"](function (error) {
                    reject(error);
                });
            });
        };
        Utils.loadExternalResourceAuth1 = function (resource, openContentProviderInteraction, openTokenService, getStoredAccessToken, userInteractedWithContentProvider, getContentProviderInteraction, handleMovedTemporarily, showOutOfOptionsMessages) {
            return __awaiter(this, void 0, void 0, function () {
                var storedAccessToken;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, getStoredAccessToken(resource)];
                        case 1:
                            storedAccessToken = _a.sent();
                            if (!storedAccessToken) return [3 /*break*/, 6];
                            return [4 /*yield*/, resource.getData(storedAccessToken)];
                        case 2:
                            _a.sent();
                            if (!(resource.status === HTTPStatusCode.OK)) return [3 /*break*/, 3];
                            return [2 /*return*/, resource];
                        case 3:
                        // the stored token is no good for this resource
                        return [4 /*yield*/, Utils.doAuthChain(resource, openContentProviderInteraction, openTokenService, userInteractedWithContentProvider, getContentProviderInteraction, handleMovedTemporarily, showOutOfOptionsMessages)];
                        case 4:
                            // the stored token is no good for this resource
                            _a.sent();
                            _a.label = 5;
                        case 5:
                            if (resource.status === HTTPStatusCode.OK || resource.status === HTTPStatusCode.MOVED_TEMPORARILY) {
                                return [2 /*return*/, resource];
                            }
                            throw Utils.createAuthorizationFailedError();
                        case 6: return [4 /*yield*/, resource.getData()];
                        case 7:
                            _a.sent();
                            if (!(resource.status === HTTPStatusCode.MOVED_TEMPORARILY || resource.status === HTTPStatusCode.UNAUTHORIZED)) return [3 /*break*/, 9];
                            return [4 /*yield*/, Utils.doAuthChain(resource, openContentProviderInteraction, openTokenService, userInteractedWithContentProvider, getContentProviderInteraction, handleMovedTemporarily, showOutOfOptionsMessages)];
                        case 8:
                            _a.sent();
                            _a.label = 9;
                        case 9:
                            if (resource.status === HTTPStatusCode.OK || resource.status === HTTPStatusCode.MOVED_TEMPORARILY) {
                                return [2 /*return*/, resource];
                            }
                            throw Utils.createAuthorizationFailedError();
                    }
                });
            });
        };
        Utils.doAuthChain = function (resource, openContentProviderInteraction, openTokenService, userInteractedWithContentProvider, getContentProviderInteraction, handleMovedTemporarily, showOutOfOptionsMessages) {
            return __awaiter(this, void 0, void 0, function () {
                var externalService, kioskService, clickThroughService, loginService, serviceToTry, lastAttempted, kioskInteraction, contentProviderInteraction, contentProviderInteraction;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // This function enters the flowchart at the < External? > junction
                            // http://iiif.io/api/auth/1.0/#workflow-from-the-browser-client-perspective
                            if (!resource.isAccessControlled()) {
                                return [2 /*return*/, resource]; // no services found
                            }
                            externalService = resource.externalService;
                            if (externalService) {
                                externalService.options = resource.options;
                            }
                            kioskService = resource.kioskService;
                            if (kioskService) {
                                kioskService.options = resource.options;
                            }
                            clickThroughService = resource.clickThroughService;
                            if (clickThroughService) {
                                clickThroughService.options = resource.options;
                            }
                            loginService = resource.loginService;
                            if (loginService) {
                                loginService.options = resource.options;
                            }
                            if (!(!resource.isResponseHandled && resource.status === HTTPStatusCode.MOVED_TEMPORARILY)) return [3 /*break*/, 2];
                            return [4 /*yield*/, handleMovedTemporarily(resource)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, resource];
                        case 2:
                            serviceToTry = null;
                            lastAttempted = null;
                            // repetition of logic is left in these steps for clarity:
                            // Looking for external pattern
                            serviceToTry = externalService;
                            if (!serviceToTry) return [3 /*break*/, 4];
                            lastAttempted = serviceToTry;
                            return [4 /*yield*/, Utils.attemptResourceWithToken(resource, openTokenService, serviceToTry)];
                        case 3:
                            _a.sent();
                            return [2 /*return*/, resource];
                        case 4:
                            // Looking for kiosk pattern
                            serviceToTry = kioskService;
                            if (!serviceToTry) return [3 /*break*/, 7];
                            lastAttempted = serviceToTry;
                            kioskInteraction = openContentProviderInteraction(serviceToTry);
                            if (!kioskInteraction) return [3 /*break*/, 7];
                            return [4 /*yield*/, userInteractedWithContentProvider(kioskInteraction)];
                        case 5:
                            _a.sent();
                            return [4 /*yield*/, Utils.attemptResourceWithToken(resource, openTokenService, serviceToTry)];
                        case 6:
                            _a.sent();
                            return [2 /*return*/, resource];
                        case 7:
                            // The code for the next two patterns is identical (other than the profile name).
                            // The difference is in the expected behaviour of
                            //
                            //    await userInteractedWithContentProvider(contentProviderInteraction);
                            //
                            // For clickthrough the opened window should close immediately having established
                            // a session, whereas for login the user might spend some time entering credentials etc.
                            // Looking for clickthrough pattern
                            serviceToTry = clickThroughService;
                            if (!serviceToTry) return [3 /*break*/, 11];
                            lastAttempted = serviceToTry;
                            return [4 /*yield*/, getContentProviderInteraction(resource, serviceToTry)];
                        case 8:
                            contentProviderInteraction = _a.sent();
                            if (!contentProviderInteraction) return [3 /*break*/, 11];
                            // should close immediately
                            return [4 /*yield*/, userInteractedWithContentProvider(contentProviderInteraction)];
                        case 9:
                            // should close immediately
                            _a.sent();
                            return [4 /*yield*/, Utils.attemptResourceWithToken(resource, openTokenService, serviceToTry)];
                        case 10:
                            _a.sent();
                            return [2 /*return*/, resource];
                        case 11:
                            // Looking for login pattern
                            serviceToTry = loginService;
                            if (!serviceToTry) return [3 /*break*/, 15];
                            lastAttempted = serviceToTry;
                            return [4 /*yield*/, getContentProviderInteraction(resource, serviceToTry)];
                        case 12:
                            contentProviderInteraction = _a.sent();
                            if (!contentProviderInteraction) return [3 /*break*/, 15];
                            // we expect the user to spend some time interacting
                            return [4 /*yield*/, userInteractedWithContentProvider(contentProviderInteraction)];
                        case 13:
                            // we expect the user to spend some time interacting
                            _a.sent();
                            return [4 /*yield*/, Utils.attemptResourceWithToken(resource, openTokenService, serviceToTry)];
                        case 14:
                            _a.sent();
                            return [2 /*return*/, resource];
                        case 15:
                            // nothing worked! Use the most recently tried service as the source of
                            // messages to show to the user.
                            if (lastAttempted) {
                                showOutOfOptionsMessages(resource, lastAttempted);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        Utils.attemptResourceWithToken = function (resource, openTokenService, authService) {
            return __awaiter(this, void 0, void 0, function () {
                var tokenService, tokenMessage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            tokenService = authService.getService(Manifesto.ServiceProfile.AUTH1TOKEN.toString());
                            if (!tokenService) return [3 /*break*/, 3];
                            return [4 /*yield*/, openTokenService(resource, tokenService)];
                        case 1:
                            tokenMessage = _a.sent();
                            if (!(tokenMessage && tokenMessage.accessToken)) return [3 /*break*/, 3];
                            return [4 /*yield*/, resource.getData(tokenMessage)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/, resource];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        Utils.loadExternalResourcesAuth09 = function (resources, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, getStoredAccessToken, handleResourceResponse, options) {
            return new Promise(function (resolve, reject) {
                var promises = resources.map(function (resource) {
                    return Utils.loadExternalResourceAuth09(resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, getStoredAccessToken, handleResourceResponse, options);
                });
                Promise.all(promises)
                    .then(function () {
                    resolve(resources);
                })["catch"](function (error) {
                    reject(error);
                });
            });
        };
        // IIIF auth api pre v1.0
        // Keeping this around for now until the auth 1.0 implementation is stable
        Utils.loadExternalResourceAuth09 = function (resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, getStoredAccessToken, handleResourceResponse, options) {
            return new Promise(function (resolve, reject) {
                if (options && options.pessimisticAccessControl) {
                    // pessimistic: access control cookies may have been deleted.
                    // always request the access token for every access controlled info.json request
                    // returned access tokens are not stored, therefore the login window flashes for every request.
                    resource.getData().then(function () {
                        if (resource.isAccessControlled()) {
                            // if the resource has a click through service, use that.
                            if (resource.clickThroughService) {
                                resolve(clickThrough(resource));
                                //} else if(resource.restrictedService) {
                                resolve(restricted(resource));
                            }
                            else {
                                login(resource).then(function () {
                                    getAccessToken(resource, true).then(function (token) {
                                        resource.getData(token).then(function () {
                                            resolve(handleResourceResponse(resource));
                                        })["catch"](function (message) {
                                            reject(Utils.createInternalServerError(message));
                                        });
                                    })["catch"](function (message) {
                                        reject(Utils.createInternalServerError(message));
                                    });
                                })["catch"](function (message) {
                                    reject(Utils.createInternalServerError(message));
                                });
                            }
                        }
                        else {
                            // this info.json isn't access controlled, therefore no need to request an access token.
                            resolve(resource);
                        }
                    })["catch"](function (message) {
                        reject(Utils.createInternalServerError(message));
                    });
                }
                else {
                    // optimistic: access control cookies may not have been deleted.
                    // store access tokens to avoid login window flashes.
                    // if cookies are deleted a page refresh is required.
                    // try loading the resource using an access token that matches the info.json domain.
                    // if an access token is found, request the resource using it regardless of whether it is access controlled.
                    getStoredAccessToken(resource, tokenStorageStrategy).then(function (storedAccessToken) {
                        if (storedAccessToken) {
                            // try using the stored access token
                            resource.getData(storedAccessToken).then(function () {
                                // if the info.json loaded using the stored access token
                                if (resource.status === HTTPStatusCode.OK) {
                                    resolve(handleResourceResponse(resource));
                                }
                                else {
                                    // otherwise, load the resource data to determine the correct access control services.
                                    // if access controlled, do login.
                                    Utils.authorize(resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, getStoredAccessToken).then(function () {
                                        resolve(handleResourceResponse(resource));
                                    })["catch"](function (error) {
                                        // if (resource.restrictedService){
                                        //     reject(Utils.createRestrictedError());
                                        // } else {
                                        reject(Utils.createAuthorizationFailedError());
                                        //}
                                    });
                                }
                            })["catch"](function (error) {
                                reject(Utils.createAuthorizationFailedError());
                            });
                        }
                        else {
                            Utils.authorize(resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, getStoredAccessToken).then(function () {
                                resolve(handleResourceResponse(resource));
                            })["catch"](function (error) {
                                reject(Utils.createAuthorizationFailedError());
                            });
                        }
                    })["catch"](function (error) {
                        reject(Utils.createAuthorizationFailedError());
                    });
                }
            });
        };
        Utils.createError = function (name, message) {
            var error = new Error();
            error.message = message;
            error.name = name;
            return error;
        };
        Utils.createAuthorizationFailedError = function () {
            return Utils.createError(manifesto.StatusCodes.AUTHORIZATION_FAILED.toString(), "Authorization failed");
        };
        Utils.createRestrictedError = function () {
            return Utils.createError(manifesto.StatusCodes.RESTRICTED.toString(), "Restricted");
        };
        Utils.createInternalServerError = function (message) {
            return Utils.createError(manifesto.StatusCodes.INTERNAL_SERVER_ERROR.toString(), message);
        };
        Utils.authorize = function (resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, getStoredAccessToken) {
            return new Promise(function (resolve, reject) {
                resource.getData().then(function () {
                    if (resource.isAccessControlled()) {
                        getStoredAccessToken(resource, tokenStorageStrategy).then(function (storedAccessToken) {
                            if (storedAccessToken) {
                                // try using the stored access token
                                resource.getData(storedAccessToken).then(function () {
                                    if (resource.status === HTTPStatusCode.OK) {
                                        resolve(resource); // happy path ended
                                    }
                                    else {
                                        // the stored token is no good for this resource
                                        Utils.showAuthInteraction(resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, resolve, reject);
                                    }
                                })["catch"](function (message) {
                                    reject(Utils.createInternalServerError(message));
                                });
                            }
                            else {
                                // There was no stored token, but the user might have a cookie that will grant a token
                                getAccessToken(resource, false).then(function (accessToken) {
                                    if (accessToken) {
                                        storeAccessToken(resource, accessToken, tokenStorageStrategy).then(function () {
                                            // try using the fresh access token
                                            resource.getData(accessToken).then(function () {
                                                if (resource.status === HTTPStatusCode.OK) {
                                                    resolve(resource);
                                                }
                                                else {
                                                    // User has a token, but it's not good enough
                                                    Utils.showAuthInteraction(resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, resolve, reject);
                                                }
                                            })["catch"](function (message) {
                                                reject(Utils.createInternalServerError(message));
                                            });
                                        })["catch"](function (message) {
                                            // not able to store access token
                                            reject(Utils.createInternalServerError(message));
                                        });
                                    }
                                    else {
                                        // The user did not have a cookie that granted a token
                                        Utils.showAuthInteraction(resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, resolve, reject);
                                    }
                                });
                            }
                        })["catch"](function (message) {
                            reject(Utils.createInternalServerError(message));
                        });
                    }
                    else {
                        // this info.json isn't access controlled, therefore there's no need to request an access token
                        resolve(resource);
                    }
                });
            });
        };
        Utils.showAuthInteraction = function (resource, tokenStorageStrategy, clickThrough, restricted, login, getAccessToken, storeAccessToken, resolve, reject) {
            if (resource.status === HTTPStatusCode.MOVED_TEMPORARILY && !resource.isResponseHandled) {
                // if the resource was redirected to a degraded version
                // and the response hasn't been handled yet.
                // if the client wishes to trigger a login, set resource.isResponseHandled to true
                // and call loadExternalResources() again passing the resource.
                resolve(resource);
                // } else if (resource.restrictedService) {
                //     resolve(restricted(resource));
                //     // TODO: move to next etc
            }
            else if (resource.clickThroughService && !resource.isResponseHandled) {
                // if the resource has a click through service, use that.
                clickThrough(resource).then(function () {
                    getAccessToken(resource, true).then(function (accessToken) {
                        storeAccessToken(resource, accessToken, tokenStorageStrategy).then(function () {
                            resource.getData(accessToken).then(function () {
                                resolve(resource);
                            })["catch"](function (message) {
                                reject(Utils.createInternalServerError(message));
                            });
                        })["catch"](function (message) {
                            reject(Utils.createInternalServerError(message));
                        });
                    })["catch"](function (message) {
                        reject(Utils.createInternalServerError(message));
                    });
                });
            }
            else {
                // get an access token
                login(resource).then(function () {
                    getAccessToken(resource, true).then(function (accessToken) {
                        storeAccessToken(resource, accessToken, tokenStorageStrategy).then(function () {
                            resource.getData(accessToken).then(function () {
                                resolve(resource);
                            })["catch"](function (message) {
                                reject(Utils.createInternalServerError(message));
                            });
                        })["catch"](function (message) {
                            reject(Utils.createInternalServerError(message));
                        });
                    })["catch"](function (message) {
                        reject(Utils.createInternalServerError(message));
                    });
                });
            }
        };
        ;
        Utils.getService = function (resource, profile) {
            var services = this.getServices(resource);
            // coerce profile to string
            if (typeof (profile) !== 'string') {
                profile = profile.toString();
            }
            for (var i = 0; i < services.length; i++) {
                var service = services[i];
                if (service.getProfile().toString() === profile) {
                    return service;
                }
            }
            return null;
        };
        Utils.getResourceById = function (parentResource, id) {
            return Utils.traverseAndFind(parentResource.__jsonld, '@id', id);
        };
        /**
         * Does a depth first traversal of an Object, returning an Object that
         * matches provided k and v arguments
         * @example Utils.traverseAndFind({foo: 'bar'}, 'foo', 'bar')
         */
        Utils.traverseAndFind = function (object, k, v) {
            if (object.hasOwnProperty(k) && object[k] === v) {
                return object;
            }
            for (var i = 0; i < Object.keys(object).length; i++) {
                if (typeof object[Object.keys(object)[i]] === "object") {
                    var o = Utils.traverseAndFind(object[Object.keys(object)[i]], k, v);
                    if (o != null) {
                        return o;
                    }
                }
            }
        };
        Utils.getServices = function (resource) {
            var service;
            // if passing a manifesto-parsed object, use the __jsonld.service property,
            // otherwise look for a service property (info.json services)
            if (resource.__jsonld) {
                service = resource.__jsonld.service;
            }
            else {
                service = resource.service;
            }
            var services = [];
            if (!service)
                return services;
            // coerce to array
            if (!Array.isArray(service)) {
                service = [service];
            }
            for (var i = 0; i < service.length; i++) {
                var s = service[i];
                if (typeof (s) === 'string') {
                    var r = this.getResourceById(resource.options.resource, s);
                    if (r) {
                        services.push(new Manifesto.Service(r.__jsonld || r, resource.options));
                    }
                }
                else {
                    services.push(new Manifesto.Service(s, resource.options));
                }
            }
            return services;
        };
        Utils.getTemporalComponent = function (target) {
            var temporal = /t=([^&]+)/g.exec(target);
            var t = null;
            if (temporal && temporal[1]) {
                t = temporal[1].split(',');
            }
            return t;
        };
        return Utils;
    }());
    Manifesto.Utils = Utils;
})(Manifesto || (Manifesto = {}));

var Manifesto;
(function (Manifesto) {
    var Language = /** @class */ (function () {
        function Language(value, locale) {
            if (Array.isArray(value)) {
                if (value.length === 1) {
                    this.value = value[0];
                }
                else {
                    // concatenate all of the values
                    this.value = value.join('<br/>');
                }
            }
            else {
                this.value = value;
            }
            this.locale = locale;
        }
        return Language;
    }());
    Manifesto.Language = Language;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var LanguageMap = /** @class */ (function (_super) {
        __extends(LanguageMap, _super);
        function LanguageMap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LanguageMap.parse = function (language, defaultLocale) {
            var tc = [];
            var t;
            if (!language) {
                return tc;
            }
            else if (Array.isArray(language)) {
                for (var i = 0; i < language.length; i++) {
                    var value = language[i];
                    if (typeof (value) === 'string') {
                        t = new Manifesto.Language(value, defaultLocale);
                    }
                    else {
                        t = new Manifesto.Language(value['@value'], value['@language'] || defaultLocale);
                    }
                    tc.push(t);
                }
            }
            else if (typeof (language) === 'string') {
                // if it's just a single string value, create one language in the configured locale
                t = new Manifesto.Language(language, defaultLocale);
                tc.push(t);
                return tc;
            }
            else {
                // it's an object
                if (language['@value']) {
                    // presentation 2
                    t = new Manifesto.Language(language['@value'], language['@language'] || defaultLocale);
                    tc.push(t);
                }
                else {
                    // presentation 3
                    Object.keys(language).forEach(function (key) {
                        // todo: support multiple values in array
                        if (language[key].length) {
                            t = new Manifesto.Language(language[key], key);
                            tc.push(t);
                        }
                        else {
                            throw new Error('language must have a value');
                        }
                    });
                }
            }
            return tc;
        };
        LanguageMap.getValue = function (languageCollection, locale) {
            if (languageCollection.length) {
                if (locale) {
                    var language = languageCollection.filter(function (t) { return t.locale === locale || Manifesto.Utils.getInexactLocale(t.locale) === Manifesto.Utils.getInexactLocale(locale); })[0];
                    if (language) {
                        return language.value;
                    }
                }
                // return the first valuel
                return languageCollection[0].value;
            }
            return null;
        };
        return LanguageMap;
    }(Array));
    Manifesto.LanguageMap = LanguageMap;
})(Manifesto || (Manifesto = {}));

var Manifesto;
(function (Manifesto) {
    var LabelValuePair = /** @class */ (function () {
        function LabelValuePair(defaultLocale) {
            this.defaultLocale = defaultLocale;
        }
        LabelValuePair.prototype.parse = function (resource) {
            this.resource = resource;
            this.label = Manifesto.LanguageMap.parse(this.resource.label, this.defaultLocale);
            this.value = Manifesto.LanguageMap.parse(this.resource.value, this.defaultLocale);
        };
        // shortcuts to get/set values based on default locale
        LabelValuePair.prototype.getLabel = function () {
            if (this.label) {
                return Manifesto.LanguageMap.getValue(this.label, this.defaultLocale);
            }
            return null;
        };
        LabelValuePair.prototype.setLabel = function (value) {
            var _this = this;
            if (this.label && this.label.length) {
                var t = this.label.filter(function (x) { return x.locale === _this.defaultLocale || x.locale === Manifesto.Utils.getInexactLocale(_this.defaultLocale); })[0];
                if (t)
                    t.value = value;
            }
        };
        LabelValuePair.prototype.getValue = function () {
            if (this.value) {
                var locale = this.defaultLocale;
                // if the label has a locale, prefer that to the default locale
                if (this.label && this.label.length && this.label[0].locale) {
                    locale = this.label[0].locale;
                }
                return Manifesto.LanguageMap.getValue(this.value, locale);
            }
            return null;
        };
        LabelValuePair.prototype.setValue = function (value) {
            var _this = this;
            if (this.value && this.value.length) {
                var t = this.value.filter(function (x) { return x.locale === _this.defaultLocale || x.locale === Manifesto.Utils.getInexactLocale(_this.defaultLocale); })[0];
                if (t)
                    t.value = value;
            }
        };
        return LabelValuePair;
    }());
    Manifesto.LabelValuePair = LabelValuePair;
})(Manifesto || (Manifesto = {}));

var Manifesto;
(function (Manifesto) {
    var Size = /** @class */ (function () {
        function Size(width, height) {
            this.width = width;
            this.height = height;
        }
        return Size;
    }());
    Manifesto.Size = Size;
})(Manifesto || (Manifesto = {}));

global.manifesto = global.Manifesto = module.exports = {
    AnnotationMotivation: new Manifesto.AnnotationMotivation(),
    Behavior: new Manifesto.Behavior(),
    IIIFResourceType: new Manifesto.IIIFResourceType(),
    LabelValuePair: Manifesto.LabelValuePair,
    Language: Manifesto.Language,
    LanguageMap: Manifesto.LanguageMap,
    ManifestType: new Manifesto.ManifestType(),
    MediaType: new Manifesto.MediaType(),
    RenderingFormat: new Manifesto.RenderingFormat(),
    ResourceType: new Manifesto.ResourceType(),
    ServiceProfile: new Manifesto.ServiceProfile(),
    Size: Manifesto.Size,
    TreeNode: Manifesto.TreeNode,
    TreeNodeType: new Manifesto.TreeNodeType(),
    Utils: Manifesto.Utils,
    ViewingDirection: new Manifesto.ViewingDirection(),
    ViewingHint: new Manifesto.ViewingHint(),
    Annotation: Manifesto.Annotation,
    AnnotationBody: Manifesto.AnnotationBody,
    AnnotationList: Manifesto.AnnotationList,
    AnnotationPage: Manifesto.AnnotationPage,
    Canvas: Manifesto.Canvas,
    Collection: Manifesto.Collection,
    Duration: Manifesto.Duration,
    Manifest: Manifesto.Manifest,
    Range: Manifesto.Range,
    Sequence: Manifesto.Sequence,
    Service: Manifesto.Service,
    Thumbnail: Manifesto.Thumbnail,
    Thumb: Manifesto.Thumb,
    StatusCodes: {
        AUTHORIZATION_FAILED: 1,
        FORBIDDEN: 2,
        INTERNAL_SERVER_ERROR: 3,
        RESTRICTED: 4
    },
    create: function (manifest, options) {
        return Manifesto.Deserialiser.parse(manifest, options);
    },
    loadManifest: function (uri) {
        return Manifesto.Utils.loadResource(uri);
    }
};

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Annotation = /** @class */ (function (_super) {
        __extends(Annotation, _super);
        function Annotation(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        Annotation.prototype.getBody = function () {
            var bodies = [];
            var body = this.getProperty('body');
            // todo: make this a generic "property that can be an object or array enumerator" util
            if (body) {
                if (Array.isArray(body)) {
                    for (var i = 0; i < body.length; i++) {
                        var b = body[i];
                        if (b.items) {
                            for (var i_1 = 0; i_1 < b.items.length; i_1++) { // todo: don't ignore that it's a choice. maybe add isChoice() to IAnnotationBody?
                                var c = b.items[i_1];
                                bodies.push(new Manifesto.AnnotationBody(c, this.options));
                            }
                        }
                        else {
                            bodies.push(new Manifesto.AnnotationBody(b, this.options));
                        }
                    }
                }
                else if (body.items) {
                    for (var i = 0; i < body.items.length; i++) {
                        var b = body.items[i];
                        bodies.push(new Manifesto.AnnotationBody(b, this.options));
                    }
                }
                else {
                    bodies.push(new Manifesto.AnnotationBody(body, this.options));
                }
            }
            return bodies;
        };
        Annotation.prototype.getMotivation = function () {
            var motivation = this.getProperty('motivation');
            if (motivation) {
                return new Manifesto.AnnotationMotivation(motivation.toLowerCase());
            }
            return null;
        };
        // open annotation
        Annotation.prototype.getOn = function () {
            return this.getProperty('on');
        };
        Annotation.prototype.getTarget = function () {
            return this.getProperty('target');
        };
        Annotation.prototype.getResource = function () {
            return new Manifesto.Resource(this.getProperty('resource'), this.options);
        };
        return Annotation;
    }(Manifesto.ManifestResource));
    Manifesto.Annotation = Annotation;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var AnnotationBody = /** @class */ (function (_super) {
        __extends(AnnotationBody, _super);
        function AnnotationBody(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        AnnotationBody.prototype.getFormat = function () {
            var format = this.getProperty('format');
            if (format) {
                return new Manifesto.MediaType(Manifesto.Utils.getMediaType(format));
            }
            return null;
        };
        AnnotationBody.prototype.getType = function () {
            var type = this.getProperty('type');
            if (type) {
                return new Manifesto.ResourceType(Manifesto.Utils.normaliseType(this.getProperty('type')));
            }
            return null;
        };
        AnnotationBody.prototype.getWidth = function () {
            return this.getProperty('width');
        };
        AnnotationBody.prototype.getHeight = function () {
            return this.getProperty('height');
        };
        return AnnotationBody;
    }(Manifesto.ManifestResource));
    Manifesto.AnnotationBody = AnnotationBody;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var AnnotationList = /** @class */ (function (_super) {
        __extends(AnnotationList, _super);
        function AnnotationList(label, jsonld, options) {
            var _this = _super.call(this, jsonld) || this;
            _this.label = label;
            _this.options = options;
            return _this;
        }
        AnnotationList.prototype.getIIIFResourceType = function () {
            return new Manifesto.IIIFResourceType(Manifesto.Utils.normaliseType(this.getProperty('type')));
        };
        AnnotationList.prototype.getLabel = function () {
            return this.label;
        };
        AnnotationList.prototype.getResources = function () {
            var _this = this;
            var resources = this.getProperty('resources');
            return resources.map(function (resource) { return new Manifesto.Annotation(resource, _this.options); });
        };
        AnnotationList.prototype.load = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (_this.isLoaded) {
                    resolve(_this);
                }
                else {
                    var id = _this.__jsonld.id;
                    if (!id) {
                        id = _this.__jsonld['@id'];
                    }
                    Manifesto.Utils.loadResource(id).then(function (data) {
                        _this.__jsonld = JSON.parse(data);
                        _this.context = _this.getProperty('context');
                        _this.id = _this.getProperty('id');
                        _this.isLoaded = true;
                        resolve(_this);
                    }).catch(reject);
                }
            });
        };
        return AnnotationList;
    }(Manifesto.JSONLDResource));
    Manifesto.AnnotationList = AnnotationList;
})(Manifesto || (Manifesto = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var AnnotationPage = /** @class */ (function (_super) {
        __extends(AnnotationPage, _super);
        function AnnotationPage(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        AnnotationPage.prototype.getItems = function () {
            return this.getProperty('items');
        };
        return AnnotationPage;
    }(Manifesto.ManifestResource));
    Manifesto.AnnotationPage = AnnotationPage;
})(Manifesto || (Manifesto = {}));

























var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifesto;
(function (Manifesto) {
    var Thumbnail = /** @class */ (function (_super) {
        __extends(Thumbnail, _super);
        function Thumbnail(jsonld, options) {
            return _super.call(this, jsonld, options) || this;
        }
        return Thumbnail;
    }(Manifesto.Resource));
    Manifesto.Thumbnail = Thumbnail;
})(Manifesto || (Manifesto = {}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"http":30,"https":9,"url":36}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":2,"ieee754":10,"isarray":13}],6:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],7:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":12}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],9:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":30}],10:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],11:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],12:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],13:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],14:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],17:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":15,"./encode":16}],18:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":20,"./_stream_writable":22,"core-util-is":7,"inherits":11,"process-nextick-args":26}],19:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":21,"core-util-is":7,"inherits":11}],20:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":18,"./internal/streams/BufferList":23,"./internal/streams/destroy":24,"./internal/streams/stream":25,"_process":14,"core-util-is":7,"events":8,"inherits":11,"isarray":13,"process-nextick-args":26,"safe-buffer":29,"string_decoder/":27,"util":3}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":18,"core-util-is":7,"inherits":11}],22:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":18,"./internal/streams/destroy":24,"./internal/streams/stream":25,"_process":14,"core-util-is":7,"inherits":11,"process-nextick-args":26,"safe-buffer":29,"timers":34,"util-deprecate":38}],23:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":29,"util":3}],24:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":26}],25:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":8}],26:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":14}],27:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":29}],28:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":18,"./lib/_stream_passthrough.js":19,"./lib/_stream_readable.js":20,"./lib/_stream_transform.js":21,"./lib/_stream_writable.js":22}],29:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":5}],30:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/request":32,"./lib/response":33,"builtin-status-codes":6,"url":36,"xtend":39}],31:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],32:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":31,"./response":33,"_process":14,"buffer":5,"inherits":11,"readable-stream":28,"to-arraybuffer":35}],33:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText

		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":31,"_process":14,"buffer":5,"inherits":11,"readable-stream":28}],34:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":14,"timers":34}],35:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":5}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":37,"punycode":4,"querystring":17}],37:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],38:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],39:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[1])(1)
});

// @iiif/manifold v1.2.37 https://github.com/iiif-commons/manifold#readme
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('lib/manifold.js',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.iiifmanifold = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){

var Manifold;
(function (Manifold) {
    var StringValue = /** @class */ (function () {
        function StringValue(value) {
            this.value = "";
            if (value) {
                this.value = value.toLowerCase();
            }
        }
        StringValue.prototype.toString = function () {
            return this.value;
        };
        return StringValue;
    }());
    Manifold.StringValue = StringValue;
})(Manifold || (Manifold = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Manifold;
(function (Manifold) {
    var TreeSortType = /** @class */ (function (_super) {
        __extends(TreeSortType, _super);
        function TreeSortType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // todo: use getters when ES3 target is no longer required.
        TreeSortType.prototype.date = function () {
            return new TreeSortType(TreeSortType.DATE.toString());
        };
        TreeSortType.prototype.none = function () {
            return new TreeSortType(TreeSortType.NONE.toString());
        };
        TreeSortType.DATE = new TreeSortType("date");
        TreeSortType.NONE = new TreeSortType("none");
        return TreeSortType;
    }(Manifold.StringValue));
    Manifold.TreeSortType = TreeSortType;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var AnnotationGroup = /** @class */ (function () {
        function AnnotationGroup(resource, canvasIndex) {
            this.rects = [];
            this.canvasIndex = canvasIndex;
            this.addRect(resource);
        }
        AnnotationGroup.prototype.addRect = function (resource) {
            var rect = new Manifold.AnnotationRect(resource);
            rect.canvasIndex = this.canvasIndex;
            rect.index = this.rects.length;
            this.rects.push(rect);
            // sort ascending
            this.rects.sort(function (a, b) {
                return a.index - b.index;
            });
        };
        return AnnotationGroup;
    }());
    Manifold.AnnotationGroup = AnnotationGroup;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var AnnotationRect = /** @class */ (function () {
        function AnnotationRect(result) {
            this.isVisible = true;
            var xywh = result.on.match(/.*xywh=(\d*),(\d*),(\d*),(\d*)/);
            this.x = Number(xywh[1]);
            this.y = Number(xywh[2]);
            this.width = Number(xywh[3]);
            this.height = Number(xywh[4]);
            this.chars = result.resource.chars;
        }
        return AnnotationRect;
    }());
    Manifold.AnnotationRect = AnnotationRect;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var Bootstrapper = /** @class */ (function () {
        function Bootstrapper(options) {
            this._options = options;
            this._options.locale = this._options.locale || 'en-GB'; // default locale
        }
        Bootstrapper.prototype.bootstrap = function (res, rej) {
            var that = this;
            return new Promise(function (resolve, reject) {
                // if this is a recursive bootstrap we will have existing resolve & reject methods.
                if (res && rej) {
                    resolve = res;
                    reject = rej;
                }
                var msie = that._detectIE();
                if (msie === false) {
                    manifesto.loadManifest(that._options.iiifResourceUri).then(function (json) {
                        that._loaded(that, json, resolve, reject);
                    });
                }
                else {
                    // if not a recent version of IE
                    if (msie > 0) {
                        if (msie === 9) {
                            // CORS not available, use jsonp
                            var settings = {
                                url: that._options.iiifResourceUri,
                                type: 'GET',
                                dataType: 'jsonp',
                                jsonp: 'callback',
                                jsonpCallback: 'manifestCallback'
                            };
                            $.ajax(settings);
                            global.manifestCallback = function (json) {
                                that._loaded(that, JSON.stringify(json), resolve, reject);
                            };
                        }
                        else {
                            $.getJSON(that._options.iiifResourceUri, function (json) {
                                that._loaded(that, JSON.stringify(json), resolve, reject);
                            });
                        }
                    }
                }
            });
        };
        Bootstrapper.prototype._loaded = function (bootstrapper, json, resolve, reject) {
            var iiifResource = manifesto.create(json, {
                locale: bootstrapper._options.locale
            });
            // only set the root IIIFResource on the first load
            if (!bootstrapper._options.iiifResource) {
                bootstrapper._options.iiifResource = iiifResource;
            }
            var collectionIndex = bootstrapper._options.collectionIndex; // this is either undefined, 0, or a positive number (defaults to undefined)
            var manifestIndex = bootstrapper._options.manifestIndex; // this is either 0 or a positive number (defaults to 0)
            if (iiifResource.getIIIFResourceType().toString() === manifesto.IIIFResourceType.collection().toString() ||
                iiifResource.getIIIFResourceType().toString().toLowerCase() === 'collection') {
                // it's a collection
                var manifests = iiifResource.getManifests();
                var collections = iiifResource.getCollections();
                // if there are only collections available, set the collectionIndex to 0 if undefined.
                if (!manifests.length && collectionIndex === undefined) {
                    collectionIndex = 0;
                }
                if (collectionIndex !== undefined && collections && collections.length) {
                    // a collectionIndex has been passed and we have sub collections
                    iiifResource.getCollectionByIndex(collectionIndex).then(function (collection) {
                        if (!collection) {
                            reject('Collection index not found');
                        }
                        // Special case: we're trying to load the first manifest of the
                        // specified collection, but the collection has no manifests but does have
                        // subcollections. Thus, we should dive in until we find something
                        // we can display!
                        if (collection.getTotalManifests() === 0 && manifestIndex === 0 && collection.getTotalCollections() > 0) {
                            bootstrapper._options.collectionIndex = 0;
                            bootstrapper._options.iiifResourceUri = collection.id;
                            bootstrapper.bootstrap(resolve, reject);
                        }
                        else {
                            collection.getManifestByIndex(manifestIndex).then(function (manifest) {
                                bootstrapper._options.manifest = manifest;
                                var helper = new Manifold.Helper(bootstrapper._options);
                                resolve(helper);
                            });
                        }
                    });
                }
                else {
                    iiifResource.getManifestByIndex(bootstrapper._options.manifestIndex).then(function (manifest) {
                        bootstrapper._options.manifest = manifest;
                        var helper = new Manifold.Helper(bootstrapper._options);
                        resolve(helper);
                    });
                }
            }
            else {
                bootstrapper._options.manifest = iiifResource;
                var helper = new Manifold.Helper(bootstrapper._options);
                resolve(helper);
            }
        };
        Bootstrapper.prototype._detectIE = function () {
            var ua = window.navigator.userAgent;
            // Test values; Uncomment to check result 
            // IE 10
            // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';
            // IE 11
            // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';
            // Edge 12 (Spartan)
            // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';
            // Edge 13
            // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';
            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }
            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }
            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }
            // other browser
            return false;
        };
        return Bootstrapper;
    }());
    Manifold.Bootstrapper = Bootstrapper;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var ExternalResource = /** @class */ (function () {
        function ExternalResource(canvas, options) {
            this.authHoldingPage = null;
            this.clickThroughService = null;
            this.externalService = null;
            this.isProbed = false;
            this.isResponseHandled = false;
            this.kioskService = null;
            this.loginService = null;
            this.logoutService = null;
            this.probeService = null;
            this.restrictedService = null;
            this.tokenService = null;
            canvas.externalResource = this;
            this.dataUri = this._getDataUri(canvas);
            this.index = canvas.index;
            this.authAPIVersion = options.authApiVersion;
            this._parseAuthServices(canvas);
            // get the height and width of the image resource if available
            this._parseDimensions(canvas);
        }
        ExternalResource.prototype._getImageServiceDescriptor = function (services) {
            var infoUri = null;
            for (var i = 0; i < services.length; i++) {
                var service = services[i];
                var id = service.id;
                if (!id.endsWith('/')) {
                    id += '/';
                }
                if (manifesto.Utils.isImageProfile(service.getProfile())) {
                    infoUri = id + 'info.json';
                }
            }
            return infoUri;
        };
        ExternalResource.prototype._getDataUri = function (canvas) {
            var content = canvas.getContent();
            var images = canvas.getImages();
            var infoUri = null;
            // presentation 3
            if (content && content.length) {
                var annotation = content[0];
                var annotationBody = annotation.getBody();
                if (annotationBody.length) {
                    var body = annotationBody[0];
                    var services = body.getServices();
                    if (services.length) {
                        infoUri = this._getImageServiceDescriptor(services);
                        if (infoUri) {
                            return infoUri;
                        }
                    }
                    // no image services. return the image id
                    return annotationBody[0].id;
                }
                return null;
            }
            else if (images && images.length) {
                var firstImage = images[0];
                var resource = firstImage.getResource();
                var services = resource.getServices();
                if (services.length) {
                    infoUri = this._getImageServiceDescriptor(services);
                    if (infoUri) {
                        return infoUri;
                    }
                }
                // no image services. return the image id
                return resource.id;
            }
            else {
                // Legacy IxIF
                var service = canvas.getService(manifesto.ServiceProfile.ixif());
                if (service) {
                    return service.getInfoUri();
                }
                // return the canvas id.
                return canvas.id;
            }
        };
        ExternalResource.prototype._parseAuthServices = function (resource) {
            if (this.authAPIVersion === 0.9) {
                this.clickThroughService = manifesto.Utils.getService(resource, manifesto.ServiceProfile.clickThrough().toString());
                this.loginService = manifesto.Utils.getService(resource, manifesto.ServiceProfile.login().toString());
                this.restrictedService = manifesto.Utils.getService(resource, manifesto.ServiceProfile.restricted().toString());
                if (this.clickThroughService) {
                    this.logoutService = this.clickThroughService.getService(manifesto.ServiceProfile.logout().toString());
                    this.tokenService = this.clickThroughService.getService(manifesto.ServiceProfile.token().toString());
                }
                else if (this.loginService) {
                    this.logoutService = this.loginService.getService(manifesto.ServiceProfile.logout().toString());
                    this.tokenService = this.loginService.getService(manifesto.ServiceProfile.token().toString());
                }
                else if (this.restrictedService) {
                    this.logoutService = this.restrictedService.getService(manifesto.ServiceProfile.logout().toString());
                    this.tokenService = this.restrictedService.getService(manifesto.ServiceProfile.token().toString());
                }
            }
            else {
                // if the resource is a canvas, not an info.json, look for auth services on its content.
                if (resource.isCanvas !== undefined && resource.isCanvas()) {
                    var content = resource.getContent();
                    if (content && content.length) {
                        var body = content[0].getBody();
                        if (body && body.length) {
                            var annotation = body[0];
                            resource = annotation;
                        }
                    }
                }
                this.clickThroughService = manifesto.Utils.getService(resource, manifesto.ServiceProfile.auth1Clickthrough().toString());
                this.loginService = manifesto.Utils.getService(resource, manifesto.ServiceProfile.auth1Login().toString());
                this.externalService = manifesto.Utils.getService(resource, manifesto.ServiceProfile.auth1External().toString());
                this.kioskService = manifesto.Utils.getService(resource, manifesto.ServiceProfile.auth1Kiosk().toString());
                if (this.clickThroughService) {
                    this.logoutService = this.clickThroughService.getService(manifesto.ServiceProfile.auth1Logout().toString());
                    this.tokenService = this.clickThroughService.getService(manifesto.ServiceProfile.auth1Token().toString());
                    this.probeService = this.clickThroughService.getService(manifesto.ServiceProfile.auth1Probe().toString());
                }
                else if (this.loginService) {
                    this.logoutService = this.loginService.getService(manifesto.ServiceProfile.auth1Logout().toString());
                    this.tokenService = this.loginService.getService(manifesto.ServiceProfile.auth1Token().toString());
                    this.probeService = this.loginService.getService(manifesto.ServiceProfile.auth1Probe().toString());
                }
                else if (this.externalService) {
                    this.logoutService = this.externalService.getService(manifesto.ServiceProfile.auth1Logout().toString());
                    this.tokenService = this.externalService.getService(manifesto.ServiceProfile.auth1Token().toString());
                    this.probeService = this.externalService.getService(manifesto.ServiceProfile.auth1Probe().toString());
                }
                else if (this.kioskService) {
                    this.logoutService = this.kioskService.getService(manifesto.ServiceProfile.auth1Logout().toString());
                    this.tokenService = this.kioskService.getService(manifesto.ServiceProfile.auth1Token().toString());
                    this.probeService = this.kioskService.getService(manifesto.ServiceProfile.auth1Probe().toString());
                }
            }
        };
        ExternalResource.prototype._parseDimensions = function (canvas) {
            var images = canvas.getImages();
            if (images && images.length) {
                var firstImage = images[0];
                var resource = firstImage.getResource();
                this.width = resource.getWidth();
                this.height = resource.getHeight();
            }
            else {
                // presentation 3
                images = canvas.getContent();
                if (images.length) {
                    var annotation = images[0];
                    var body = annotation.getBody();
                    if (body.length) {
                        this.width = body[0].getWidth();
                        this.height = body[0].getHeight();
                    }
                }
            }
        };
        ExternalResource.prototype.isAccessControlled = function () {
            if (this.clickThroughService || this.loginService || this.externalService || this.kioskService || this.probeService) {
                return true;
            }
            return false;
        };
        ExternalResource.prototype.hasServiceDescriptor = function () {
            if (this.dataUri) {
                return this.dataUri.endsWith('info.json');
            }
            return false;
        };
        ExternalResource.prototype.getData = function (accessToken) {
            var _this = this;
            var that = this;
            that.data = {};
            return new Promise(function (resolve, reject) {
                if (!_this.dataUri) {
                    reject('There is no dataUri to fetch');
                }
                // if the resource has a probe service, use that to get http status code
                if (that.probeService && !that.isProbed) {
                    that.isProbed = true;
                    $.ajax({
                        url: that.probeService.id,
                        type: 'GET',
                        dataType: 'json'
                    }).done(function (data) {
                        var contentLocation = unescape(data.contentLocation);
                        if (contentLocation !== that.dataUri) {
                            that.status = HTTPStatusCode.MOVED_TEMPORARILY;
                        }
                        else {
                            that.status = HTTPStatusCode.OK;
                        }
                        resolve(that);
                    }).fail(function (error) {
                        that.status = error.status;
                        that.error = error;
                        resolve(that);
                    });
                }
                else {
                    // check if dataUri ends with info.json
                    // if not issue a HEAD request.
                    var type = 'GET';
                    if (!that.hasServiceDescriptor()) {
                        // If access control is unnecessary, short circuit the process.
                        // Note that isAccessControlled check for short-circuiting only
                        // works in the "binary resource" context, since in that case,
                        // we know about access control from the manifest. For image
                        // resources, we need to check info.json for details and can't
                        // short-circuit like this.
                        if (!that.isAccessControlled()) {
                            that.status = HTTPStatusCode.OK;
                            resolve(that);
                            return;
                        }
                        type = 'HEAD';
                    }
                    $.ajax({
                        url: that.dataUri,
                        type: type,
                        dataType: 'json',
                        beforeSend: function (xhr) {
                            if (accessToken) {
                                xhr.setRequestHeader("Authorization", "Bearer " + accessToken.accessToken);
                            }
                        }
                    }).done(function (data) {
                        // if it's a resource without an info.json
                        // todo: if resource doesn't have a @profile
                        if (!data) {
                            that.status = HTTPStatusCode.OK;
                            resolve(that);
                        }
                        else {
                            var uri = unescape(data['@id']);
                            that.data = data;
                            that._parseAuthServices(that.data);
                            // remove trailing /info.json
                            if (uri.endsWith('/info.json')) {
                                uri = uri.substr(0, uri.lastIndexOf('/'));
                            }
                            var dataUri = that.dataUri;
                            if (dataUri && dataUri.endsWith('/info.json')) {
                                dataUri = dataUri.substr(0, dataUri.lastIndexOf('/'));
                            }
                            // if the request was redirected to a degraded version and there's a login service to get the full quality version
                            if (uri !== dataUri && that.loginService) {
                                that.status = HTTPStatusCode.MOVED_TEMPORARILY;
                            }
                            else {
                                that.status = HTTPStatusCode.OK;
                            }
                            resolve(that);
                        }
                    }).fail(function (error) {
                        that.status = error.status;
                        that.error = error;
                        if (error.responseJSON) {
                            that._parseAuthServices(error.responseJSON);
                        }
                        resolve(that);
                    });
                }
            });
        };
        return ExternalResource;
    }());
    Manifold.ExternalResource = ExternalResource;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var Helper = /** @class */ (function () {
        function Helper(options) {
            this.options = options;
            this.iiifResource = this.options.iiifResource;
            this.iiifResourceUri = this.options.iiifResourceUri;
            this.manifest = this.options.manifest;
            this.collectionIndex = this.options.collectionIndex;
            this.manifestIndex = this.options.manifestIndex || 0;
            this.sequenceIndex = this.options.sequenceIndex || 0;
            this.canvasIndex = this.options.canvasIndex || 0;
        }
        // getters //
        Helper.prototype.getAutoCompleteService = function () {
            var service = this.getSearchService();
            if (service) {
                return service.getService(manifesto.ServiceProfile.autoComplete());
            }
            return null;
        };
        Helper.prototype.getAttribution = function () {
            console.warn('getAttribution will be deprecated, use getRequiredStatement instead.');
            var attribution = this.manifest.getAttribution();
            if (attribution) {
                return Manifesto.LanguageMap.getValue(attribution, this.options.locale);
            }
            return null;
        };
        Helper.prototype.getCanvases = function () {
            return this.getCurrentSequence().getCanvases();
        };
        Helper.prototype.getCanvasById = function (id) {
            return this.getCurrentSequence().getCanvasById(id);
        };
        Helper.prototype.getCanvasesById = function (ids) {
            var canvases = [];
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                var canvas = this.getCanvasById(id);
                if (canvas) {
                    canvases.push(canvas);
                }
            }
            return canvases;
        };
        Helper.prototype.getCanvasByIndex = function (index) {
            return this.getCurrentSequence().getCanvasByIndex(index);
        };
        Helper.prototype.getCanvasIndexById = function (id) {
            return this.getCurrentSequence().getCanvasIndexById(id);
        };
        Helper.prototype.getCanvasIndexByLabel = function (label) {
            var foliated = this.getManifestType().toString() === manifesto.ManifestType.manuscript().toString();
            return this.getCurrentSequence().getCanvasIndexByLabel(label, foliated);
        };
        Helper.prototype.getCanvasRange = function (canvas, path) {
            var ranges = this.getCanvasRanges(canvas);
            if (path) {
                for (var i = 0; i < ranges.length; i++) {
                    var range = ranges[i];
                    if (range.path === path) {
                        return range;
                    }
                }
                return null;
            }
            else {
                return ranges[0]; // else return the first range
            }
        };
        Helper.prototype.getCanvasRanges = function (canvas) {
            if (canvas.ranges) {
                return canvas.ranges; // cache
            }
            else {
                canvas.ranges = this.manifest.getAllRanges().en().where(function (range) { return (range.getCanvasIds().en().any(function (c) { return manifesto.Utils.normaliseUrl(c) === manifesto.Utils.normaliseUrl(canvas.id); })); }).toArray();
            }
            return canvas.ranges;
        };
        Helper.prototype.getCollectionIndex = function (iiifResource) {
            // todo: this only works for collections nested one level deep
            if (iiifResource.parentCollection && !iiifResource.parentCollection.parentCollection) {
                // manifest must be in the root
                return undefined;
            }
            else if (iiifResource.parentCollection) {
                return iiifResource.parentCollection.index;
            }
            return undefined;
        };
        Helper.prototype.getCurrentCanvas = function () {
            return this.getCurrentSequence().getCanvasByIndex(this.canvasIndex);
        };
        Helper.prototype.getCurrentSequence = function () {
            return this.getSequenceByIndex(this.sequenceIndex);
        };
        Helper.prototype.getDescription = function () {
            var description = this.manifest.getDescription();
            if (description) {
                return Manifesto.LanguageMap.getValue(description, this.options.locale);
            }
            return null;
        };
        Helper.prototype.getFirstPageIndex = function () {
            return 0;
        };
        Helper.prototype.getLabel = function () {
            var label = this.manifest.getLabel();
            if (label) {
                return Manifesto.LanguageMap.getValue(label, this.options.locale);
            }
            return null;
        };
        Helper.prototype.getLastCanvasLabel = function (alphanumeric) {
            return this.getCurrentSequence().getLastCanvasLabel(alphanumeric);
        };
        Helper.prototype.getLastPageIndex = function () {
            return this.getTotalCanvases() - 1;
        };
        Helper.prototype.getLicense = function () {
            return this.manifest.getLicense();
        };
        Helper.prototype.getLogo = function () {
            return this.manifest.getLogo();
        };
        Helper.prototype.getManifestType = function () {
            var manifestType = this.manifest.getManifestType();
            // default to monograph
            if (manifestType.toString() === "") {
                manifestType = manifesto.ManifestType.monograph();
            }
            return manifestType;
        };
        Helper.prototype.getMetadata = function (options) {
            var metadataGroups = [];
            var manifestMetadata = this.manifest.getMetadata();
            var manifestGroup = new Manifold.MetadataGroup(this.manifest);
            if (manifestMetadata && manifestMetadata.length) {
                manifestGroup.addMetadata(manifestMetadata, true);
            }
            if (this.manifest.getDescription().length) {
                var metadataItem = new Manifesto.LabelValuePair(this.options.locale);
                metadataItem.label = [new Manifesto.Language("description", this.options.locale)];
                metadataItem.value = this.manifest.getDescription();
                metadataItem.isRootLevel = true;
                manifestGroup.addItem(metadataItem);
            }
            if (this.manifest.getAttribution().length) {
                var metadataItem = new Manifesto.LabelValuePair(this.options.locale);
                metadataItem.label = [new Manifesto.Language("attribution", this.options.locale)];
                metadataItem.value = this.manifest.getAttribution();
                metadataItem.isRootLevel = true;
                manifestGroup.addItem(metadataItem);
            }
            var license = this.manifest.getLicense();
            if (license) {
                var item = {
                    label: "license",
                    value: (options && options.licenseFormatter) ? options.licenseFormatter.format(license) : license
                };
                var metadataItem = new Manifesto.LabelValuePair(this.options.locale);
                metadataItem.parse(item);
                metadataItem.isRootLevel = true;
                manifestGroup.addItem(metadataItem);
            }
            if (this.manifest.getLogo()) {
                var item = {
                    label: "logo",
                    value: '<img src="' + this.manifest.getLogo() + '"/>'
                };
                var metadataItem = new Manifesto.LabelValuePair(this.options.locale);
                metadataItem.parse(item);
                metadataItem.isRootLevel = true;
                manifestGroup.addItem(metadataItem);
            }
            metadataGroups.push(manifestGroup);
            if (options) {
                return this._parseMetadataOptions(options, metadataGroups);
            }
            else {
                return metadataGroups;
            }
        };
        Helper.prototype.getRequiredStatement = function () {
            var requiredStatement = this.manifest.getRequiredStatement();
            if (requiredStatement) {
                return {
                    label: requiredStatement.getLabel(),
                    value: requiredStatement.getValue()
                };
            }
            return null;
        };
        Helper.prototype._parseMetadataOptions = function (options, metadataGroups) {
            // get sequence metadata
            var sequence = this.getCurrentSequence();
            var sequenceMetadata = sequence.getMetadata();
            if (sequenceMetadata && sequenceMetadata.length) {
                var sequenceGroup = new Manifold.MetadataGroup(sequence);
                sequenceGroup.addMetadata(sequenceMetadata);
                metadataGroups.push(sequenceGroup);
            }
            // get range metadata
            if (options.range) {
                var rangeGroups = this._getRangeMetadata([], options.range);
                rangeGroups = rangeGroups.reverse();
                metadataGroups = metadataGroups.concat(rangeGroups);
            }
            // get canvas metadata
            if (options.canvases && options.canvases.length) {
                for (var i = 0; i < options.canvases.length; i++) {
                    var canvas = options.canvases[i];
                    var canvasMetadata = canvas.getMetadata();
                    if (canvasMetadata && canvasMetadata.length) {
                        var canvasGroup = new Manifold.MetadataGroup(canvas);
                        canvasGroup.addMetadata(canvas.getMetadata());
                        metadataGroups.push(canvasGroup);
                    }
                    // add image metadata
                    var images = canvas.getImages();
                    for (var j = 0; j < images.length; j++) {
                        var image = images[j];
                        var imageMetadata = image.getMetadata();
                        if (imageMetadata && imageMetadata.length) {
                            var imageGroup = new Manifold.MetadataGroup(image);
                            imageGroup.addMetadata(imageMetadata);
                            metadataGroups.push(imageGroup);
                        }
                    }
                }
            }
            return metadataGroups;
        };
        Helper.prototype._getRangeMetadata = function (metadataGroups, range) {
            var rangeMetadata = range.getMetadata();
            if (rangeMetadata && rangeMetadata.length) {
                var rangeGroup = new Manifold.MetadataGroup(range);
                rangeGroup.addMetadata(rangeMetadata);
                metadataGroups.push(rangeGroup);
            }
            else if (range.parentRange) {
                return this._getRangeMetadata(metadataGroups, range.parentRange);
            }
            return metadataGroups;
        };
        Helper.prototype.getMultiSelectState = function () {
            if (!this._multiSelectState) {
                this._multiSelectState = new Manifold.MultiSelectState();
                this._multiSelectState.ranges = this.getRanges().slice(0);
                this._multiSelectState.canvases = this.getCurrentSequence().getCanvases().slice(0);
            }
            return this._multiSelectState;
        };
        Helper.prototype.getCurrentRange = function () {
            if (this.rangeId) {
                return this.getRangeById(this.rangeId);
            }
            return null;
        };
        Helper.prototype.getPosterCanvas = function () {
            return this.manifest.getPosterCanvas();
        };
        Helper.prototype.getPosterImage = function () {
            var posterCanvas = this.getPosterCanvas();
            if (posterCanvas) {
                var content = posterCanvas.getContent();
                if (content && content.length) {
                    var anno = content[0];
                    var body = anno.getBody();
                    return body[0].id;
                }
            }
            return null;
        };
        Helper.prototype.getPreviousRange = function (range) {
            var currentRange = null;
            if (range) {
                currentRange = range;
            }
            else {
                currentRange = this.getCurrentRange();
            }
            if (currentRange) {
                var flatTree = this.getFlattenedTree();
                for (var i = 0; i < flatTree.length; i++) {
                    var node = flatTree[i];
                    // find current range in flattened tree
                    if (node.data.id === currentRange.id) {
                        // find the first node before it that has canvases
                        while (i > 0) {
                            i--;
                            var prevNode = flatTree[i];
                            return prevNode.data;
                        }
                        break;
                    }
                }
            }
            return null;
        };
        Helper.prototype.getNextRange = function (range) {
            // if a range is passed, use that. otherwise get the current range.
            var currentRange = null;
            if (range) {
                currentRange = range;
            }
            else {
                currentRange = this.getCurrentRange();
            }
            if (currentRange) {
                var flatTree = this.getFlattenedTree();
                for (var i = 0; i < flatTree.length; i++) {
                    var node = flatTree[i];
                    // find current range in flattened tree
                    if (node.data.id === currentRange.id) {
                        // find the first node after it that has canvases
                        while (i < flatTree.length - 1) {
                            i++;
                            var nextNode = flatTree[i];
                            if (nextNode.data.canvases && nextNode.data.canvases.length) {
                                return nextNode.data;
                            }
                        }
                        break;
                    }
                }
            }
            return null;
        };
        Helper.prototype.getFlattenedTree = function () {
            return this._flattenTree(this.getTree(), 'nodes');
        };
        Helper.prototype._flattenTree = function (root, key) {
            var _this = this;
            var flatten = [Object.assign({}, root)];
            delete flatten[0][key];
            if (root[key] && root[key].length > 0) {
                return flatten.concat(root[key]
                    .map(function (child) { return _this._flattenTree(child, key); })
                    .reduce(function (a, b) { return a.concat(b); }, []));
            }
            return flatten;
        };
        Helper.prototype.getRanges = function () {
            return this.manifest.getAllRanges();
        };
        Helper.prototype.getRangeByPath = function (path) {
            return this.manifest.getRangeByPath(path);
        };
        Helper.prototype.getRangeById = function (id) {
            return this.manifest.getRangeById(id);
        };
        Helper.prototype.getRangeCanvases = function (range) {
            var ids = range.getCanvasIds();
            return this.getCanvasesById(ids);
        };
        Helper.prototype.getRelated = function () {
            return this.manifest.getRelated();
        };
        Helper.prototype.getSearchService = function () {
            return this.manifest.getService(manifesto.ServiceProfile.search());
        };
        Helper.prototype.getSeeAlso = function () {
            return this.manifest.getSeeAlso();
        };
        Helper.prototype.getSequenceByIndex = function (index) {
            return this.manifest.getSequenceByIndex(index);
        };
        Helper.prototype.getShareServiceUrl = function () {
            var url = null;
            var shareService = this.manifest.getService(manifesto.ServiceProfile.shareExtensions());
            if (shareService) {
                if (shareService.length) {
                    shareService = shareService[0];
                }
                url = shareService.__jsonld.shareUrl;
            }
            return url;
        };
        Helper.prototype.getSortedTreeNodesByDate = function (sortedTree, tree) {
            var all = tree.nodes.en().traverseUnique(function (node) { return node.nodes; })
                .where(function (n) { return n.data.type === manifesto.TreeNodeType.collection().toString() ||
                n.data.type === manifesto.TreeNodeType.manifest().toString(); }).toArray();
            //var collections: ITreeNode[] = tree.nodes.en().traverseUnique(n => n.nodes)
            //    .where((n) => n.data.type === ITreeNodeType.collection().toString()).toArray();
            var manifests = tree.nodes.en().traverseUnique(function (n) { return n.nodes; })
                .where(function (n) { return n.data.type === manifesto.TreeNodeType.manifest().toString(); }).toArray();
            this.createDecadeNodes(sortedTree, all);
            this.sortDecadeNodes(sortedTree);
            this.createYearNodes(sortedTree, all);
            this.sortYearNodes(sortedTree);
            this.createMonthNodes(sortedTree, manifests);
            this.sortMonthNodes(sortedTree);
            this.createDateNodes(sortedTree, manifests);
            this.pruneDecadeNodes(sortedTree);
        };
        Helper.prototype.getStartCanvasIndex = function () {
            return this.getCurrentSequence().getStartCanvasIndex();
        };
        Helper.prototype.getThumbs = function (width, height) {
            return this.getCurrentSequence().getThumbs(width, height);
        };
        Helper.prototype.getTopRanges = function () {
            return this.manifest.getTopRanges();
        };
        Helper.prototype.getTotalCanvases = function () {
            return this.getCurrentSequence().getTotalCanvases();
        };
        Helper.prototype.getTrackingLabel = function () {
            return this.manifest.getTrackingLabel();
        };
        Helper.prototype._getTopRanges = function () {
            return this.iiifResource.getTopRanges();
        };
        Helper.prototype.getTree = function (topRangeIndex, sortType) {
            // if it's a collection, use IIIFResource.getDefaultTree()
            // otherwise, get the top range by index and use Range.getTree()
            if (topRangeIndex === void 0) { topRangeIndex = 0; }
            if (sortType === void 0) { sortType = Manifold.TreeSortType.NONE; }
            if (!this.iiifResource) {
                return null;
            }
            var tree;
            if (this.iiifResource.isCollection()) {
                tree = this.iiifResource.getDefaultTree();
            }
            else {
                var topRanges = this._getTopRanges();
                var root = new manifesto.TreeNode();
                root.label = 'root';
                root.data = this.iiifResource;
                if (topRanges.length) {
                    var range = topRanges[topRangeIndex];
                    tree = range.getTree(root);
                }
                else {
                    return root;
                }
            }
            var sortedTree = new manifesto.TreeNode();
            switch (sortType.toString()) {
                case Manifold.TreeSortType.DATE.toString():
                    // returns a list of treenodes for each decade.
                    // expanding a decade generates a list of years
                    // expanding a year gives a list of months containing issues
                    // expanding a month gives a list of issues.
                    if (this.treeHasNavDates(tree)) {
                        this.getSortedTreeNodesByDate(sortedTree, tree);
                        break;
                    }
                default:
                    sortedTree = tree;
            }
            return sortedTree;
        };
        Helper.prototype.treeHasNavDates = function (tree) {
            var node = tree.nodes.en().traverseUnique(function (node) { return node.nodes; }).where(function (n) { return !isNaN(n.navDate); }).first();
            return (node) ? true : false;
        };
        Helper.prototype.getViewingDirection = function () {
            var viewingDirection = this.getCurrentSequence().getViewingDirection();
            if (!viewingDirection) {
                viewingDirection = this.manifest.getViewingDirection();
            }
            return viewingDirection;
        };
        Helper.prototype.getViewingHint = function () {
            var viewingHint = this.getCurrentSequence().getViewingHint();
            if (!viewingHint) {
                viewingHint = this.manifest.getViewingHint();
            }
            return viewingHint;
        };
        // inquiries //
        Helper.prototype.hasParentCollection = function () {
            return !!this.manifest.parentCollection;
        };
        Helper.prototype.hasRelatedPage = function () {
            var related = this.getRelated();
            if (!related)
                return false;
            if (related.length) {
                related = related[0];
            }
            return related['format'] === 'text/html';
        };
        Helper.prototype.hasResources = function () {
            var canvas = this.getCurrentCanvas();
            return canvas.getResources().length > 0;
        };
        Helper.prototype.isBottomToTop = function () {
            var viewingDirection = this.getViewingDirection();
            if (viewingDirection) {
                return viewingDirection.toString() === manifesto.ViewingDirection.bottomToTop().toString();
            }
            return false;
        };
        Helper.prototype.isCanvasIndexOutOfRange = function (index) {
            return this.getCurrentSequence().isCanvasIndexOutOfRange(index);
        };
        Helper.prototype.isContinuous = function () {
            var viewingHint = this.getViewingHint();
            if (viewingHint) {
                return viewingHint.toString() === manifesto.ViewingHint.continuous().toString();
            }
            return false;
        };
        Helper.prototype.isFirstCanvas = function (index) {
            if (typeof index !== 'undefined') {
                return this.getCurrentSequence().isFirstCanvas(index);
            }
            return this.getCurrentSequence().isFirstCanvas(this.canvasIndex);
        };
        Helper.prototype.isHorizontallyAligned = function () {
            return this.isLeftToRight() || this.isRightToLeft();
        };
        Helper.prototype.isLastCanvas = function (index) {
            if (typeof index !== 'undefined') {
                return this.getCurrentSequence().isLastCanvas(index);
            }
            return this.getCurrentSequence().isLastCanvas(this.canvasIndex);
        };
        Helper.prototype.isLeftToRight = function () {
            var viewingDirection = this.getViewingDirection();
            if (viewingDirection) {
                return viewingDirection.toString() === manifesto.ViewingDirection.leftToRight().toString();
            }
            return false;
        };
        Helper.prototype.isMultiCanvas = function () {
            return this.getCurrentSequence().isMultiCanvas();
        };
        Helper.prototype.isMultiSequence = function () {
            return this.manifest.isMultiSequence();
        };
        Helper.prototype.isPaged = function () {
            // check the sequence for a viewingHint (deprecated)
            var viewingHint = this.getViewingHint();
            if (viewingHint) {
                return viewingHint.toString() === manifesto.ViewingHint.paged().toString();
            }
            // check the manifest for a viewingHint (deprecated) or paged behavior
            return this.manifest.isPagingEnabled();
        };
        Helper.prototype.isPagingAvailable = function () {
            // paged mode is useless unless you have at least 3 pages...
            return this.isPagingEnabled() && this.getTotalCanvases() > 2;
        };
        Helper.prototype.isPagingEnabled = function () {
            return (this.manifest.isPagingEnabled() || this.getCurrentSequence().isPagingEnabled());
        };
        Helper.prototype.isRightToLeft = function () {
            var viewingDirection = this.getViewingDirection();
            if (viewingDirection) {
                return viewingDirection.toString() === manifesto.ViewingDirection.rightToLeft().toString();
            }
            return false;
        };
        Helper.prototype.isTopToBottom = function () {
            var viewingDirection = this.getViewingDirection();
            if (viewingDirection) {
                return viewingDirection.toString() === manifesto.ViewingDirection.topToBottom().toString();
            }
            return false;
        };
        Helper.prototype.isTotalCanvasesEven = function () {
            return this.getCurrentSequence().isTotalCanvasesEven();
        };
        Helper.prototype.isUIEnabled = function (name) {
            var uiExtensions = this.manifest.getService(manifesto.ServiceProfile.uiExtensions());
            if (uiExtensions) {
                var disableUI = uiExtensions.getProperty('disableUI');
                if (disableUI) {
                    if (disableUI.indexOf(name) !== -1 || disableUI.indexOf(name.toLowerCase()) !== -1) {
                        return false;
                    }
                }
            }
            return true;
        };
        Helper.prototype.isVerticallyAligned = function () {
            return this.isTopToBottom() || this.isBottomToTop();
        };
        // dates //
        Helper.prototype.createDateNodes = function (rootNode, nodes) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var year = this.getNodeYear(node);
                var month = this.getNodeMonth(node);
                var dateNode = new manifesto.TreeNode();
                dateNode.id = node.id;
                dateNode.label = this.getNodeDisplayDate(node);
                dateNode.data = node.data;
                dateNode.data.type = manifesto.TreeNodeType.manifest().toString();
                dateNode.data.year = year;
                dateNode.data.month = month;
                var decadeNode = this.getDecadeNode(rootNode, year);
                if (decadeNode) {
                    var yearNode = this.getYearNode(decadeNode, year);
                    if (yearNode) {
                        var monthNode = this.getMonthNode(yearNode, month);
                        if (monthNode) {
                            monthNode.addNode(dateNode);
                        }
                    }
                }
            }
        };
        Helper.prototype.createDecadeNodes = function (rootNode, nodes) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var year = this.getNodeYear(node);
                var endYear = Number(year.toString().substr(0, 3) + "9");
                if (!this.getDecadeNode(rootNode, year)) {
                    var decadeNode = new manifesto.TreeNode();
                    decadeNode.label = year + " - " + endYear;
                    decadeNode.navDate = node.navDate;
                    decadeNode.data.startYear = year;
                    decadeNode.data.endYear = endYear;
                    rootNode.addNode(decadeNode);
                }
            }
        };
        Helper.prototype.createMonthNodes = function (rootNode, nodes) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var year = this.getNodeYear(node);
                var month = this.getNodeMonth(node);
                var decadeNode = this.getDecadeNode(rootNode, year);
                var yearNode = null;
                if (decadeNode) {
                    yearNode = this.getYearNode(decadeNode, year);
                }
                if (decadeNode && yearNode && !this.getMonthNode(yearNode, month)) {
                    var monthNode = new manifesto.TreeNode();
                    monthNode.label = this.getNodeDisplayMonth(node);
                    monthNode.navDate = node.navDate;
                    monthNode.data.year = year;
                    monthNode.data.month = month;
                    yearNode.addNode(monthNode);
                }
            }
        };
        Helper.prototype.createYearNodes = function (rootNode, nodes) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var year = this.getNodeYear(node);
                var decadeNode = this.getDecadeNode(rootNode, year);
                if (decadeNode && !this.getYearNode(decadeNode, year)) {
                    var yearNode = new manifesto.TreeNode();
                    yearNode.label = year.toString();
                    yearNode.navDate = node.navDate;
                    yearNode.data.year = year;
                    decadeNode.addNode(yearNode);
                }
            }
        };
        Helper.prototype.getDecadeNode = function (rootNode, year) {
            for (var i = 0; i < rootNode.nodes.length; i++) {
                var n = rootNode.nodes[i];
                if (year >= n.data.startYear && year <= n.data.endYear)
                    return n;
            }
            return null;
        };
        Helper.prototype.getMonthNode = function (yearNode, month) {
            for (var i = 0; i < yearNode.nodes.length; i++) {
                var n = yearNode.nodes[i];
                if (month === this.getNodeMonth(n))
                    return n;
            }
            return null;
        };
        Helper.prototype.getNodeDisplayDate = function (node) {
            return node.navDate.toDateString();
        };
        Helper.prototype.getNodeDisplayMonth = function (node) {
            var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            return months[node.navDate.getMonth()];
        };
        Helper.prototype.getNodeMonth = function (node) {
            return node.navDate.getMonth();
        };
        Helper.prototype.getNodeYear = function (node) {
            return node.navDate.getFullYear();
        };
        Helper.prototype.getYearNode = function (decadeNode, year) {
            for (var i = 0; i < decadeNode.nodes.length; i++) {
                var n = decadeNode.nodes[i];
                if (year === this.getNodeYear(n))
                    return n;
            }
            return null;
        };
        // delete any empty decades
        Helper.prototype.pruneDecadeNodes = function (rootNode) {
            var pruned = [];
            for (var i = 0; i < rootNode.nodes.length; i++) {
                var n = rootNode.nodes[i];
                if (!n.nodes.length) {
                    pruned.push(n);
                }
            }
            for (var j = 0; j < pruned.length; j++) {
                var p = pruned[j];
                var index = rootNode.nodes.indexOf(p);
                if (index > -1) {
                    rootNode.nodes.splice(index, 1);
                }
            }
        };
        Helper.prototype.sortDecadeNodes = function (rootNode) {
            rootNode.nodes = rootNode.nodes.sort(function (a, b) {
                return a.data.startYear - b.data.startYear;
            });
        };
        Helper.prototype.sortMonthNodes = function (rootNode) {
            var _this = this;
            for (var i = 0; i < rootNode.nodes.length; i++) {
                var decadeNode = rootNode.nodes[i];
                for (var j = 0; j < decadeNode.nodes.length; j++) {
                    var monthNode = decadeNode.nodes[j];
                    monthNode.nodes = monthNode.nodes.sort(function (a, b) {
                        return _this.getNodeMonth(a) - _this.getNodeMonth(b);
                    });
                }
            }
        };
        Helper.prototype.sortYearNodes = function (rootNode) {
            var _this = this;
            for (var i = 0; i < rootNode.nodes.length; i++) {
                var decadeNode = rootNode.nodes[i];
                decadeNode.nodes = decadeNode.nodes.sort(function (a, b) {
                    return (_this.getNodeYear(a) - _this.getNodeYear(b));
                });
            }
        };
        return Helper;
    }());
    Manifold.Helper = Helper;
})(Manifold || (Manifold = {}));



var Manifold;
(function (Manifold) {
    var ILabelValuePair = /** @class */ (function () {
        function ILabelValuePair() {
        }
        return ILabelValuePair;
    }());
    Manifold.ILabelValuePair = ILabelValuePair;
})(Manifold || (Manifold = {}));








/// <reference types="manifesto.js" />
/// <reference types="http-status-codes" />
var Manifold;
(function (Manifold) {
    function loadManifest(options) {
        var bootstrapper = new Manifold.Bootstrapper(options);
        return bootstrapper.bootstrap();
    }
    Manifold.loadManifest = loadManifest;
})(Manifold || (Manifold = {}));
(function (g) {
    if (!g.Manifold) {
        g.Manifold = Manifold;
    }
})(global);

var Manifold;
(function (Manifold) {
    var MetadataGroup = /** @class */ (function () {
        function MetadataGroup(resource, label) {
            this.items = [];
            this.resource = resource;
            this.label = label;
        }
        MetadataGroup.prototype.addItem = function (item) {
            this.items.push(item);
        };
        MetadataGroup.prototype.addMetadata = function (metadata, isRootLevel) {
            if (isRootLevel === void 0) { isRootLevel = false; }
            for (var i = 0; i < metadata.length; i++) {
                var item = metadata[i];
                item.isRootLevel = isRootLevel;
                this.addItem(item);
            }
        };
        return MetadataGroup;
    }());
    Manifold.MetadataGroup = MetadataGroup;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var MetadataOptions = /** @class */ (function () {
        function MetadataOptions() {
        }
        return MetadataOptions;
    }());
    Manifold.MetadataOptions = MetadataOptions;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var MultiSelectState = /** @class */ (function () {
        function MultiSelectState() {
            this.isEnabled = false;
            this.ranges = [];
            this.canvases = [];
        }
        MultiSelectState.prototype.allCanvasesSelected = function () {
            return this.canvases.length > 0 && this.getAllSelectedCanvases().length === this.canvases.length;
        };
        MultiSelectState.prototype.allRangesSelected = function () {
            return this.ranges.length > 0 && this.getAllSelectedRanges().length === this.ranges.length;
        };
        MultiSelectState.prototype.allSelected = function () {
            return this.allRangesSelected() && this.allCanvasesSelected();
        };
        MultiSelectState.prototype.getAll = function () {
            return this.canvases.concat(this.ranges);
        };
        MultiSelectState.prototype.getAllSelectedCanvases = function () {
            return this.canvases.en().where(function (c) { return c.multiSelected; }).toArray();
        };
        MultiSelectState.prototype.getAllSelectedRanges = function () {
            return this.ranges.en().where(function (r) { return r.multiSelected; }).toArray();
        };
        MultiSelectState.prototype.getCanvasById = function (id) {
            return this.canvases.en().where(function (c) { return manifesto.Utils.normaliseUrl(c.id) === manifesto.Utils.normaliseUrl(id); }).first();
        };
        MultiSelectState.prototype.getCanvasesByIds = function (ids) {
            var canvases = [];
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                canvases.push(this.getCanvasById(id));
            }
            return canvases;
        };
        MultiSelectState.prototype.getRangeCanvases = function (range) {
            var ids = range.getCanvasIds();
            return this.getCanvasesByIds(ids);
        };
        MultiSelectState.prototype.selectAll = function (selected) {
            this.selectRanges(this.ranges, selected);
            this.selectCanvases(this.canvases, selected);
        };
        MultiSelectState.prototype.selectCanvas = function (canvas, selected) {
            var c = this.canvases.en().where(function (c) { return c.id === canvas.id; }).first();
            c.multiSelected = selected;
        };
        MultiSelectState.prototype.selectAllCanvases = function (selected) {
            this.selectCanvases(this.canvases, selected);
        };
        MultiSelectState.prototype.selectCanvases = function (canvases, selected) {
            for (var j = 0; j < canvases.length; j++) {
                var canvas = canvases[j];
                canvas.multiSelected = selected;
            }
        };
        MultiSelectState.prototype.selectRange = function (range, selected) {
            var r = this.ranges.en().where(function (r) { return r.id === range.id; }).first();
            r.multiSelected = selected;
            var canvases = this.getRangeCanvases(r);
            this.selectCanvases(canvases, selected);
        };
        MultiSelectState.prototype.selectAllRanges = function (selected) {
            this.selectRanges(this.ranges, selected);
        };
        MultiSelectState.prototype.selectRanges = function (ranges, selected) {
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                range.multiSelected = selected;
                var canvases = this.getCanvasesByIds(range.getCanvasIds());
                this.selectCanvases(canvases, selected);
            }
        };
        MultiSelectState.prototype.setEnabled = function (enabled) {
            this.isEnabled = enabled;
            var items = this.getAll();
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                item.multiSelectEnabled = this.isEnabled;
                if (!enabled) {
                    item.multiSelected = false;
                }
            }
        };
        return MultiSelectState;
    }());
    Manifold.MultiSelectState = MultiSelectState;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    var Translation = /** @class */ (function () {
        function Translation(value, locale) {
            this.value = value;
            this.locale = locale;
        }
        return Translation;
    }());
    Manifold.Translation = Translation;
})(Manifold || (Manifold = {}));

var Manifold;
(function (Manifold) {
    // This class formats URIs into HTML <a> links, applying labels when available
    var UriLabeller = /** @class */ (function () {
        function UriLabeller(labels) {
            this.labels = labels;
        }
        UriLabeller.prototype.format = function (url) {
            // if already a link, do nothing.
            if (url.indexOf('<a') != -1)
                return url;
            var label = (this.labels[url]) ? this.labels[url] : url;
            return '<a href="' + url + '">' + label + '</a>';
        };
        return UriLabeller;
    }());
    Manifold.UriLabeller = UriLabeller;
})(Manifold || (Manifold = {}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1])(1)
});

var Utils;
(function (Utils) {
    var Async = /** @class */ (function () {
        function Async() {
        }
        Async.waitFor = function (test, successCallback, failureCallback, interval, maxTries, numTries) {
            if (!interval)
                interval = 200;
            if (!maxTries)
                maxTries = 100; // try 100 times over 20 seconds
            if (!numTries)
                numTries = 0;
            numTries += 1;
            if (numTries > maxTries) {
                if (failureCallback)
                    failureCallback();
            }
            else if (test()) {
                successCallback();
            }
            else {
                setTimeout(function () {
                    Async.waitFor(test, successCallback, failureCallback, interval, maxTries, numTries);
                }, interval);
            }
        };
        return Async;
    }());
    Utils.Async = Async;
    var Bools = /** @class */ (function () {
        function Bools() {
        }
        Bools.getBool = function (val, defaultVal) {
            if (val === null || typeof (val) === 'undefined') {
                return defaultVal;
            }
            return val;
        };
        return Bools;
    }());
    Utils.Bools = Bools;
    var Clipboard = /** @class */ (function () {
        function Clipboard() {
        }
        Clipboard.supportsCopy = function () {
            return document.queryCommandSupported && document.queryCommandSupported('copy');
        };
        Clipboard.copy = function (text) {
            text = Clipboard.convertBrToNewLine(text);
            var textArea = document.createElement("textarea");
            textArea.value = text;
            Clipboard.hideButKeepEnabled(textArea);
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
        };
        Clipboard.hideButKeepEnabled = function (textArea) {
            // Place in top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = '0';
            textArea.style.left = '0';
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = '0';
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            // Avoid flash of white box if rendered for any reason.
            textArea.style.background = 'transparent';
        };
        Clipboard.convertBrToNewLine = function (text) {
            var brRegex = /<br\s*[\/]?>/gi;
            text = text.replace(brRegex, "\n");
            return text;
        };
        return Clipboard;
    }());
    Utils.Clipboard = Clipboard;
    var Colors = /** @class */ (function () {
        function Colors() {
        }
        Colors.float32ColorToARGB = function (float32Color) {
            var a = (float32Color & 0xff000000) >>> 24;
            var r = (float32Color & 0xff0000) >>> 16;
            var g = (float32Color & 0xff00) >>> 8;
            var b = float32Color & 0xff;
            var result = [a, r, g, b];
            return result;
        };
        Colors._componentToHex = function (c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        };
        Colors.rgbToHexString = function (rgb) {
            Colors.coalesce(rgb);
            return "#" + Colors._componentToHex(rgb[0]) + Colors._componentToHex(rgb[1]) + Colors._componentToHex(rgb[2]);
        };
        Colors.argbToHexString = function (argb) {
            return "#" + Colors._componentToHex(argb[0]) + Colors._componentToHex(argb[1]) + Colors._componentToHex(argb[2]) + Colors._componentToHex(argb[3]);
        };
        Colors.coalesce = function (arr) {
            for (var i = 1; i < arr.length; i++) {
                if (typeof (arr[i]) === 'undefined')
                    arr[i] = arr[i - 1];
            }
        };
        return Colors;
    }());
    Utils.Colors = Colors;
    var Dates = /** @class */ (function () {
        function Dates() {
        }
        Dates.getTimeStamp = function () {
            return new Date().getTime();
        };
        return Dates;
    }());
    Utils.Dates = Dates;
    var Device = /** @class */ (function () {
        function Device() {
        }
        Device.getPixelRatio = function (ctx) {
            var dpr = window.devicePixelRatio || 1;
            var bsr = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;
            return dpr / bsr;
        };
        Device.isTouch = function () {
            return !!("ontouchstart" in window) || window.navigator.msMaxTouchPoints > 0;
        };
        return Device;
    }());
    Utils.Device = Device;
    var Documents = /** @class */ (function () {
        function Documents() {
        }
        Documents.isInIFrame = function () {
            // see http://stackoverflow.com/questions/326069/how-to-identify-if-a-webpage-is-being-loaded-inside-an-iframe-or-directly-into-t
            try {
                return window.self !== window.top;
            }
            catch (e) {
                return true;
            }
        };
        Documents.supportsFullscreen = function () {
            var doc = document.documentElement;
            var support = doc.requestFullscreen || doc.mozRequestFullScreen ||
                doc.webkitRequestFullScreen || doc.msRequestFullscreen;
            return support !== undefined;
        };
        Documents.isHidden = function () {
            var prop = Documents.getHiddenProp();
            if (!prop)
                return false;
            return true;
            //return document[prop];
        };
        Documents.getHiddenProp = function () {
            var prefixes = ['webkit', 'moz', 'ms', 'o'];
            // if 'hidden' is natively supported just return it
            if ('hidden' in document)
                return 'hidden';
            // otherwise loop over all the known prefixes until we find one
            for (var i = 0; i < prefixes.length; i++) {
                if ((prefixes[i] + 'Hidden') in document) {
                    return prefixes[i] + 'Hidden';
                }
            }
            // otherwise it's not supported
            return null;
        };
        return Documents;
    }());
    Utils.Documents = Documents;
    var Events = /** @class */ (function () {
        function Events() {
        }
        Events.debounce = function (fn, debounceDuration) {
            // summary:
            //      Returns a debounced function that will make sure the given
            //      function is not triggered too much.
            // fn: Function
            //      Function to debounce.
            // debounceDuration: Number
            //      OPTIONAL. The amount of time in milliseconds for which we
            //      will debounce the function. (defaults to 100ms)
            debounceDuration = debounceDuration || 100;
            return function () {
                if (!fn.debouncing) {
                    var args = Array.prototype.slice.apply(arguments);
                    fn.lastReturnVal = fn.apply(window, args);
                    fn.debouncing = true;
                }
                clearTimeout(fn.debounceTimeout);
                fn.debounceTimeout = setTimeout(function () {
                    fn.debouncing = false;
                }, debounceDuration);
                return fn.lastReturnVal;
            };
        };
        return Events;
    }());
    Utils.Events = Events;
    var Files = /** @class */ (function () {
        function Files() {
        }
        Files.simplifyMimeType = function (mime) {
            switch (mime) {
                case 'text/plain':
                    return 'txt';
                case 'image/jpeg':
                    return 'jpg';
                case 'application/msword':
                    return 'doc';
                case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
                    return 'docx';
                default:
                    var parts = mime.split('/');
                    return parts[parts.length - 1];
            }
        };
        return Files;
    }());
    Utils.Files = Files;
    var Keyboard = /** @class */ (function () {
        function Keyboard() {
        }
        Keyboard.getCharCode = function (e) {
            var charCode = (typeof e.which == "number") ? e.which : e.keyCode;
            return charCode;
        };
        return Keyboard;
    }());
    Utils.Keyboard = Keyboard;
    var Maths = /** @class */ (function () {
        function Maths() {
        }
        Maths.normalise = function (num, min, max) {
            return (num - min) / (max - min);
        };
        Maths.median = function (values) {
            values.sort(function (a, b) {
                return a - b;
            });
            var half = Math.floor(values.length / 2);
            if (values.length % 2) {
                return values[half];
            }
            else {
                return (values[half - 1] + values[half]) / 2.0;
            }
        };
        Maths.clamp = function (value, min, max) {
            return Math.min(Math.max(value, min), max);
        };
        return Maths;
    }());
    Utils.Maths = Maths;
    var Size = /** @class */ (function () {
        function Size(width, height) {
            this.width = width;
            this.height = height;
        }
        return Size;
    }());
    Utils.Size = Size;
    var Dimensions = /** @class */ (function () {
        function Dimensions() {
        }
        Dimensions.fitRect = function (width1, height1, width2, height2) {
            var ratio1 = height1 / width1;
            var ratio2 = height2 / width2;
            var width = 0;
            var height = 0;
            var scale;
            if (ratio1 < ratio2) {
                scale = width2 / width1;
                width = width1 * scale;
                height = height1 * scale;
            }
            else {
                scale = height2 / height1;
                width = width1 * scale;
                height = height1 * scale;
            }
            return new Size(Math.floor(width), Math.floor(height));
        };
        Dimensions.hitRect = function (x, y, w, h, mx, my) {
            if (mx > x && mx < (x + w) && my > y && my < (y + h)) {
                return true;
            }
            return false;
        };
        return Dimensions;
    }());
    Utils.Dimensions = Dimensions;
    var Numbers = /** @class */ (function () {
        function Numbers() {
        }
        Numbers.numericalInput = function (event) {
            // Allow: backspace, delete, tab and escape
            if (event.keyCode == 46 || event.keyCode == 8 || event.keyCode == 9 || event.keyCode == 27 ||
                // Allow: Ctrl+A
                (event.keyCode == 65 && event.ctrlKey === true) ||
                // Allow: home, end, left, right
                (event.keyCode >= 35 && event.keyCode <= 39)) {
                // let it happen, don't do anything
                return true;
            }
            else {
                // Ensure that it is a number and stop the keypress
                if (event.shiftKey || (event.keyCode < 48 || event.keyCode > 57) && (event.keyCode < 96 || event.keyCode > 105)) {
                    event.preventDefault();
                    return false;
                }
                return true;
            }
        };
        return Numbers;
    }());
    Utils.Numbers = Numbers;
    var Objects = /** @class */ (function () {
        function Objects() {
        }
        Objects.toPlainObject = function (value) {
            value = Object(value);
            var result = {};
            for (var key in value) {
                result[key] = value[key];
            }
            return result;
        };
        return Objects;
    }());
    Utils.Objects = Objects;
    var Storage = /** @class */ (function () {
        function Storage() {
        }
        Storage.clear = function (storageType) {
            if (storageType === void 0) { storageType = StorageType.memory; }
            switch (storageType.value) {
                case StorageType.memory.value:
                    this._memoryStorage = {};
                    break;
                case StorageType.session.value:
                    sessionStorage.clear();
                    break;
                case StorageType.local.value:
                    localStorage.clear();
                    break;
            }
        };
        Storage.clearExpired = function (storageType) {
            if (storageType === void 0) { storageType = StorageType.memory; }
            var items = this.getItems(storageType);
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (this._isExpired(item)) {
                    this.remove(item.key);
                }
            }
        };
        Storage.get = function (key, storageType) {
            if (storageType === void 0) { storageType = StorageType.memory; }
            var data = null;
            switch (storageType.value) {
                case StorageType.memory.value:
                    data = this._memoryStorage[key];
                    break;
                case StorageType.session.value:
                    data = sessionStorage.getItem(key);
                    break;
                case StorageType.local.value:
                    data = localStorage.getItem(key);
                    break;
            }
            if (!data)
                return null;
            var item = null;
            try {
                item = JSON.parse(data);
            }
            catch (error) {
                return null;
            }
            if (!item)
                return null;
            if (this._isExpired(item))
                return null;
            // useful reference
            item.key = key;
            return item;
        };
        Storage._isExpired = function (item) {
            if (new Date().getTime() < item.expiresAt) {
                return false;
            }
            return true;
        };
        Storage.getItems = function (storageType) {
            if (storageType === void 0) { storageType = StorageType.memory; }
            var items = [];
            switch (storageType.value) {
                case StorageType.memory.value:
                    var keys = Object.keys(this._memoryStorage);
                    for (var i = 0; i < keys.length; i++) {
                        var item = this.get(keys[i], StorageType.memory);
                        if (item) {
                            items.push(item);
                        }
                    }
                    break;
                case StorageType.session.value:
                    for (var i = 0; i < sessionStorage.length; i++) {
                        var key = sessionStorage.key(i);
                        if (key) {
                            var item = this.get(key, StorageType.session);
                            if (item) {
                                items.push(item);
                            }
                        }
                    }
                    break;
                case StorageType.local.value:
                    for (var i = 0; i < localStorage.length; i++) {
                        var key = localStorage.key(i);
                        if (key) {
                            var item = this.get(key, StorageType.local);
                            if (item) {
                                items.push(item);
                            }
                        }
                    }
                    break;
            }
            return items;
        };
        Storage.remove = function (key, storageType) {
            if (storageType === void 0) { storageType = StorageType.memory; }
            switch (storageType.value) {
                case StorageType.memory.value:
                    delete this._memoryStorage[key];
                    break;
                case StorageType.session.value:
                    sessionStorage.removeItem(key);
                    break;
                case StorageType.local.value:
                    localStorage.removeItem(key);
                    break;
            }
        };
        Storage.set = function (key, value, expirationSecs, storageType) {
            if (storageType === void 0) { storageType = StorageType.memory; }
            var expirationMS = expirationSecs * 1000;
            var record = new StorageItem();
            record.value = value;
            record.expiresAt = new Date().getTime() + expirationMS;
            switch (storageType.value) {
                case StorageType.memory.value:
                    this._memoryStorage[key] = JSON.stringify(record);
                    break;
                case StorageType.session.value:
                    sessionStorage.setItem(key, JSON.stringify(record));
                    break;
                case StorageType.local.value:
                    localStorage.setItem(key, JSON.stringify(record));
                    break;
            }
            return record;
        };
        Storage._memoryStorage = {};
        return Storage;
    }());
    Utils.Storage = Storage;
    var StorageItem = /** @class */ (function () {
        function StorageItem() {
        }
        return StorageItem;
    }());
    Utils.StorageItem = StorageItem;
    var StorageType = /** @class */ (function () {
        function StorageType(value) {
            this.value = value;
        }
        StorageType.prototype.toString = function () {
            return this.value;
        };
        StorageType.memory = new StorageType("memory");
        StorageType.session = new StorageType("session");
        StorageType.local = new StorageType("local");
        return StorageType;
    }());
    Utils.StorageType = StorageType;
    var Strings = /** @class */ (function () {
        function Strings() {
        }
        Strings.ellipsis = function (text, chars) {
            if (text.length <= chars)
                return text;
            var trimmedText = text.substr(0, chars);
            var lastSpaceIndex = trimmedText.lastIndexOf(" ");
            if (lastSpaceIndex != -1) {
                trimmedText = trimmedText.substr(0, Math.min(trimmedText.length, lastSpaceIndex));
            }
            return trimmedText + "&hellip;";
        };
        Strings.htmlDecode = function (encoded) {
            var div = document.createElement('div');
            div.innerHTML = encoded;
            return div.firstChild.nodeValue;
        };
        Strings.format = function (str) {
            var values = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                values[_i - 1] = arguments[_i];
            }
            for (var i = 0; i < values.length; i++) {
                var reg = new RegExp("\\{" + i + "\\}", "gm");
                str = str.replace(reg, values[i]);
            }
            return str;
        };
        Strings.isAlphanumeric = function (str) {
            return /^[a-zA-Z0-9]*$/.test(str);
        };
        Strings.toCssClass = function (str) {
            return str.replace(/[^a-z0-9]/g, function (s) {
                var c = s.charCodeAt(0);
                if (c == 32)
                    return '-';
                if (c >= 65 && c <= 90)
                    return '_' + s.toLowerCase();
                return '__' + ('000' + c.toString(16)).slice(-4);
            });
        };
        Strings.toFileName = function (str) {
            return str.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        };
        Strings.utf8_to_b64 = function (str) {
            return window.btoa(unescape(encodeURIComponent(str)));
        };
        return Strings;
    }());
    Utils.Strings = Strings;
    var Urls = /** @class */ (function () {
        function Urls() {
        }
        Urls.getHashParameter = function (key, doc) {
            if (!doc)
                doc = window.document;
            if (doc && doc.location) {
                return this.getHashParameterFromString(key, doc.location.hash);
            }
            return null;
        };
        Urls.getHashParameterFromString = function (key, url) {
            var regex = new RegExp("#.*[?&]" + key + "=([^&]+)(&|$)");
            var match = regex.exec(url);
            return (match ? decodeURIComponent(match[1].replace(/\+/g, " ")) : null);
        };
        Urls.setHashParameter = function (key, value, doc) {
            if (!doc)
                doc = window.document;
            if (doc && doc.location) {
                var kvp = this.updateURIKeyValuePair(doc.location.hash.replace('#?', ''), key, value);
                var newHash = "#?" + kvp;
                var url = doc.URL;
                // remove hash value (if present).
                var index = url.indexOf('#');
                if (index != -1) {
                    url = url.substr(0, url.indexOf('#'));
                }
                doc.location.replace(url + newHash);
            }
        };
        Urls.getQuerystringParameter = function (key, w) {
            if (!w)
                w = window;
            return this.getQuerystringParameterFromString(key, w.location.search);
        };
        Urls.getQuerystringParameterFromString = function (key, querystring) {
            key = key.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
            var regex = new RegExp("[\\?&]" + key + "=([^&#]*)");
            var match = regex.exec(querystring);
            return (match ? decodeURIComponent(match[1].replace(/\+/g, " ")) : null);
        };
        Urls.setQuerystringParameter = function (key, value, doc) {
            if (!doc)
                doc = window.document;
            if (doc && doc.location) {
                var kvp = this.updateURIKeyValuePair(doc.location.hash.replace('#?', ''), key, value);
                // redirects.
                window.location.search = kvp;
            }
        };
        Urls.updateURIKeyValuePair = function (uriSegment, key, value) {
            key = encodeURIComponent(key);
            value = encodeURIComponent(value);
            var kvp = uriSegment.split('&');
            // Array.split() returns an array with a single "" item
            // if the target string is empty. remove if present.
            if (kvp[0] == "")
                kvp.shift();
            var i = kvp.length;
            var x;
            // replace if already present.
            while (i--) {
                x = kvp[i].split('=');
                if (x[0] == key) {
                    x[1] = value;
                    kvp[i] = x.join('=');
                    break;
                }
            }
            // not found, so append.
            if (i < 0) {
                kvp[kvp.length] = [key, value].join('=');
            }
            return kvp.join('&');
        };
        Urls.getUrlParts = function (url) {
            var a = document.createElement('a');
            a.href = url;
            return a;
        };
        Urls.convertToRelativeUrl = function (url) {
            var parts = this.getUrlParts(url);
            var relUri = parts.pathname + parts.searchWithin;
            if (!relUri.startsWith("/")) {
                relUri = "/" + relUri;
            }
            return relUri;
        };
        return Urls;
    }());
    Utils.Urls = Urls;
})(Utils || (Utils = {}));
window.Utils = Utils;

define("lib/Utils.js", function(){});

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var FilterCSS=require("cssfilter").FilterCSS;var getDefaultCSSWhiteList=require("cssfilter").getDefaultWhiteList;var _=require("./util");function getDefaultWhiteList(){return{a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","loop","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],sup:[],strong:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","loop","preload","src","height","width"]}}var defaultCSSFilter=new FilterCSS;function onTag(tag,html,options){}function onIgnoreTag(tag,html,options){}function onTagAttr(tag,name,value){}function onIgnoreTagAttr(tag,name,value){}function escapeHtml(html){return html.replace(REGEXP_LT,"&lt;").replace(REGEXP_GT,"&gt;")}function safeAttrValue(tag,name,value,cssFilter){value=friendlyAttrValue(value);if(name==="href"||name==="src"){value=_.trim(value);if(value==="#")return"#";if(!(value.substr(0,7)==="http://"||value.substr(0,8)==="https://"||value.substr(0,7)==="mailto:"||value.substr(0,4)==="tel:"||value[0]==="#"||value[0]==="/")){return""}}else if(name==="background"){REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex=0;if(REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)){return""}}else if(name==="style"){REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex=0;if(REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)){return""}REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex=0;if(REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)){REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex=0;if(REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)){return""}}if(cssFilter!==false){cssFilter=cssFilter||defaultCSSFilter;value=cssFilter.process(value)}}value=escapeAttrValue(value);return value}var REGEXP_LT=/</g;var REGEXP_GT=/>/g;var REGEXP_QUOTE=/"/g;var REGEXP_QUOTE_2=/&quot;/g;var REGEXP_ATTR_VALUE_1=/&#([a-zA-Z0-9]*);?/gim;var REGEXP_ATTR_VALUE_COLON=/&colon;?/gim;var REGEXP_ATTR_VALUE_NEWLINE=/&newline;?/gim;var REGEXP_DEFAULT_ON_TAG_ATTR_3=/\/\*|\*\//gm;var REGEXP_DEFAULT_ON_TAG_ATTR_4=/((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi;var REGEXP_DEFAULT_ON_TAG_ATTR_5=/^[\s"'`]*(d\s*a\s*t\s*a\s*)\:/gi;var REGEXP_DEFAULT_ON_TAG_ATTR_6=/^[\s"'`]*(d\s*a\s*t\s*a\s*)\:\s*image\//gi;var REGEXP_DEFAULT_ON_TAG_ATTR_7=/e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;var REGEXP_DEFAULT_ON_TAG_ATTR_8=/u\s*r\s*l\s*\(.*/gi;function escapeQuote(str){return str.replace(REGEXP_QUOTE,"&quot;")}function unescapeQuote(str){return str.replace(REGEXP_QUOTE_2,'"')}function escapeHtmlEntities(str){return str.replace(REGEXP_ATTR_VALUE_1,function replaceUnicode(str,code){return code[0]==="x"||code[0]==="X"?String.fromCharCode(parseInt(code.substr(1),16)):String.fromCharCode(parseInt(code,10))})}function escapeDangerHtml5Entities(str){return str.replace(REGEXP_ATTR_VALUE_COLON,":").replace(REGEXP_ATTR_VALUE_NEWLINE," ")}function clearNonPrintableCharacter(str){var str2="";for(var i=0,len=str.length;i<len;i++){str2+=str.charCodeAt(i)<32?" ":str.charAt(i)}return _.trim(str2)}function friendlyAttrValue(str){str=unescapeQuote(str);str=escapeHtmlEntities(str);str=escapeDangerHtml5Entities(str);str=clearNonPrintableCharacter(str);return str}function escapeAttrValue(str){str=escapeQuote(str);str=escapeHtml(str);return str}function onIgnoreTagStripAll(){return""}function StripTagBody(tags,next){if(typeof next!=="function"){next=function(){}}var isRemoveAllTag=!Array.isArray(tags);function isRemoveTag(tag){if(isRemoveAllTag)return true;return _.indexOf(tags,tag)!==-1}var removeList=[];var posStart=false;return{onIgnoreTag:function(tag,html,options){if(isRemoveTag(tag)){if(options.isClosing){var ret="[/removed]";var end=options.position+ret.length;removeList.push([posStart!==false?posStart:options.position,end]);posStart=false;return ret}else{if(!posStart){posStart=options.position}return"[removed]"}}else{return next(tag,html,options)}},remove:function(html){var rethtml="";var lastPos=0;_.forEach(removeList,function(pos){rethtml+=html.slice(lastPos,pos[0]);lastPos=pos[1]});rethtml+=html.slice(lastPos);return rethtml}}}function stripCommentTag(html){return html.replace(STRIP_COMMENT_TAG_REGEXP,"")}var STRIP_COMMENT_TAG_REGEXP=/<!--[\s\S]*?-->/g;function stripBlankChar(html){var chars=html.split("");chars=chars.filter(function(char){var c=char.charCodeAt(0);if(c===127)return false;if(c<=31){if(c===10||c===13)return true;return false}return true});return chars.join("")}exports.whiteList=getDefaultWhiteList();exports.getDefaultWhiteList=getDefaultWhiteList;exports.onTag=onTag;exports.onIgnoreTag=onIgnoreTag;exports.onTagAttr=onTagAttr;exports.onIgnoreTagAttr=onIgnoreTagAttr;exports.safeAttrValue=safeAttrValue;exports.escapeHtml=escapeHtml;exports.escapeQuote=escapeQuote;exports.unescapeQuote=unescapeQuote;exports.escapeHtmlEntities=escapeHtmlEntities;exports.escapeDangerHtml5Entities=escapeDangerHtml5Entities;exports.clearNonPrintableCharacter=clearNonPrintableCharacter;exports.friendlyAttrValue=friendlyAttrValue;exports.escapeAttrValue=escapeAttrValue;exports.onIgnoreTagStripAll=onIgnoreTagStripAll;exports.StripTagBody=StripTagBody;exports.stripCommentTag=stripCommentTag;exports.stripBlankChar=stripBlankChar;exports.cssFilter=defaultCSSFilter;exports.getDefaultCSSWhiteList=getDefaultCSSWhiteList},{"./util":4,cssfilter:8}],2:[function(require,module,exports){var DEFAULT=require("./default");var parser=require("./parser");var FilterXSS=require("./xss");function filterXSS(html,options){var xss=new FilterXSS(options);return xss.process(html)}exports=module.exports=filterXSS;exports.FilterXSS=FilterXSS;for(var i in DEFAULT)exports[i]=DEFAULT[i];for(var i in parser)exports[i]=parser[i];if(typeof window!=="undefined"){window.filterXSS=module.exports}function isWorkerEnv(){return typeof self!=="undefined"&&typeof DedicatedWorkerGlobalScope!=="undefined"&&self instanceof DedicatedWorkerGlobalScope}if(isWorkerEnv()){self.filterXSS=module.exports}},{"./default":1,"./parser":3,"./xss":5}],3:[function(require,module,exports){var _=require("./util");function getTagName(html){var i=_.spaceIndex(html);if(i===-1){var tagName=html.slice(1,-1)}else{var tagName=html.slice(1,i+1)}tagName=_.trim(tagName).toLowerCase();if(tagName.slice(0,1)==="/")tagName=tagName.slice(1);if(tagName.slice(-1)==="/")tagName=tagName.slice(0,-1);return tagName}function isClosing(html){return html.slice(0,2)==="</"}function parseTag(html,onTag,escapeHtml){"user strict";var rethtml="";var lastPos=0;var tagStart=false;var quoteStart=false;var currentPos=0;var len=html.length;var currentTagName="";var currentHtml="";for(currentPos=0;currentPos<len;currentPos++){var c=html.charAt(currentPos);if(tagStart===false){if(c==="<"){tagStart=currentPos;continue}}else{if(quoteStart===false){if(c==="<"){rethtml+=escapeHtml(html.slice(lastPos,currentPos));tagStart=currentPos;lastPos=currentPos;continue}if(c===">"){rethtml+=escapeHtml(html.slice(lastPos,tagStart));currentHtml=html.slice(tagStart,currentPos+1);currentTagName=getTagName(currentHtml);rethtml+=onTag(tagStart,rethtml.length,currentTagName,currentHtml,isClosing(currentHtml));lastPos=currentPos+1;tagStart=false;continue}if((c==='"'||c==="'")&&html.charAt(currentPos-1)==="="){quoteStart=c;continue}}else{if(c===quoteStart){quoteStart=false;continue}}}}if(lastPos<html.length){rethtml+=escapeHtml(html.substr(lastPos))}return rethtml}var REGEXP_ILLEGAL_ATTR_NAME=/[^a-zA-Z0-9_:\.\-]/gim;function parseAttr(html,onAttr){"user strict";var lastPos=0;var retAttrs=[];var tmpName=false;var len=html.length;function addAttr(name,value){name=_.trim(name);name=name.replace(REGEXP_ILLEGAL_ATTR_NAME,"").toLowerCase();if(name.length<1)return;var ret=onAttr(name,value||"");if(ret)retAttrs.push(ret)}for(var i=0;i<len;i++){var c=html.charAt(i);var v,j;if(tmpName===false&&c==="="){tmpName=html.slice(lastPos,i);lastPos=i+1;continue}if(tmpName!==false){if(i===lastPos&&(c==='"'||c==="'")&&html.charAt(i-1)==="="){j=html.indexOf(c,i+1);if(j===-1){break}else{v=_.trim(html.slice(lastPos+1,j));addAttr(tmpName,v);tmpName=false;i=j;lastPos=i+1;continue}}}if(/\s|\n|\t/.test(c)){html=html.replace(/\s|\n|\t/g," ");if(tmpName===false){j=findNextEqual(html,i);if(j===-1){v=_.trim(html.slice(lastPos,i));addAttr(v);tmpName=false;lastPos=i+1;continue}else{i=j-1;continue}}else{j=findBeforeEqual(html,i-1);if(j===-1){v=_.trim(html.slice(lastPos,i));v=stripQuoteWrap(v);addAttr(tmpName,v);tmpName=false;lastPos=i+1;continue}else{continue}}}}if(lastPos<html.length){if(tmpName===false){addAttr(html.slice(lastPos))}else{addAttr(tmpName,stripQuoteWrap(_.trim(html.slice(lastPos))))}}return _.trim(retAttrs.join(" "))}function findNextEqual(str,i){for(;i<str.length;i++){var c=str[i];if(c===" ")continue;if(c==="=")return i;return-1}}function findBeforeEqual(str,i){for(;i>0;i--){var c=str[i];if(c===" ")continue;if(c==="=")return i;return-1}}function isQuoteWrapString(text){if(text[0]==='"'&&text[text.length-1]==='"'||text[0]==="'"&&text[text.length-1]==="'"){return true}else{return false}}function stripQuoteWrap(text){if(isQuoteWrapString(text)){return text.substr(1,text.length-2)}else{return text}}exports.parseTag=parseTag;exports.parseAttr=parseAttr},{"./util":4}],4:[function(require,module,exports){module.exports={indexOf:function(arr,item){var i,j;if(Array.prototype.indexOf){return arr.indexOf(item)}for(i=0,j=arr.length;i<j;i++){if(arr[i]===item){return i}}return-1},forEach:function(arr,fn,scope){var i,j;if(Array.prototype.forEach){return arr.forEach(fn,scope)}for(i=0,j=arr.length;i<j;i++){fn.call(scope,arr[i],i,arr)}},trim:function(str){if(String.prototype.trim){return str.trim()}return str.replace(/(^\s*)|(\s*$)/g,"")},spaceIndex:function(str){var reg=/\s|\n|\t/;var match=reg.exec(str);return match?match.index:-1}}},{}],5:[function(require,module,exports){var FilterCSS=require("cssfilter").FilterCSS;var DEFAULT=require("./default");var parser=require("./parser");var parseTag=parser.parseTag;var parseAttr=parser.parseAttr;var _=require("./util");function isNull(obj){return obj===undefined||obj===null}function getAttrs(html){var i=_.spaceIndex(html);if(i===-1){return{html:"",closing:html[html.length-2]==="/"}}html=_.trim(html.slice(i+1,-1));var isClosing=html[html.length-1]==="/";if(isClosing)html=_.trim(html.slice(0,-1));return{html:html,closing:isClosing}}function shallowCopyObject(obj){var ret={};for(var i in obj){ret[i]=obj[i]}return ret}function FilterXSS(options){options=shallowCopyObject(options||{});if(options.stripIgnoreTag){if(options.onIgnoreTag){console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time')}options.onIgnoreTag=DEFAULT.onIgnoreTagStripAll}options.whiteList=options.whiteList||DEFAULT.whiteList;options.onTag=options.onTag||DEFAULT.onTag;options.onTagAttr=options.onTagAttr||DEFAULT.onTagAttr;options.onIgnoreTag=options.onIgnoreTag||DEFAULT.onIgnoreTag;options.onIgnoreTagAttr=options.onIgnoreTagAttr||DEFAULT.onIgnoreTagAttr;options.safeAttrValue=options.safeAttrValue||DEFAULT.safeAttrValue;options.escapeHtml=options.escapeHtml||DEFAULT.escapeHtml;this.options=options;if(options.css===false){this.cssFilter=false}else{options.css=options.css||{};this.cssFilter=new FilterCSS(options.css)}}FilterXSS.prototype.process=function(html){html=html||"";html=html.toString();if(!html)return"";var me=this;var options=me.options;var whiteList=options.whiteList;var onTag=options.onTag;var onIgnoreTag=options.onIgnoreTag;var onTagAttr=options.onTagAttr;var onIgnoreTagAttr=options.onIgnoreTagAttr;var safeAttrValue=options.safeAttrValue;var escapeHtml=options.escapeHtml;var cssFilter=me.cssFilter;if(options.stripBlankChar){html=DEFAULT.stripBlankChar(html)}if(!options.allowCommentTag){html=DEFAULT.stripCommentTag(html)}var stripIgnoreTagBody=false;if(options.stripIgnoreTagBody){var stripIgnoreTagBody=DEFAULT.StripTagBody(options.stripIgnoreTagBody,onIgnoreTag);onIgnoreTag=stripIgnoreTagBody.onIgnoreTag}var retHtml=parseTag(html,function(sourcePosition,position,tag,html,isClosing){var info={sourcePosition:sourcePosition,position:position,isClosing:isClosing,isWhite:whiteList.hasOwnProperty(tag)};var ret=onTag(tag,html,info);if(!isNull(ret))return ret;if(info.isWhite){if(info.isClosing){return"</"+tag+">"}var attrs=getAttrs(html);var whiteAttrList=whiteList[tag];var attrsHtml=parseAttr(attrs.html,function(name,value){var isWhiteAttr=_.indexOf(whiteAttrList,name)!==-1;var ret=onTagAttr(tag,name,value,isWhiteAttr);if(!isNull(ret))return ret;if(isWhiteAttr){value=safeAttrValue(tag,name,value,cssFilter);if(value){return name+'="'+value+'"'}else{return name}}else{var ret=onIgnoreTagAttr(tag,name,value,isWhiteAttr);if(!isNull(ret))return ret;return}});var html="<"+tag;if(attrsHtml)html+=" "+attrsHtml;if(attrs.closing)html+=" /";html+=">";return html}else{var ret=onIgnoreTag(tag,html,info);if(!isNull(ret))return ret;return escapeHtml(html)}},escapeHtml);if(stripIgnoreTagBody){retHtml=stripIgnoreTagBody.remove(retHtml)}return retHtml};module.exports=FilterXSS},{"./default":1,"./parser":3,"./util":4,cssfilter:8}],6:[function(require,module,exports){var DEFAULT=require("./default");var parseStyle=require("./parser");var _=require("./util");function isNull(obj){return obj===undefined||obj===null}function shallowCopyObject(obj){var ret={};for(var i in obj){ret[i]=obj[i]}return ret}function FilterCSS(options){options=shallowCopyObject(options||{});options.whiteList=options.whiteList||DEFAULT.whiteList;options.onAttr=options.onAttr||DEFAULT.onAttr;options.onIgnoreAttr=options.onIgnoreAttr||DEFAULT.onIgnoreAttr;options.safeAttrValue=options.safeAttrValue||DEFAULT.safeAttrValue;this.options=options}FilterCSS.prototype.process=function(css){css=css||"";css=css.toString();if(!css)return"";var me=this;var options=me.options;var whiteList=options.whiteList;var onAttr=options.onAttr;var onIgnoreAttr=options.onIgnoreAttr;var safeAttrValue=options.safeAttrValue;var retCSS=parseStyle(css,function(sourcePosition,position,name,value,source){var check=whiteList[name];var isWhite=false;if(check===true)isWhite=check;else if(typeof check==="function")isWhite=check(value);else if(check instanceof RegExp)isWhite=check.test(value);if(isWhite!==true)isWhite=false;value=safeAttrValue(name,value);if(!value)return;var opts={position:position,sourcePosition:sourcePosition,source:source,isWhite:isWhite};if(isWhite){var ret=onAttr(name,value,opts);if(isNull(ret)){return name+":"+value}else{return ret}}else{var ret=onIgnoreAttr(name,value,opts);if(!isNull(ret)){return ret}}});return retCSS};module.exports=FilterCSS},{"./default":7,"./parser":9,"./util":10}],7:[function(require,module,exports){function getDefaultWhiteList(){var whiteList={};whiteList["align-content"]=false;whiteList["align-items"]=false;whiteList["align-self"]=false;whiteList["alignment-adjust"]=false;whiteList["alignment-baseline"]=false;whiteList["all"]=false;whiteList["anchor-point"]=false;whiteList["animation"]=false;whiteList["animation-delay"]=false;whiteList["animation-direction"]=false;whiteList["animation-duration"]=false;whiteList["animation-fill-mode"]=false;whiteList["animation-iteration-count"]=false;whiteList["animation-name"]=false;whiteList["animation-play-state"]=false;whiteList["animation-timing-function"]=false;whiteList["azimuth"]=false;whiteList["backface-visibility"]=false;whiteList["background"]=true;whiteList["background-attachment"]=true;whiteList["background-clip"]=true;whiteList["background-color"]=true;whiteList["background-image"]=true;whiteList["background-origin"]=true;whiteList["background-position"]=true;whiteList["background-repeat"]=true;whiteList["background-size"]=true;whiteList["baseline-shift"]=false;whiteList["binding"]=false;whiteList["bleed"]=false;whiteList["bookmark-label"]=false;whiteList["bookmark-level"]=false;whiteList["bookmark-state"]=false;whiteList["border"]=true;whiteList["border-bottom"]=true;whiteList["border-bottom-color"]=true;whiteList["border-bottom-left-radius"]=true;whiteList["border-bottom-right-radius"]=true;whiteList["border-bottom-style"]=true;whiteList["border-bottom-width"]=true;whiteList["border-collapse"]=true;whiteList["border-color"]=true;whiteList["border-image"]=true;whiteList["border-image-outset"]=true;whiteList["border-image-repeat"]=true;whiteList["border-image-slice"]=true;whiteList["border-image-source"]=true;whiteList["border-image-width"]=true;whiteList["border-left"]=true;whiteList["border-left-color"]=true;whiteList["border-left-style"]=true;whiteList["border-left-width"]=true;whiteList["border-radius"]=true;whiteList["border-right"]=true;whiteList["border-right-color"]=true;whiteList["border-right-style"]=true;whiteList["border-right-width"]=true;whiteList["border-spacing"]=true;whiteList["border-style"]=true;whiteList["border-top"]=true;whiteList["border-top-color"]=true;whiteList["border-top-left-radius"]=true;whiteList["border-top-right-radius"]=true;whiteList["border-top-style"]=true;whiteList["border-top-width"]=true;whiteList["border-width"]=true;whiteList["bottom"]=false;whiteList["box-decoration-break"]=true;whiteList["box-shadow"]=true;whiteList["box-sizing"]=true;whiteList["box-snap"]=true;whiteList["box-suppress"]=true;whiteList["break-after"]=true;whiteList["break-before"]=true;whiteList["break-inside"]=true;whiteList["caption-side"]=false;whiteList["chains"]=false;whiteList["clear"]=true;whiteList["clip"]=false;whiteList["clip-path"]=false;whiteList["clip-rule"]=false;whiteList["color"]=true;whiteList["color-interpolation-filters"]=true;whiteList["column-count"]=false;whiteList["column-fill"]=false;whiteList["column-gap"]=false;whiteList["column-rule"]=false;whiteList["column-rule-color"]=false;whiteList["column-rule-style"]=false;whiteList["column-rule-width"]=false;whiteList["column-span"]=false;whiteList["column-width"]=false;whiteList["columns"]=false;whiteList["contain"]=false;whiteList["content"]=false;whiteList["counter-increment"]=false;whiteList["counter-reset"]=false;whiteList["counter-set"]=false;whiteList["crop"]=false;whiteList["cue"]=false;whiteList["cue-after"]=false;whiteList["cue-before"]=false;whiteList["cursor"]=false;whiteList["direction"]=false;whiteList["display"]=true;whiteList["display-inside"]=true;whiteList["display-list"]=true;whiteList["display-outside"]=true;whiteList["dominant-baseline"]=false;whiteList["elevation"]=false;whiteList["empty-cells"]=false;whiteList["filter"]=false;whiteList["flex"]=false;whiteList["flex-basis"]=false;whiteList["flex-direction"]=false;whiteList["flex-flow"]=false;whiteList["flex-grow"]=false;whiteList["flex-shrink"]=false;whiteList["flex-wrap"]=false;whiteList["float"]=false;whiteList["float-offset"]=false;whiteList["flood-color"]=false;whiteList["flood-opacity"]=false;whiteList["flow-from"]=false;whiteList["flow-into"]=false;whiteList["font"]=true;whiteList["font-family"]=true;whiteList["font-feature-settings"]=true;whiteList["font-kerning"]=true;whiteList["font-language-override"]=true;whiteList["font-size"]=true;whiteList["font-size-adjust"]=true;whiteList["font-stretch"]=true;whiteList["font-style"]=true;whiteList["font-synthesis"]=true;whiteList["font-variant"]=true;whiteList["font-variant-alternates"]=true;whiteList["font-variant-caps"]=true;whiteList["font-variant-east-asian"]=true;whiteList["font-variant-ligatures"]=true;whiteList["font-variant-numeric"]=true;whiteList["font-variant-position"]=true;whiteList["font-weight"]=true;whiteList["grid"]=false;whiteList["grid-area"]=false;whiteList["grid-auto-columns"]=false;whiteList["grid-auto-flow"]=false;whiteList["grid-auto-rows"]=false;whiteList["grid-column"]=false;whiteList["grid-column-end"]=false;whiteList["grid-column-start"]=false;whiteList["grid-row"]=false;whiteList["grid-row-end"]=false;whiteList["grid-row-start"]=false;whiteList["grid-template"]=false;whiteList["grid-template-areas"]=false;whiteList["grid-template-columns"]=false;whiteList["grid-template-rows"]=false;whiteList["hanging-punctuation"]=false;whiteList["height"]=true;whiteList["hyphens"]=false;whiteList["icon"]=false;whiteList["image-orientation"]=false;whiteList["image-resolution"]=false;whiteList["ime-mode"]=false;whiteList["initial-letters"]=false;whiteList["inline-box-align"]=false;whiteList["justify-content"]=false;whiteList["justify-items"]=false;whiteList["justify-self"]=false;whiteList["left"]=false;whiteList["letter-spacing"]=true;whiteList["lighting-color"]=true;whiteList["line-box-contain"]=false;whiteList["line-break"]=false;whiteList["line-grid"]=false;whiteList["line-height"]=false;whiteList["line-snap"]=false;whiteList["line-stacking"]=false;whiteList["line-stacking-ruby"]=false;whiteList["line-stacking-shift"]=false;whiteList["line-stacking-strategy"]=false;whiteList["list-style"]=true;whiteList["list-style-image"]=true;whiteList["list-style-position"]=true;whiteList["list-style-type"]=true;whiteList["margin"]=true;whiteList["margin-bottom"]=true;whiteList["margin-left"]=true;whiteList["margin-right"]=true;whiteList["margin-top"]=true;whiteList["marker-offset"]=false;whiteList["marker-side"]=false;whiteList["marks"]=false;whiteList["mask"]=false;whiteList["mask-box"]=false;whiteList["mask-box-outset"]=false;whiteList["mask-box-repeat"]=false;whiteList["mask-box-slice"]=false;whiteList["mask-box-source"]=false;whiteList["mask-box-width"]=false;whiteList["mask-clip"]=false;whiteList["mask-image"]=false;whiteList["mask-origin"]=false;whiteList["mask-position"]=false;whiteList["mask-repeat"]=false;whiteList["mask-size"]=false;whiteList["mask-source-type"]=false;whiteList["mask-type"]=false;whiteList["max-height"]=true;whiteList["max-lines"]=false;whiteList["max-width"]=true;whiteList["min-height"]=true;whiteList["min-width"]=true;whiteList["move-to"]=false;whiteList["nav-down"]=false;whiteList["nav-index"]=false;whiteList["nav-left"]=false;whiteList["nav-right"]=false;whiteList["nav-up"]=false;whiteList["object-fit"]=false;whiteList["object-position"]=false;whiteList["opacity"]=false;whiteList["order"]=false;whiteList["orphans"]=false;whiteList["outline"]=false;whiteList["outline-color"]=false;whiteList["outline-offset"]=false;whiteList["outline-style"]=false;whiteList["outline-width"]=false;whiteList["overflow"]=false;whiteList["overflow-wrap"]=false;whiteList["overflow-x"]=false;whiteList["overflow-y"]=false;whiteList["padding"]=true;whiteList["padding-bottom"]=true;whiteList["padding-left"]=true;whiteList["padding-right"]=true;whiteList["padding-top"]=true;whiteList["page"]=false;whiteList["page-break-after"]=false;whiteList["page-break-before"]=false;whiteList["page-break-inside"]=false;whiteList["page-policy"]=false;whiteList["pause"]=false;whiteList["pause-after"]=false;whiteList["pause-before"]=false;whiteList["perspective"]=false;whiteList["perspective-origin"]=false;whiteList["pitch"]=false;whiteList["pitch-range"]=false;whiteList["play-during"]=false;whiteList["position"]=false;whiteList["presentation-level"]=false;whiteList["quotes"]=false;whiteList["region-fragment"]=false;whiteList["resize"]=false;whiteList["rest"]=false;whiteList["rest-after"]=false;whiteList["rest-before"]=false;whiteList["richness"]=false;whiteList["right"]=false;whiteList["rotation"]=false;whiteList["rotation-point"]=false;whiteList["ruby-align"]=false;whiteList["ruby-merge"]=false;whiteList["ruby-position"]=false;whiteList["shape-image-threshold"]=false;whiteList["shape-outside"]=false;whiteList["shape-margin"]=false;whiteList["size"]=false;whiteList["speak"]=false;whiteList["speak-as"]=false;whiteList["speak-header"]=false;whiteList["speak-numeral"]=false;whiteList["speak-punctuation"]=false;whiteList["speech-rate"]=false;whiteList["stress"]=false;whiteList["string-set"]=false;whiteList["tab-size"]=false;whiteList["table-layout"]=false;whiteList["text-align"]=true;whiteList["text-align-last"]=true;whiteList["text-combine-upright"]=true;whiteList["text-decoration"]=true;whiteList["text-decoration-color"]=true;whiteList["text-decoration-line"]=true;whiteList["text-decoration-skip"]=true;whiteList["text-decoration-style"]=true;whiteList["text-emphasis"]=true;whiteList["text-emphasis-color"]=true;whiteList["text-emphasis-position"]=true;whiteList["text-emphasis-style"]=true;whiteList["text-height"]=true;whiteList["text-indent"]=true;whiteList["text-justify"]=true;whiteList["text-orientation"]=true;whiteList["text-overflow"]=true;whiteList["text-shadow"]=true;whiteList["text-space-collapse"]=true;whiteList["text-transform"]=true;whiteList["text-underline-position"]=true;whiteList["text-wrap"]=true;whiteList["top"]=false;whiteList["transform"]=false;whiteList["transform-origin"]=false;whiteList["transform-style"]=false;whiteList["transition"]=false;whiteList["transition-delay"]=false;whiteList["transition-duration"]=false;whiteList["transition-property"]=false;whiteList["transition-timing-function"]=false;whiteList["unicode-bidi"]=false;whiteList["vertical-align"]=false;whiteList["visibility"]=false;whiteList["voice-balance"]=false;whiteList["voice-duration"]=false;whiteList["voice-family"]=false;whiteList["voice-pitch"]=false;whiteList["voice-range"]=false;whiteList["voice-rate"]=false;whiteList["voice-stress"]=false;whiteList["voice-volume"]=false;whiteList["volume"]=false;whiteList["white-space"]=false;whiteList["widows"]=false;whiteList["width"]=true;whiteList["will-change"]=false;whiteList["word-break"]=true;whiteList["word-spacing"]=true;whiteList["word-wrap"]=true;whiteList["wrap-flow"]=false;whiteList["wrap-through"]=false;whiteList["writing-mode"]=false;whiteList["z-index"]=false;return whiteList}function onAttr(name,value,options){}function onIgnoreAttr(name,value,options){}var REGEXP_URL_JAVASCRIPT=/javascript\s*\:/gim;function safeAttrValue(name,value){if(REGEXP_URL_JAVASCRIPT.test(value))return"";return value}exports.whiteList=getDefaultWhiteList();exports.getDefaultWhiteList=getDefaultWhiteList;exports.onAttr=onAttr;exports.onIgnoreAttr=onIgnoreAttr;exports.safeAttrValue=safeAttrValue},{}],8:[function(require,module,exports){var DEFAULT=require("./default");var FilterCSS=require("./css");function filterCSS(html,options){var xss=new FilterCSS(options);return xss.process(html)}exports=module.exports=filterCSS;exports.FilterCSS=FilterCSS;for(var i in DEFAULT)exports[i]=DEFAULT[i];if(typeof window!=="undefined"){window.filterCSS=module.exports}},{"./css":6,"./default":7}],9:[function(require,module,exports){var _=require("./util");function parseStyle(css,onAttr){css=_.trimRight(css);if(css[css.length-1]!==";")css+=";";var cssLength=css.length;var isParenthesisOpen=false;var lastPos=0;var i=0;var retCSS="";function addNewAttr(){if(!isParenthesisOpen){var source=_.trim(css.slice(lastPos,i));var j=source.indexOf(":");if(j!==-1){var name=_.trim(source.slice(0,j));var value=_.trim(source.slice(j+1));if(name){var ret=onAttr(lastPos,retCSS.length,name,value,source);if(ret)retCSS+=ret+"; "}}}lastPos=i+1}for(;i<cssLength;i++){var c=css[i];if(c==="/"&&css[i+1]==="*"){var j=css.indexOf("*/",i+2);if(j===-1)break;i=j+1;lastPos=i+1;isParenthesisOpen=false}else if(c==="("){isParenthesisOpen=true}else if(c===")"){isParenthesisOpen=false}else if(c===";"){if(isParenthesisOpen){}else{addNewAttr()}}else if(c==="\n"){addNewAttr()}}return _.trim(retCSS)}module.exports=parseStyle},{"./util":10}],10:[function(require,module,exports){module.exports={indexOf:function(arr,item){var i,j;if(Array.prototype.indexOf){return arr.indexOf(item)}for(i=0,j=arr.length;i<j;i++){if(arr[i]===item){return i}}return-1},forEach:function(arr,fn,scope){var i,j;if(Array.prototype.forEach){return arr.forEach(fn,scope)}for(i=0,j=arr.length;i<j;i++){fn.call(scope,arr[i],i,arr)}},trim:function(str){if(String.prototype.trim){return str.trim()}return str.replace(/(^\s*)|(\s*$)/g,"")},trimRight:function(str){if(String.prototype.trimRight){return str.trimRight()}return str.replace(/(\s*$)/g,"")}}},{}]},{},[2]);
define("lib/xss.min.js", function(){});

define('UVDataProvider',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UVDataProvider = /** @class */ (function () {
        function UVDataProvider(readonly) {
            this.readonly = false;
            this.readonly = readonly;
        }
        UVDataProvider.prototype.get = function (key, defaultValue) {
            return null;
        };
        UVDataProvider.prototype.set = function (key, value) {
        };
        return UVDataProvider;
    }());
    exports.UVDataProvider = UVDataProvider;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('URLDataProvider',["require", "exports", "./UVDataProvider"], function (require, exports, UVDataProvider_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var URLDataProvider = /** @class */ (function (_super) {
        __extends(URLDataProvider, _super);
        function URLDataProvider(readonly) {
            return _super.call(this, readonly) || this;
        }
        URLDataProvider.prototype.get = function (key, defaultValue) {
            return Utils.Urls.getHashParameter(key, document) || defaultValue;
        };
        URLDataProvider.prototype.set = function (key, value) {
            if (!this.readonly) {
                if (value) {
                    Utils.Urls.setHashParameter(key, value.toString(), document);
                }
                else {
                    Utils.Urls.setHashParameter(key, '', document);
                }
            }
        };
        return URLDataProvider;
    }(UVDataProvider_1.UVDataProvider));
    exports.default = URLDataProvider;
});

define('modules/uv-shared-module/BaseEvents',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseEvents = /** @class */ (function () {
        function BaseEvents() {
        }
        BaseEvents.ACCEPT_TERMS = 'acceptTerms';
        BaseEvents.ANNOTATION_CANVAS_CHANGED = 'annotationCanvasChanged';
        BaseEvents.ANNOTATION_CHANGED = 'annotationChanged';
        BaseEvents.ANNOTATIONS_CLEARED = 'annotationsCleared';
        BaseEvents.ANNOTATIONS_EMPTY = 'annotationsEmpty';
        BaseEvents.ANNOTATIONS = 'annotations';
        BaseEvents.BOOKMARK = 'bookmark';
        BaseEvents.CANVAS_INDEX_CHANGE_FAILED = 'canvasIndexChangeFailed';
        BaseEvents.CANVAS_INDEX_CHANGED = 'canvasIndexChanged';
        BaseEvents.CLEAR_ANNOTATIONS = 'clearAnnotations';
        BaseEvents.CLICKTHROUGH = 'clickthrough';
        BaseEvents.CLOSE_ACTIVE_DIALOGUE = 'closeActiveDialogue';
        BaseEvents.CLOSE_LEFT_PANEL = 'closeLeftPanel';
        BaseEvents.CLOSE_RIGHT_PANEL = 'closeRightPanel';
        BaseEvents.COLLECTION_INDEX_CHANGED = 'collectionIndexChanged';
        BaseEvents.CREATE = 'create';
        BaseEvents.CREATED = 'created';
        BaseEvents.DOWN_ARROW = 'downArrow';
        BaseEvents.DOWNLOAD = 'download';
        BaseEvents.DROP = 'drop';
        BaseEvents.END = 'end';
        BaseEvents.ERROR = 'error';
        BaseEvents.ESCAPE = 'escape';
        BaseEvents.EXIT_FULLSCREEN = 'exitFullScreen';
        BaseEvents.EXTERNAL_LINK_CLICKED = 'externalLinkClicked';
        BaseEvents.FEEDBACK = 'feedback';
        BaseEvents.FIRST = 'first';
        BaseEvents.FORBIDDEN = 'forbidden';
        BaseEvents.GALLERY_DECREASE_SIZE = 'galleryDecreaseSize';
        BaseEvents.GALLERY_INCREASE_SIZE = 'galleryIncreaseSize';
        BaseEvents.GALLERY_THUMB_SELECTED = 'galleryThumbSelected';
        BaseEvents.HIDE_AUTH_DIALOGUE = 'hideAuthDialogue';
        BaseEvents.HIDE_CLICKTHROUGH_DIALOGUE = 'hideClickthroughDialogue';
        BaseEvents.HIDE_DOWNLOAD_DIALOGUE = 'hideDownloadDialogue';
        BaseEvents.HIDE_EMBED_DIALOGUE = 'hideEmbedDialogue';
        BaseEvents.HIDE_EXTERNALCONTENT_DIALOGUE = 'hideExternalContentDialogue';
        BaseEvents.HIDE_GENERIC_DIALOGUE = 'hideGenericDialogue';
        BaseEvents.HIDE_HELP_DIALOGUE = 'hideHelpDialogue';
        BaseEvents.HIDE_INFORMATION = 'hideInformation';
        BaseEvents.HIDE_LOGIN_DIALOGUE = 'hideLoginDialogue';
        BaseEvents.HIDE_MOREINFO_DIALOGUE = 'hideMoreInfoDialogue';
        BaseEvents.HIDE_MULTISELECT_DIALOGUE = 'hideMultiSelectDialogue';
        BaseEvents.HIDE_OVERLAY = 'hideOverlay';
        BaseEvents.HIDE_RESTRICTED_DIALOGUE = 'hideRestrictedDialogue';
        BaseEvents.HIDE_SETTINGS_DIALOGUE = 'hideSettingsDialogue';
        BaseEvents.HIDE_SHARE_DIALOGUE = 'hideShareDialogue';
        BaseEvents.HOME = 'home';
        BaseEvents.LAST = 'last';
        BaseEvents.LEFT_ARROW = 'leftArrow';
        BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH = 'leftPanelCollapseFullFinish';
        BaseEvents.LEFTPANEL_COLLAPSE_FULL_START = 'leftPanelCollapseFullStart';
        BaseEvents.LEFTPANEL_EXPAND_FULL_FINISH = 'leftPanelExpandFullFinish';
        BaseEvents.LEFTPANEL_EXPAND_FULL_START = 'leftPanelExpandFullStart';
        BaseEvents.LOAD_FAILED = 'loadFailed';
        BaseEvents.LOGIN_FAILED = 'loginFailed';
        BaseEvents.LOGIN = 'login';
        BaseEvents.LOGOUT = 'logout';
        BaseEvents.MANIFEST_INDEX_CHANGED = 'manifestIndexChanged';
        BaseEvents.METRIC_CHANGED = 'metricChanged';
        BaseEvents.MINUS = 'minus';
        BaseEvents.MULTISELECT_CHANGE = 'multiSelectChange';
        BaseEvents.MULTISELECTION_MADE = 'multiSelectionMade';
        BaseEvents.NEXT = 'next';
        BaseEvents.NOT_FOUND = 'notFound';
        BaseEvents.OPEN_EXTERNAL_RESOURCE = 'openExternalResource';
        BaseEvents.OPEN_LEFT_PANEL = 'openLeftPanel';
        BaseEvents.OPEN_RIGHT_PANEL = 'openRightPanel';
        BaseEvents.OPEN_THUMBS_VIEW = 'openThumbsView';
        BaseEvents.OPEN_TREE_VIEW = 'openTreeView';
        BaseEvents.OPEN = 'open';
        BaseEvents.PAGE_DOWN = 'pageDown';
        BaseEvents.PAGE_UP = 'pageUp';
        BaseEvents.PLUS = 'plus';
        BaseEvents.PREV = 'prev';
        BaseEvents.RANGE_CHANGED = 'rangeChanged';
        BaseEvents.REDIRECT = 'redirect';
        BaseEvents.REFRESH = 'refresh';
        BaseEvents.RELOAD = 'reload';
        BaseEvents.RESIZE = 'resize';
        BaseEvents.RESOURCE_DEGRADED = 'resourceDegraded';
        BaseEvents.RETRY = 'retry';
        BaseEvents.RETURN = 'return';
        BaseEvents.RIGHT_ARROW = 'rightArrow';
        BaseEvents.RIGHTPANEL_COLLAPSE_FULL_FINISH = 'rightPanelCollapseFullFinish';
        BaseEvents.RIGHTPANEL_COLLAPSE_FULL_START = 'rightPanelCollapseFullStart';
        BaseEvents.RIGHTPANEL_EXPAND_FULL_FINISH = 'rightPanelExpandFullFinish';
        BaseEvents.RIGHTPANEL_EXPAND_FULL_START = 'rightPanelExpandFullStart';
        BaseEvents.SEQUENCE_INDEX_CHANGED = 'sequenceIndexChanged';
        BaseEvents.SETTINGS_CHANGED = 'settingsChanged';
        BaseEvents.SHOW_AUTH_DIALOGUE = 'showAuthDialogue';
        BaseEvents.SHOW_CLICKTHROUGH_DIALOGUE = 'showClickThroughDialogue';
        BaseEvents.SHOW_DOWNLOAD_DIALOGUE = 'showDownloadDialogue';
        BaseEvents.SHOW_EMBED_DIALOGUE = 'showEmbedDialogue';
        BaseEvents.SHOW_EXTERNALCONTENT_DIALOGUE = 'showExternalContentDialogue';
        BaseEvents.SHOW_GENERIC_DIALOGUE = 'showGenericDialogue';
        BaseEvents.SHOW_HELP_DIALOGUE = 'showHelpDialogue';
        BaseEvents.SHOW_INFORMATION = 'showInformation';
        BaseEvents.SHOW_LOGIN_DIALOGUE = 'showLoginDialogue';
        BaseEvents.SHOW_MESSAGE = 'showMessage';
        BaseEvents.SHOW_MOREINFO_DIALOGUE = 'showMoreInfoDialogue';
        BaseEvents.SHOW_MULTISELECT_DIALOGUE = 'showMultiSelectDialogue';
        BaseEvents.SHOW_OVERLAY = 'showOverlay';
        BaseEvents.SHOW_RESTRICTED_DIALOGUE = 'showRestrictedDialogue';
        BaseEvents.SHOW_SETTINGS_DIALOGUE = 'showSettingsDialogue';
        BaseEvents.SHOW_SHARE_DIALOGUE = 'showShareDialogue';
        BaseEvents.SHOW_TERMS_OF_USE = 'showTermsOfUse';
        BaseEvents.THUMB_MULTISELECTED = 'thumbMultiSelected';
        BaseEvents.THUMB_SELECTED = 'thumbSelected';
        BaseEvents.TOGGLE_EXPAND_LEFT_PANEL = 'toggleExpandLeftPanel';
        BaseEvents.TOGGLE_EXPAND_RIGHT_PANEL = 'toggleExpandRightPanel';
        BaseEvents.TOGGLE_FULLSCREEN = 'toggleFullScreen';
        BaseEvents.TREE_NODE_MULTISELECTED = 'treeNodeMultiSelected';
        BaseEvents.TREE_NODE_SELECTED = 'treeNodeSelected';
        BaseEvents.UP_ARROW = 'upArrow';
        BaseEvents.UPDATE_SETTINGS = 'updateSettings';
        BaseEvents.VIEW_FULL_TERMS = 'viewFullTerms';
        BaseEvents.WINDOW_UNLOAD = 'windowUnload';
        return BaseEvents;
    }());
    exports.BaseEvents = BaseEvents;
});

define('modules/uv-shared-module/Panel',["require", "exports", "./BaseEvents"], function (require, exports, BaseEvents_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Panel = /** @class */ (function () {
        function Panel($element, fitToParentWidth, fitToParentHeight) {
            this.isResized = false;
            this.$element = $element;
            this.fitToParentWidth = fitToParentWidth || false;
            this.fitToParentHeight = fitToParentHeight || false;
            this.create();
        }
        Panel.prototype.create = function () {
            var _this = this;
            this.component.subscribe(BaseEvents_1.BaseEvents.RESIZE, function () {
                _this.resize();
            });
        };
        Panel.prototype.whenResized = function (cb) {
            var _this = this;
            Utils.Async.waitFor(function () {
                return _this.isResized;
            }, cb);
        };
        Panel.prototype.resize = function () {
            var $parent = this.$element.parent();
            if (this.fitToParentWidth) {
                this.$element.width($parent.width());
            }
            if (this.fitToParentHeight) {
                this.$element.height($parent.height());
            }
            this.isResized = true;
        };
        return Panel;
    }());
    exports.Panel = Panel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/BaseView',["require", "exports", "./Panel"], function (require, exports, Panel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseView = /** @class */ (function (_super) {
        __extends(BaseView, _super);
        function BaseView($element, fitToParentWidth, fitToParentHeight) {
            return _super.call(this, $element, fitToParentWidth, fitToParentHeight) || this;
        }
        BaseView.prototype.create = function () {
            this.component = this.$element.closest(".uv").data("component");
            _super.prototype.create.call(this);
            this.extension = this.component.extension;
            this.config = {};
            this.config.content = {};
            this.config.options = {};
            var that = this;
            // build config inheritance chain
            if (that.modules && that.modules.length) {
                that.modules = that.modules.reverse();
                that.modules.forEach(function (moduleName) {
                    that.config = $.extend(true, that.config, that.extension.data.config.modules[moduleName]);
                });
            }
            this.content = this.config.content;
            this.options = this.config.options;
        };
        BaseView.prototype.init = function () {
        };
        BaseView.prototype.setConfig = function (moduleName) {
            if (!this.modules) {
                this.modules = [];
            }
            this.modules.push(moduleName);
        };
        BaseView.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return BaseView;
    }(Panel_1.Panel));
    exports.BaseView = BaseView;
});

define('modules/uv-shared-module/Position',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Position;
    (function (Position) {
        Position[Position["TOP_LEFT"] = 0] = "TOP_LEFT";
        Position[Position["TOP_CENTER"] = 1] = "TOP_CENTER";
        Position[Position["TOP_RIGHT"] = 2] = "TOP_RIGHT";
        Position[Position["CENTER_LEFT"] = 3] = "CENTER_LEFT";
        Position[Position["CENTER"] = 4] = "CENTER";
        Position[Position["CENTER_RIGHT"] = 5] = "CENTER_RIGHT";
        Position[Position["BOTTOM_LEFT"] = 6] = "BOTTOM_LEFT";
        Position[Position["BOTTOM_CENTER"] = 7] = "BOTTOM_CENTER";
        Position[Position["BOTTOM_RIGHT"] = 8] = "BOTTOM_RIGHT";
    })(Position = exports.Position || (exports.Position = {}));
});

define('Utils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UVUtils = /** @class */ (function () {
        function UVUtils() {
        }
        UVUtils.sanitize = function (html) {
            return filterXSS(html, {
                whiteList: {
                    a: ["href", "title", "target", "class"],
                    b: [],
                    br: [],
                    i: [],
                    img: ["src", "alt"],
                    p: [],
                    small: [],
                    span: [],
                    strong: [],
                    sub: [],
                    sup: []
                }
            });
        };
        UVUtils.isValidUrl = function (value) {
            var a = document.createElement('a');
            a.href = value;
            return (!!a.host && a.host !== window.location.host);
        };
        UVUtils.propertiesChanged = function (newData, currentData, properties) {
            var propChanged = false;
            for (var i = 0; i < properties.length; i++) {
                propChanged = UVUtils.propertyChanged(newData, currentData, properties[i]);
                if (propChanged) {
                    break;
                }
            }
            return propChanged;
        };
        UVUtils.propertyChanged = function (newData, currentData, propertyName) {
            return currentData[propertyName] !== newData[propertyName];
        };
        return UVUtils;
    }());
    exports.UVUtils = UVUtils;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/CenterPanel',["require", "exports", "./BaseView", "./Position", "../../Utils"], function (require, exports, BaseView_1, Position_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CenterPanel = /** @class */ (function (_super) {
        __extends(CenterPanel, _super);
        function CenterPanel($element) {
            var _this = _super.call(this, $element, false, true) || this;
            _this.subtitleExpanded = false;
            _this.isAttributionOpen = false;
            _this.attributionPosition = Position_1.Position.BOTTOM_LEFT;
            return _this;
        }
        CenterPanel.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            this.$title = $('<div class="title"></div>');
            this.$element.append(this.$title);
            this.$subtitle = $("<div class=\"subtitle\">\n                                <div class=\"wrapper\">\n                                    <button type=\"button\" class=\"expand-btn\" aria-label=\"Expand\">\n                                        <span aria-hidden=\"true\">+</span>\n                                    </button>\n                                    <span class=\"text\"></span>\n                                </div>\n                            </div>");
            this.$element.append(this.$subtitle);
            this.$subtitleWrapper = this.$subtitle.find('.wrapper');
            this.$subtitleExpand = this.$subtitle.find('.expand-btn');
            this.$subtitleText = this.$subtitle.find('.text');
            this.$content = $('<div id="content" class="content"></div>');
            this.$element.append(this.$content);
            this.$attribution = $("\n                                <div class=\"attribution\">\n                                  <div class=\"header\">\n                                    <div class=\"title\"></div>\n                                    <button type=\"button\" class=\"close\" aria-label=\"Close\">\n                                      <span aria-hidden=\"true\">&times;</span>\n                                    </button>\n                                  </div>\n                                  <div class=\"main\">\n                                    <div class=\"attribution-text\"></div>\n                                    <div class=\"license\"></div>\n                                    <div class=\"logo\"></div>\n                                  </div>\n                                </div>\n        ");
            this.$attribution.find('.header .title').text(this.content.attribution);
            this.$content.append(this.$attribution);
            this.closeAttribution();
            this.$closeAttributionButton = this.$attribution.find('.header .close');
            this.$closeAttributionButton.on('click', function (e) {
                e.preventDefault();
                _this.closeAttribution();
            });
            this.$subtitleExpand.on('click', function (e) {
                e.preventDefault();
                _this.subtitleExpanded = !_this.subtitleExpanded;
                if (_this.subtitleExpanded) {
                    _this.$subtitleWrapper.addClass('expanded');
                    _this.$subtitleExpand.text('-');
                }
                else {
                    _this.$subtitleWrapper.removeClass('expanded');
                    _this.$subtitleExpand.text('+');
                }
                _this.resize();
            });
            if (Utils.Bools.getBool(this.options.titleEnabled, true)) {
                this.$title.removeClass('hidden');
            }
            else {
                this.$title.addClass('hidden');
            }
            if (Utils.Bools.getBool(this.options.subtitleEnabled, false)) {
                this.$subtitle.removeClass('hidden');
            }
            else {
                this.$subtitle.addClass('hidden');
            }
            this.whenResized(function () {
                _this.updateRequiredStatement();
            });
        };
        CenterPanel.prototype.openAttribution = function () {
            this.$attribution.show();
            this.isAttributionOpen = true;
        };
        CenterPanel.prototype.closeAttribution = function () {
            this.$attribution.hide();
            this.isAttributionOpen = false;
        };
        CenterPanel.prototype.updateRequiredStatement = function () {
            var _this = this;
            var requiredStatement = this.extension.helper.getRequiredStatement();
            //var license = this.provider.getLicense();
            //var logo = this.provider.getLogo();
            var enabled = Utils.Bools.getBool(this.options.requiredStatementEnabled, true);
            if (!requiredStatement || !requiredStatement.value || !enabled) {
                return;
            }
            this.openAttribution();
            var $attributionTitle = this.$attribution.find('.title');
            var $attributionText = this.$attribution.find('.attribution-text');
            var $license = this.$attribution.find('.license');
            var $logo = this.$attribution.find('.logo');
            if (requiredStatement.label) {
                var sanitizedTitle = Utils_1.UVUtils.sanitize(requiredStatement.label);
                $attributionTitle.html(sanitizedTitle);
            }
            else {
                $attributionTitle.text(this.content.attribution);
            }
            if (requiredStatement.value) {
                var sanitizedText = Utils_1.UVUtils.sanitize(requiredStatement.value);
                $attributionText.html(sanitizedText);
                $attributionText.find('img').one('load', function () {
                    _this.resize();
                }).each(function () {
                    if (this.complete)
                        $(this).load();
                });
                $attributionText.targetBlank();
            }
            // $attribution.toggleExpandText(this.options.trimAttributionCount, () => {
            //     this.resize();
            // });
            //if (license){
            //    $license.append('<a href="' + license + '">' + license + '</a>');
            //} else {
            $license.hide();
            //}
            //
            //if (logo){
            //    $logo.append('<img src="' + logo + '"/>');
            //} else {
            $logo.hide();
            //}
            this.resize();
        };
        CenterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            var leftPanelWidth = this.extension.shell.$leftPanel.is(':visible') ? Math.floor(this.extension.shell.$leftPanel.width()) : 0;
            var rightPanelWidth = this.extension.shell.$rightPanel.is(':visible') ? Math.floor(this.extension.shell.$rightPanel.width()) : 0;
            var width = Math.floor(this.$element.parent().width() - leftPanelWidth - rightPanelWidth);
            this.$element.css({
                'left': leftPanelWidth,
                'width': width
            });
            var titleHeight;
            var subtitleHeight;
            if (this.options && this.options.titleEnabled === false || !this.$title.is(':visible')) {
                titleHeight = 0;
            }
            else {
                titleHeight = this.$title.height();
            }
            if (this.options && this.options.subtitleEnabled === false || !this.$subtitle.is(':visible')) {
                subtitleHeight = 0;
            }
            else {
                subtitleHeight = this.$subtitle.height();
            }
            this.$content.height(this.$element.height() - titleHeight - subtitleHeight);
            this.$content.width(this.$element.width());
            if (this.$attribution && this.isAttributionOpen) {
                switch (this.attributionPosition) {
                    case Position_1.Position.BOTTOM_LEFT:
                        this.$attribution.css('top', this.$content.height() - this.$attribution.outerHeight() - this.$attribution.verticalMargins());
                        this.$attribution.css('left', 0);
                        break;
                    case Position_1.Position.BOTTOM_RIGHT:
                        this.$attribution.css('top', this.$content.height() - this.$attribution.outerHeight() - this.$attribution.verticalMargins());
                        this.$attribution.css('left', this.$content.width() - this.$attribution.outerWidth() - this.$attribution.horizontalMargins());
                        break;
                }
                // hide the attribution if there's no room for it
                if (this.$content.width() <= this.$attribution.width()) {
                    this.$attribution.hide();
                }
                else {
                    this.$attribution.show();
                }
            }
            if (this.subtitle && this.options.subtitleEnabled) {
                this.$subtitleText.html(Utils_1.UVUtils.sanitize(this.subtitle.replace(/<br\s*[\/]?>/gi, '; ')));
                this.$subtitleText.removeClass('elided');
                this.$subtitle.removeClass('hidden');
                this.$subtitleWrapper.css('max-height', this.$content.height() + this.$subtitle.outerHeight());
                this.$subtitleWrapper.width(this.$content.width());
                if (!this.subtitleExpanded) {
                    this.$subtitleText.width('auto');
                    this.$subtitleWrapper.width('auto');
                    this.$subtitleExpand.hide();
                    // if the subtitle span is wider than the container, set it to display:block
                    // and set its width to that of the container
                    // this will make it appear elided.
                    // show the expand button
                    if (this.$subtitleText.width() > this.$content.width()) {
                        this.$subtitleExpand.show();
                        this.$subtitleText.addClass('elided');
                        this.$subtitleText.width(this.$content.width() - (this.$subtitleExpand.outerWidth() + this.$subtitleText.horizontalMargins()));
                    }
                }
                else {
                    // subtitle expanded
                    this.$subtitleText.width(this.$content.width() - this.$subtitleText.horizontalMargins() - 2);
                }
            }
            else {
                this.$subtitle.addClass('hidden');
            }
        };
        return CenterPanel;
    }(BaseView_1.BaseView));
    exports.CenterPanel = CenterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-avcenterpanel-module/AVCenterPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/CenterPanel", "../uv-shared-module/Position", "../../Utils"], function (require, exports, BaseEvents_1, CenterPanel_1, Position_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AVCenterPanel = /** @class */ (function (_super) {
        __extends(AVCenterPanel, _super);
        function AVCenterPanel($element) {
            var _this = _super.call(this, $element) || this;
            _this._mediaReady = false;
            _this._isThumbsViewOpen = false;
            _this.attributionPosition = Position_1.Position.BOTTOM_RIGHT;
            return _this;
        }
        AVCenterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('avCenterPanel');
            _super.prototype.create.call(this);
            var that = this;
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, function (resources) {
                that.openMedia(resources);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this._viewCanvas(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RANGE_CHANGED, function (range) {
                if (!_this._observeRangeChanges()) {
                    return;
                }
                _this._whenMediaReady(function () {
                    that._viewRange(range);
                    that._setTitle();
                });
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.METRIC_CHANGED, function () {
                _this._whenMediaReady(function () {
                    if (_this.avcomponent) {
                        _this.avcomponent.set({
                            limitToRange: _this._limitToRange(),
                            constrainNavigationToRange: _this._limitToRange()
                        });
                    }
                });
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CREATED, function () {
                _this._setTitle();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_THUMBS_VIEW, function () {
                _this._isThumbsViewOpen = true;
                _this._whenMediaReady(function () {
                    if (_this.avcomponent) {
                        _this.avcomponent.set({
                            virtualCanvasEnabled: false
                        });
                        var canvas = _this.extension.helper.getCurrentCanvas();
                        if (canvas) {
                            _this._viewCanvas(_this.extension.helper.canvasIndex);
                        }
                    }
                });
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_TREE_VIEW, function () {
                _this._isThumbsViewOpen = false;
                _this._whenMediaReady(function () {
                    if (_this.avcomponent) {
                        _this.avcomponent.set({
                            virtualCanvasEnabled: true
                        });
                    }
                });
            });
            this._createAVComponent();
        };
        AVCenterPanel.prototype._createAVComponent = function () {
            var _this = this;
            this.$avcomponent = $('<div class="iiif-av-component"></div>');
            this.$content.prepend(this.$avcomponent);
            this.avcomponent = new IIIFComponents.AVComponent({
                target: this.$avcomponent[0],
                posterImageExpanded: this.options.posterImageExpanded
            });
            this.avcomponent.on('mediaready', function () {
                console.log('mediaready');
                _this._mediaReady = true;
            }, false);
            this.avcomponent.on('rangechanged', function (rangeId) {
                if (rangeId) {
                    _this._setTitle();
                    var range = _this.extension.helper.getRangeById(rangeId);
                    if (range) {
                        var currentRange = _this.extension.helper.getCurrentRange();
                        if (range !== currentRange) {
                            _this.component.publish(BaseEvents_1.BaseEvents.RANGE_CHANGED, range);
                        }
                    }
                    else {
                        _this.component.publish(BaseEvents_1.BaseEvents.RANGE_CHANGED, null);
                    }
                }
                else {
                    _this.component.publish(BaseEvents_1.BaseEvents.RANGE_CHANGED, null);
                }
            }, false);
        };
        AVCenterPanel.prototype._observeRangeChanges = function () {
            if (!this._isThumbsViewOpen) {
                return true;
            }
            return false;
        };
        AVCenterPanel.prototype._setTitle = function () {
            var _this = this;
            var title = '';
            var value;
            var label;
            // get the current range or canvas title
            var currentRange = this.extension.helper.getCurrentRange();
            if (currentRange) {
                label = currentRange.getLabel();
            }
            else {
                label = this.extension.helper.getCurrentCanvas().getLabel();
            }
            value = Manifesto.LanguageMap.getValue(label);
            if (value) {
                title = value;
            }
            if (Utils.Bools.getBool(this.config.options.includeParentInTitleEnabled, false)) {
                // get the parent range or manifest's title
                if (currentRange) {
                    if (currentRange.parentRange) {
                        label = currentRange.parentRange.getLabel();
                        value = Manifesto.LanguageMap.getValue(label);
                    }
                }
                else {
                    value = this.extension.helper.getLabel();
                }
                if (value) {
                    title += this.content.delimiter + value;
                }
            }
            this.title = title;
            // set subtitle
            var groups = this.extension.helper.getMetadata({
                range: currentRange
            });
            for (var i = 0; i < groups.length; i++) {
                var group = groups[i];
                var item = group.items.find(function (el) {
                    if (el.label) {
                        var label_1 = Manifesto.LanguageMap.getValue(el.label);
                        if (label_1 && label_1.toLowerCase() === _this.config.options.subtitleMetadataField) {
                            return true;
                        }
                    }
                    return false;
                });
                if (item) {
                    this.subtitle = Manifesto.LanguageMap.getValue(item.value);
                    break;
                }
            }
            this.$title.text(Utils_1.UVUtils.sanitize(this.title));
            this.resize(false);
        };
        AVCenterPanel.prototype._isCurrentResourceAccessControlled = function () {
            var canvas = this.extension.helper.getCurrentCanvas();
            return canvas.externalResource.isAccessControlled();
        };
        AVCenterPanel.prototype.openMedia = function (resources) {
            var _this = this;
            this.extension.getExternalResources(resources).then(function () {
                if (_this.avcomponent) {
                    // reset if the media has already been loaded (degraded flow has happened)
                    if (_this.extension.helper.canvasIndex === _this._lastCanvasIndex) {
                        _this.avcomponent.reset();
                    }
                    _this._lastCanvasIndex = _this.extension.helper.canvasIndex;
                    _this.avcomponent.set({
                        helper: _this.extension.helper,
                        adaptiveAuthEnabled: _this._isCurrentResourceAccessControlled(),
                        autoPlay: _this.config.options.autoPlay,
                        autoSelectRange: true,
                        constrainNavigationToRange: _this._limitToRange(),
                        content: _this.content,
                        defaultAspectRatio: 0.56,
                        doubleClickMS: 350,
                        limitToRange: _this._limitToRange(),
                        posterImageRatio: _this.config.options.posterImageRatio
                    });
                    _this.resize();
                }
            });
        };
        AVCenterPanel.prototype._limitToRange = function () {
            return !this.extension.isDesktopMetric();
        };
        AVCenterPanel.prototype._whenMediaReady = function (cb) {
            var _this = this;
            Utils.Async.waitFor(function () {
                return _this._mediaReady;
            }, cb);
        };
        AVCenterPanel.prototype._viewRange = function (range) {
            var _this = this;
            this._whenMediaReady(function () {
                if (range && _this.avcomponent) {
                    _this.avcomponent.playRange(range.id);
                }
                // don't resize the av component to avoid expensively redrawing waveforms
                _this.resize(false);
            });
        };
        AVCenterPanel.prototype._viewCanvas = function (canvasIndex) {
            var _this = this;
            this._whenMediaReady(function () {
                var canvas = _this.extension.helper.getCanvasByIndex(canvasIndex);
                if (_this.avcomponent) {
                    _this.avcomponent.showCanvas(canvas.id);
                }
            });
        };
        AVCenterPanel.prototype.resize = function (resizeAVComponent) {
            if (resizeAVComponent === void 0) { resizeAVComponent = true; }
            _super.prototype.resize.call(this);
            if (resizeAVComponent && this.avcomponent) {
                this.$avcomponent.height(this.$content.height());
                this.avcomponent.resize();
            }
        };
        return AVCenterPanel;
    }(CenterPanel_1.CenterPanel));
    exports.AVCenterPanel = AVCenterPanel;
});

define('modules/uv-shared-module/InformationArgs',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var InformationArgs = /** @class */ (function () {
        function InformationArgs(informationType, param) {
            this.informationType = informationType;
            this.param = param;
        }
        return InformationArgs;
    }());
    exports.InformationArgs = InformationArgs;
});

define('modules/uv-shared-module/InformationType',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var InformationType;
    (function (InformationType) {
        InformationType[InformationType["AUTH_CORS_ERROR"] = 0] = "AUTH_CORS_ERROR";
        InformationType[InformationType["DEGRADED_RESOURCE"] = 1] = "DEGRADED_RESOURCE";
    })(InformationType = exports.InformationType || (exports.InformationType = {}));
});

define('modules/uv-shared-module/LoginWarningMessages',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LoginWarningMessages = /** @class */ (function () {
        function LoginWarningMessages() {
        }
        LoginWarningMessages.FORBIDDEN = "forbiddenResourceMessage";
        return LoginWarningMessages;
    }());
    exports.LoginWarningMessages = LoginWarningMessages;
});

define('modules/uv-shared-module/Auth09',["require", "exports", "./BaseEvents", "./InformationArgs", "./InformationType", "./LoginWarningMessages"], function (require, exports, BaseEvents_1, InformationArgs_1, InformationType_1, LoginWarningMessages_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Auth09 = /** @class */ (function () {
        function Auth09() {
        }
        Auth09.loadExternalResources = function (resourcesToLoad, storageStrategy) {
            return new Promise(function (resolve) {
                manifesto.Utils.loadExternalResourcesAuth09(resourcesToLoad, storageStrategy, Auth09.clickThrough, Auth09.restricted, Auth09.login, Auth09.getAccessToken, Auth09.storeAccessToken, Auth09.getStoredAccessToken, Auth09.handleExternalResourceResponse).then(function (r) {
                    resolve(r);
                })['catch'](function (error) {
                    switch (error.name) {
                        case manifesto.StatusCodes.AUTHORIZATION_FAILED.toString():
                            Auth09.publish(BaseEvents_1.BaseEvents.LOGIN_FAILED);
                            break;
                        case manifesto.StatusCodes.FORBIDDEN.toString():
                            Auth09.publish(BaseEvents_1.BaseEvents.FORBIDDEN);
                            break;
                        case manifesto.StatusCodes.RESTRICTED.toString():
                            // do nothing
                            break;
                        default:
                            Auth09.publish(BaseEvents_1.BaseEvents.SHOW_MESSAGE, [error.message || error]);
                    }
                });
            });
        };
        Auth09.clickThrough = function (resource) {
            return new Promise(function (resolve) {
                Auth09.publish(BaseEvents_1.BaseEvents.SHOW_CLICKTHROUGH_DIALOGUE, [{
                        resource: resource,
                        acceptCallback: function () {
                            if (resource.clickThroughService) {
                                var win_1 = window.open(resource.clickThroughService.id);
                                var pollTimer_1 = window.setInterval(function () {
                                    if (win_1 && win_1.closed) {
                                        window.clearInterval(pollTimer_1);
                                        Auth09.publish(BaseEvents_1.BaseEvents.CLICKTHROUGH);
                                        resolve();
                                    }
                                }, 500);
                            }
                        }
                    }]);
            });
        };
        Auth09.restricted = function (resource) {
            return new Promise(function (resolve, reject) {
                Auth09.publish(BaseEvents_1.BaseEvents.SHOW_RESTRICTED_DIALOGUE, [{
                        resource: resource,
                        acceptCallback: function () {
                            Auth09.publish(BaseEvents_1.BaseEvents.LOAD_FAILED);
                            reject(resource);
                        }
                    }]);
            });
        };
        Auth09.login = function (resource) {
            return new Promise(function (resolve) {
                var options = {};
                if (resource.status === HTTPStatusCode.FORBIDDEN) {
                    options.warningMessage = LoginWarningMessages_1.LoginWarningMessages.FORBIDDEN;
                    options.showCancelButton = true;
                }
                Auth09.publish(BaseEvents_1.BaseEvents.SHOW_LOGIN_DIALOGUE, [{
                        resource: resource,
                        loginCallback: function () {
                            if (resource.loginService) {
                                var win_2 = window.open(resource.loginService.id + "?t=" + new Date().getTime());
                                var pollTimer_2 = window.setInterval(function () {
                                    if (win_2 && win_2.closed) {
                                        window.clearInterval(pollTimer_2);
                                        Auth09.publish(BaseEvents_1.BaseEvents.LOGIN);
                                        resolve();
                                    }
                                }, 500);
                            }
                        },
                        logoutCallback: function () {
                            if (resource.logoutService) {
                                var win_3 = window.open(resource.logoutService.id + "?t=" + new Date().getTime());
                                var pollTimer_3 = window.setInterval(function () {
                                    if (win_3 && win_3.closed) {
                                        window.clearInterval(pollTimer_3);
                                        Auth09.publish(BaseEvents_1.BaseEvents.LOGOUT);
                                        resolve();
                                    }
                                }, 500);
                            }
                        },
                        options: options
                    }]);
            });
        };
        Auth09.getAccessToken = function (resource, rejectOnError) {
            return new Promise(function (resolve, reject) {
                if (resource.tokenService) {
                    var serviceUri = resource.tokenService.id;
                    // pick an identifier for this message. We might want to keep track of sent messages
                    var msgId = serviceUri + "|" + new Date().getTime();
                    var receiveAccessToken_1 = function (e) {
                        window.removeEventListener("message", receiveAccessToken_1);
                        var token = e.data;
                        if (token.error) {
                            if (rejectOnError) {
                                reject(token.errorDescription);
                            }
                            else {
                                resolve(undefined);
                            }
                        }
                        else {
                            resolve(token);
                        }
                    };
                    window.addEventListener("message", receiveAccessToken_1, false);
                    var tokenUri = serviceUri + "?messageId=" + msgId;
                    $('#commsFrame').prop('src', tokenUri);
                }
                else {
                    reject('Token service not found');
                }
            });
        };
        Auth09.storeAccessToken = function (resource, token, storageStrategy) {
            return new Promise(function (resolve, reject) {
                if (resource.tokenService) {
                    Utils.Storage.set(resource.tokenService.id, token, token.expiresIn, new Utils.StorageType(storageStrategy));
                    resolve();
                }
                else {
                    reject('Token service not found');
                }
            });
        };
        Auth09.getStoredAccessToken = function (resource, storageStrategy) {
            return new Promise(function (resolve, reject) {
                var foundItems = [];
                var item = null;
                // try to match on the tokenService, if the resource has one:
                if (resource.tokenService) {
                    item = Utils.Storage.get(resource.tokenService.id, new Utils.StorageType(storageStrategy));
                }
                if (item) {
                    foundItems.push(item);
                }
                else {
                    // find an access token for the domain
                    var domain = Utils.Urls.getUrlParts(resource.dataUri).hostname;
                    var items = Utils.Storage.getItems(new Utils.StorageType(storageStrategy));
                    for (var i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.key.includes(domain)) {
                            foundItems.push(item);
                        }
                    }
                }
                // sort by expiresAt, earliest to most recent.
                foundItems = foundItems.sort(function (a, b) {
                    return a.expiresAt - b.expiresAt;
                });
                var foundToken;
                if (foundItems.length) {
                    foundToken = foundItems[foundItems.length - 1].value;
                }
                resolve(foundToken);
            });
        };
        Auth09.handleExternalResourceResponse = function (resource) {
            return new Promise(function (resolve, reject) {
                resource.isResponseHandled = true;
                if (resource.status === HTTPStatusCode.OK) {
                    resolve(resource);
                }
                else if (resource.status === HTTPStatusCode.MOVED_TEMPORARILY) {
                    resolve(resource);
                    Auth09.publish(BaseEvents_1.BaseEvents.RESOURCE_DEGRADED, [resource]);
                }
                else {
                    if (resource.error.status === HTTPStatusCode.UNAUTHORIZED ||
                        resource.error.status === HTTPStatusCode.INTERNAL_SERVER_ERROR) {
                        // if the browser doesn't support CORS
                        if (!Modernizr.cors) {
                            var informationArgs = new InformationArgs_1.InformationArgs(InformationType_1.InformationType.AUTH_CORS_ERROR, null);
                            Auth09.publish(BaseEvents_1.BaseEvents.SHOW_INFORMATION, [informationArgs]);
                            resolve(resource);
                        }
                        else {
                            reject(resource.error.statusText);
                        }
                    }
                    else if (resource.error.status === HTTPStatusCode.FORBIDDEN) {
                        var error = new Error();
                        error.message = "Forbidden";
                        error.name = manifesto.StatusCodes.FORBIDDEN.toString();
                        reject(error);
                    }
                    else {
                        reject(resource.error.statusText);
                    }
                }
            });
        };
        Auth09.handleDegraded = function (resource) {
            var informationArgs = new InformationArgs_1.InformationArgs(InformationType_1.InformationType.DEGRADED_RESOURCE, resource);
            Auth09.publish(BaseEvents_1.BaseEvents.SHOW_INFORMATION, [informationArgs]);
        };
        return Auth09;
    }());
    exports.Auth09 = Auth09;
});

define('modules/uv-shared-module/Auth1',["require", "exports", "./BaseEvents", "../../Utils", "./InformationArgs", "./InformationType"], function (require, exports, BaseEvents_1, Utils_1, InformationArgs_1, InformationType_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Auth1 = /** @class */ (function () {
        function Auth1() {
        }
        Auth1.loadExternalResources = function (resourcesToLoad, storageStrategy, options) {
            return new Promise(function (resolve) {
                Auth1.storageStrategy = storageStrategy;
                // set all resources to Auth API V1
                resourcesToLoad = resourcesToLoad.map(function (resource) {
                    resource.authAPIVersion = 1;
                    resource.options = options;
                    return resource;
                });
                manifesto.Utils.loadExternalResourcesAuth1(resourcesToLoad, Auth1.openContentProviderInteraction, Auth1.openTokenService, Auth1.getStoredAccessToken, Auth1.userInteractedWithContentProvider, Auth1.getContentProviderInteraction, Auth1.handleMovedTemporarily, Auth1.showOutOfOptionsMessages).then(function (r) {
                    resolve(r);
                })['catch'](function (error) {
                    switch (error.name) {
                        case manifesto.StatusCodes.AUTHORIZATION_FAILED.toString():
                            Auth1.publish(BaseEvents_1.BaseEvents.LOGIN_FAILED);
                            break;
                        case manifesto.StatusCodes.FORBIDDEN.toString():
                            Auth1.publish(BaseEvents_1.BaseEvents.FORBIDDEN);
                            break;
                        case manifesto.StatusCodes.RESTRICTED.toString():
                            // do nothing
                            break;
                        default:
                            Auth1.publish(BaseEvents_1.BaseEvents.SHOW_MESSAGE, [error.message || error]);
                    }
                });
            });
        };
        Auth1.getCookieServiceUrl = function (service) {
            var cookieServiceUrl = service.id + "?origin=" + Auth1.getOrigin();
            return cookieServiceUrl;
        };
        Auth1.openContentProviderInteraction = function (service) {
            var cookieServiceUrl = Auth1.getCookieServiceUrl(service);
            return window.open(cookieServiceUrl);
        };
        // determine the postMessage-style origin for a URL
        Auth1.getOrigin = function (url) {
            var urlHolder = window.location;
            if (url) {
                urlHolder = document.createElement('a');
                urlHolder.href = url;
            }
            return urlHolder.protocol + "//" + urlHolder.hostname + (urlHolder.port ? ':' + urlHolder.port : '');
        };
        Auth1.userInteractedWithContentProvider = function (contentProviderWindow) {
            return new Promise(function (resolve) {
                // What happens here is forever a mystery to a client application.
                // It can but wait.
                var poll = window.setInterval(function () {
                    if (contentProviderWindow.closed) {
                        window.clearInterval(poll);
                        resolve(true);
                    }
                }, 500);
            });
        };
        Auth1.handleMovedTemporarily = function (resource) {
            return new Promise(function (resolve) {
                Auth1.showDegradedMessage(resource);
                resource.isResponseHandled = true;
                resolve();
            });
        };
        Auth1.showDegradedMessage = function (resource) {
            var informationArgs = new InformationArgs_1.InformationArgs(InformationType_1.InformationType.DEGRADED_RESOURCE, resource);
            Auth1.publish(BaseEvents_1.BaseEvents.SHOW_INFORMATION, [informationArgs]);
        };
        Auth1.storeAccessToken = function (resource, token) {
            return new Promise(function (resolve, reject) {
                if (resource.tokenService) {
                    Utils.Storage.set(resource.tokenService.id, token, token.expiresIn, new Utils.StorageType(Auth1.storageStrategy));
                    resolve();
                }
                else {
                    reject('Token service not found');
                }
            });
        };
        Auth1.getStoredAccessToken = function (resource) {
            return new Promise(function (resolve, reject) {
                var foundItems = [];
                var item = null;
                // try to match on the tokenService, if the resource has one:
                if (resource.tokenService) {
                    item = Utils.Storage.get(resource.tokenService.id, new Utils.StorageType(Auth1.storageStrategy));
                }
                if (item) {
                    foundItems.push(item);
                }
                else {
                    // find an access token for the domain
                    var domain = Utils.Urls.getUrlParts(resource.dataUri).hostname;
                    var items = Utils.Storage.getItems(new Utils.StorageType(Auth1.storageStrategy));
                    for (var i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.key.includes(domain)) {
                            foundItems.push(item);
                        }
                    }
                }
                // sort by expiresAt, earliest to most recent.
                foundItems = foundItems.sort(function (a, b) {
                    return a.expiresAt - b.expiresAt;
                });
                var foundToken = null;
                if (foundItems.length) {
                    foundToken = foundItems[foundItems.length - 1].value;
                }
                resolve(foundToken);
            });
        };
        Auth1.getContentProviderInteraction = function (resource, service) {
            return new Promise(function (resolve) {
                // if the info bar has already been shown for degraded logins
                if (resource.isResponseHandled && !resource.authHoldingPage) {
                    Auth1.showDegradedMessage(resource);
                    resolve(null);
                }
                else if (resource.authHoldingPage) {
                    // redirect holding page
                    resource.authHoldingPage.location.href = Auth1.getCookieServiceUrl(service);
                    resolve(resource.authHoldingPage);
                }
                else {
                    Auth1.publish(BaseEvents_1.BaseEvents.SHOW_AUTH_DIALOGUE, [{
                            service: service,
                            closeCallback: function () {
                                resolve(null);
                            },
                            confirmCallback: function () {
                                var win = Auth1.openContentProviderInteraction(service);
                                resolve(win);
                            },
                            cancelCallback: function () {
                                resolve(null);
                            }
                        }]);
                }
            });
        };
        Auth1.openTokenService = function (resource, tokenService) {
            // use a Promise across a postMessage call. Discuss...
            return new Promise(function (resolve, reject) {
                // if necessary, the client can decide not to trust this origin
                var serviceOrigin = Auth1.getOrigin(tokenService.id);
                var messageId = new Date().getTime();
                Auth1.messages[messageId] = {
                    "resolve": resolve,
                    "reject": reject,
                    "serviceOrigin": serviceOrigin,
                    "resource": resource
                };
                window.addEventListener("message", Auth1.receiveToken, false);
                var tokenUrl = tokenService.id + "?messageId=" + messageId + "&origin=" + Auth1.getOrigin();
                // load the access token service url in the #commsFrame iframe.
                // when the message event listener (Auth1.receiveToken) receives a message from the iframe
                // it looks in Auth1.messages to find a corresponding message id with the same origin.
                // if found, it stores the returned access token, resolves and deletes the message.
                // resolving the message resolves the openTokenService promise.
                $('#commsFrame').prop('src', tokenUrl);
                // reject any unhandled messages after a configurable timeout
                var postMessageTimeout = 5000;
                setTimeout(function () {
                    if (Auth1.messages[messageId]) {
                        Auth1.messages[messageId].reject("Message unhandled after " + postMessageTimeout + "ms, rejecting");
                        delete Auth1.messages[messageId];
                    }
                }, postMessageTimeout);
            });
        };
        Auth1.receiveToken = function (event) {
            if (event.data.hasOwnProperty("messageId")) {
                var message_1 = Auth1.messages[event.data.messageId];
                if (message_1 && event.origin == message_1.serviceOrigin) {
                    // Any message with a messageId is a success
                    Auth1.storeAccessToken(message_1.resource, event.data).then(function () {
                        message_1.resolve(event.data); // resolves openTokenService with the token
                        delete Auth1.messages[event.data.messageId];
                        return;
                    });
                }
            }
        };
        Auth1.showOutOfOptionsMessages = function (resource, service) {
            // if the UV is already showing the info bar, no need to show an error message.
            if (resource.status == HTTPStatusCode.MOVED_TEMPORARILY) {
                return;
            }
            var errorMessage = "";
            if (service.getFailureHeader()) {
                errorMessage += '<p>' + service.getFailureHeader() + '</p>';
            }
            if (service.getFailureDescription()) {
                errorMessage += service.getFailureDescription();
            }
            Auth1.publish(BaseEvents_1.BaseEvents.SHOW_MESSAGE, [Utils_1.UVUtils.sanitize(errorMessage)]);
        };
        Auth1.messages = {};
        return Auth1;
    }());
    exports.Auth1 = Auth1;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/Dialogue',["require", "exports", "./BaseView", "./BaseEvents"], function (require, exports, BaseView_1, BaseEvents_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Dialogue = /** @class */ (function (_super) {
        __extends(Dialogue, _super);
        function Dialogue($element) {
            var _this = _super.call(this, $element, false, false) || this;
            _this.allowClose = true;
            _this.isActive = false;
            _this.isUnopened = true;
            return _this;
        }
        Dialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('dialogue');
            _super.prototype.create.call(this);
            // events.
            this.component.subscribe(BaseEvents_1.BaseEvents.CLOSE_ACTIVE_DIALOGUE, function () {
                if (_this.isActive) {
                    if (_this.allowClose) {
                        _this.close();
                    }
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ESCAPE, function () {
                if (_this.isActive) {
                    if (_this.allowClose) {
                        _this.close();
                    }
                }
            });
            this.$top = $('<div class="top"></div>');
            this.$element.append(this.$top);
            this.$closeButton = $('<button type="button" class="btn btn-default close" tabindex="0">' + this.content.close + '</button>');
            this.$middle = $('<div class="middle"></div>');
            this.$element.append(this.$middle);
            this.$content = $('<div class="content"></div>');
            this.$middle.append(this.$content);
            this.$buttons = $('<div class="buttons"></div>');
            this.$middle.append(this.$buttons);
            this.$bottom = $('<div class="bottom"></div>');
            this.$element.append(this.$bottom);
            if (this.config.topCloseButtonEnabled) {
                this.$top.append(this.$closeButton);
            }
            else {
                this.$buttons.append(this.$closeButton);
            }
            this.$closeButton.on('click', function (e) {
                e.preventDefault();
                _this.close();
            });
            this.returnFunc = this.close;
        };
        Dialogue.prototype.enableClose = function () {
            this.allowClose = true;
            this.$closeButton.show();
        };
        Dialogue.prototype.disableClose = function () {
            this.allowClose = false;
            this.$closeButton.hide();
        };
        Dialogue.prototype.setDockedPosition = function () {
            var top = Math.floor(this.extension.height() - this.$element.outerHeight(true));
            var left = 0;
            var arrowLeft = 0;
            var normalisedPos = 0;
            if (this.$triggerButton) {
                var verticalPadding = 4;
                var horizontalPadding = 2;
                var a = this.$triggerButton.offset().top;
                var b = this.extension.$element.offset().top;
                var d = this.$element.outerHeight(true);
                var e = (a - b) - d;
                top = e + verticalPadding;
                var f = this.$triggerButton.offset().left;
                var g = this.extension.$element.offset().left;
                var h = f - g;
                normalisedPos = Utils.Maths.normalise(h, 0, this.extension.width());
                left = Math.floor((this.extension.width() * normalisedPos) - ((this.$element.width()) * normalisedPos)) + horizontalPadding;
                arrowLeft = Math.floor(this.$element.width() * normalisedPos);
            }
            this.$bottom.css('backgroundPosition', arrowLeft + 'px 0px');
            this.$element.css({
                'top': top,
                'left': left
            });
        };
        Dialogue.prototype.open = function (triggerButton) {
            var _this = this;
            this.$element.attr('aria-hidden', 'false');
            this.$element.show();
            if (triggerButton) {
                this.$triggerButton = $(triggerButton);
                this.$bottom.show();
            }
            else {
                this.$bottom.hide();
            }
            this.isActive = true;
            // set the focus to the default button.
            setTimeout(function () {
                var $defaultButton = _this.$element.find('.default');
                if ($defaultButton.length) {
                    $defaultButton.focus();
                }
                else {
                    // if there's no default button, focus on the first visible input
                    var $input = _this.$element.find('input:visible').first();
                    if ($input.length) {
                        $input.focus();
                    }
                    else {
                        // if there's no visible first input, focus on the close button
                        _this.$closeButton.focus();
                    }
                }
            }, 1);
            this.component.publish(BaseEvents_1.BaseEvents.SHOW_OVERLAY);
            if (this.isUnopened) {
                this.isUnopened = false;
                this.afterFirstOpen();
            }
            this.resize();
        };
        Dialogue.prototype.afterFirstOpen = function () {
        };
        Dialogue.prototype.close = function () {
            if (!this.isActive)
                return;
            this.$element.attr('aria-hidden', 'true');
            this.$element.hide();
            this.isActive = false;
            this.component.publish(this.closeCommand);
            this.component.publish(BaseEvents_1.BaseEvents.HIDE_OVERLAY);
        };
        Dialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$element.css({
                'top': Math.floor((this.extension.height() / 2) - (this.$element.height() / 2)),
                'left': Math.floor((this.extension.width() / 2) - (this.$element.width() / 2))
            });
        };
        return Dialogue;
    }(BaseView_1.BaseView));
    exports.Dialogue = Dialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/AuthDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue", "../../Utils"], function (require, exports, BaseEvents_1, Dialogue_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AuthDialogue = /** @class */ (function (_super) {
        __extends(AuthDialogue, _super);
        function AuthDialogue($element) {
            return _super.call(this, $element) || this;
        }
        AuthDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('authDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_AUTH_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_AUTH_DIALOGUE;
            this.component.subscribe(this.openCommand, function (e) {
                _this.closeCallback = e.closeCallback;
                _this.confirmCallback = e.confirmCallback;
                _this.cancelCallback = e.cancelCallback;
                _this.service = e.service;
                _this.open();
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$title = $('<h1></h1>');
            this.$content.append(this.$title);
            this.$content.append('\
            <div>\
                <p class="message scroll"></p>\
            </div>');
            this.$buttons.prepend(this._buttonsToAdd());
            this.$message = this.$content.find('.message');
            this.$confirmButton = this.$buttons.find('.confirm');
            this.$confirmButton.text(this.content.confirm);
            this.$cancelButton = this.$buttons.find('.close');
            this.$cancelButton.text(this.content.cancel);
            this.$element.hide();
            this.$confirmButton.on('click', function (e) {
                e.preventDefault();
                if (_this.confirmCallback) {
                    _this.confirmCallback();
                }
                _this.close();
            });
            this.$cancelButton.on('click', function (e) {
                e.preventDefault();
                if (_this.cancelCallback) {
                    _this.cancelCallback();
                }
                _this.close();
            });
        };
        AuthDialogue.prototype.open = function () {
            _super.prototype.open.call(this);
            var header = this.service.getHeader();
            var description = this.service.getDescription();
            var confirmLabel = this.service.getConfirmLabel();
            if (header) {
                this.$title.text(Utils_1.UVUtils.sanitize(header));
            }
            if (description) {
                this.$message.html(Utils_1.UVUtils.sanitize(description));
                this.$message.targetBlank();
                this.$message.find('a').on('click', function () {
                    var url = $(this).attr('href');
                    this.component.publish(BaseEvents_1.BaseEvents.EXTERNAL_LINK_CLICKED, url);
                });
            }
            if (confirmLabel) {
                this.$confirmButton.text(Utils_1.UVUtils.sanitize(confirmLabel));
            }
            this.resize();
        };
        AuthDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        AuthDialogue.prototype._buttonsToAdd = function () {
            var buttonsToAdd = '<a class="confirm btn btn-primary" href="#" target="_parent"></a>';
            // If the top button is enabled, add an additional close button for consistency.
            if (this.config.topCloseButtonEnabled) {
                buttonsToAdd += '<button class="close btn btn-default"></button>';
            }
            return buttonsToAdd;
        };
        return AuthDialogue;
    }(Dialogue_1.Dialogue));
    exports.AuthDialogue = AuthDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/ClickThroughDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ClickThroughDialogue = /** @class */ (function (_super) {
        __extends(ClickThroughDialogue, _super);
        function ClickThroughDialogue($element) {
            return _super.call(this, $element) || this;
        }
        ClickThroughDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('clickThroughDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_CLICKTHROUGH_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_CLICKTHROUGH_DIALOGUE;
            this.component.subscribe(this.openCommand, function (params) {
                _this.acceptCallback = params.acceptCallback;
                _this.resource = params.resource;
                _this.open();
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$title = $('<h1></h1>');
            this.$content.append(this.$title);
            this.$content.append('\
            <div>\
                <p class="message scroll"></p>\
                <div class="buttons">\
                    <a class="acceptTerms btn btn-primary" href="#" target="_parent"></a>\
                </div>\
            </div>');
            this.$message = this.$content.find(".message");
            this.$acceptTermsButton = this.$content.find(".acceptTerms");
            // TODO: get from config this.$acceptTermsButton.text(this.content.acceptTerms); // figure out config
            this.$acceptTermsButton.text("Accept Terms and Open");
            this.$element.hide();
            this.$acceptTermsButton.on('click', function (e) {
                e.preventDefault();
                _this.close();
                _this.component.publish(BaseEvents_1.BaseEvents.ACCEPT_TERMS);
                if (_this.acceptCallback)
                    _this.acceptCallback();
            });
        };
        ClickThroughDialogue.prototype.open = function () {
            _super.prototype.open.call(this);
            if (this.resource.clickThroughService) {
                this.$title.text(this.resource.clickThroughService.getProperty('label'));
                this.$message.html(this.resource.clickThroughService.getProperty('description'));
                this.$message.targetBlank();
            }
            this.$message.find('a').on('click', function () {
                var url = $(this).attr('href');
                this.component.publish(BaseEvents_1.BaseEvents.EXTERNAL_LINK_CLICKED, url);
            });
            this.resize();
        };
        ClickThroughDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ClickThroughDialogue;
    }(Dialogue_1.Dialogue));
    exports.ClickThroughDialogue = ClickThroughDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/LoginDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LoginDialogue = /** @class */ (function (_super) {
        __extends(LoginDialogue, _super);
        function LoginDialogue($element) {
            return _super.call(this, $element) || this;
        }
        LoginDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('loginDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_LOGIN_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_LOGIN_DIALOGUE;
            this.component.subscribe(this.openCommand, function (e) {
                _this.loginCallback = e.loginCallback;
                _this.logoutCallback = e.logoutCallback;
                _this.options = e.options;
                _this.resource = e.resource;
                _this.open();
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$title = $('<h1></h1>');
            this.$content.append(this.$title);
            this.$content.append('\
            <div>\
                <p class="message scroll"></p>\
                <div class="buttons">\
                    <a class="logout btn btn-primary" href="#" target="_parent"></a>\
                    <a class="login btn btn-primary" href="#" target="_parent"></a>\
                    <a class="cancel btn btn-primary" href="#"></a>\
                </div>\
            </div>');
            this.$message = this.$content.find('.message');
            this.$loginButton = this.$content.find('.login');
            this.$loginButton.text(this.content.login);
            this.$logoutButton = this.$content.find('.logout');
            this.$logoutButton.text(this.content.logout);
            this.$cancelButton = this.$content.find('.cancel');
            this.$cancelButton.text(this.content.cancel);
            this.$element.hide();
            this.$loginButton.on('click', function (e) {
                e.preventDefault();
                _this.close();
                if (_this.loginCallback)
                    _this.loginCallback();
            });
            this.$logoutButton.on('click', function (e) {
                e.preventDefault();
                _this.close();
                if (_this.logoutCallback)
                    _this.logoutCallback();
            });
            this.$cancelButton.on('click', function (e) {
                e.preventDefault();
                _this.close();
            });
            this.updateLogoutButton();
        };
        LoginDialogue.prototype.open = function () {
            _super.prototype.open.call(this);
            var message = "";
            if (this.resource.loginService) {
                this.$title.text(this.resource.loginService.getProperty('label'));
                message = this.resource.loginService.getProperty('description');
            }
            if (this.options.warningMessage) {
                message = '<span class="warning">' + this.extension.data.config.content[this.options.warningMessage] + '</span><span class="description">' + message + '</span>';
            }
            this.updateLogoutButton();
            this.$message.html(message);
            this.$message.targetBlank();
            this.$message.find('a').on('click', function () {
                var url = $(this).attr('href');
                this.component.publish(BaseEvents_1.BaseEvents.EXTERNAL_LINK_CLICKED, url);
            });
            if (this.options.showCancelButton) {
                this.$cancelButton.show();
            }
            else {
                this.$cancelButton.hide();
            }
            this.resize();
        };
        LoginDialogue.prototype.updateLogoutButton = function () {
            if (this.extension.isLoggedIn) {
                this.$logoutButton.show();
            }
            else {
                this.$logoutButton.hide();
            }
        };
        LoginDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return LoginDialogue;
    }(Dialogue_1.Dialogue));
    exports.LoginDialogue = LoginDialogue;
});

define('modules/uv-shared-module/StringValue',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StringValue = /** @class */ (function () {
        function StringValue(value) {
            this.value = "";
            if (value) {
                this.value = value.toLowerCase();
            }
        }
        StringValue.prototype.toString = function () {
            return this.value;
        };
        return StringValue;
    }());
    exports.StringValue = StringValue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/MetricType',["require", "exports", "./StringValue"], function (require, exports, StringValue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MetricType = /** @class */ (function (_super) {
        __extends(MetricType, _super);
        function MetricType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MetricType.DESKTOP = new MetricType("desktop");
        MetricType.MOBILELANDSCAPE = new MetricType("mobilelandscape");
        MetricType.MOBILEPORTRAIT = new MetricType("mobileportrait");
        MetricType.NONE = new MetricType("none");
        MetricType.WATCH = new MetricType("watch");
        return MetricType;
    }(StringValue_1.StringValue));
    exports.MetricType = MetricType;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/RestrictedDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RestrictedDialogue = /** @class */ (function (_super) {
        __extends(RestrictedDialogue, _super);
        function RestrictedDialogue($element) {
            return _super.call(this, $element) || this;
        }
        RestrictedDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('restrictedDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_RESTRICTED_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_RESTRICTED_DIALOGUE;
            this.component.subscribe(this.openCommand, function (e) {
                _this.acceptCallback = e.acceptCallback;
                _this.options = e.options;
                _this.resource = e.resource;
                _this.open();
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$title = $('<h1></h1>');
            this.$content.append(this.$title);
            this.$content.append('\
            <div>\
                <p class="message scroll"></p>\
                <div class="buttons">\
                    <a class="cancel btn btn-primary" href="#" target="_parent"></a>\
                </div>\
            </div>');
            this.$message = this.$content.find('.message');
            this.$message.targetBlank();
            // todo: revisit?
            //this.$nextVisibleButton = this.$content.find('.nextvisible');
            //this.$nextVisibleButton.text(this.content.nextVisibleItem);
            this.$cancelButton = this.$content.find('.cancel');
            this.$cancelButton.text(this.content.cancel);
            this.$element.hide();
            this.$cancelButton.on('click', function (e) {
                e.preventDefault();
                _this.close();
            });
        };
        RestrictedDialogue.prototype.open = function () {
            _super.prototype.open.call(this);
            this.isAccepted = false;
            var message = "";
            if (this.resource.restrictedService) {
                this.$title.text(this.resource.restrictedService.getProperty('label'));
                message = this.resource.restrictedService.getProperty('description');
            }
            this.$message.html(message);
            this.$message.targetBlank();
            this.$message.find('a').on('click', function () {
                var url = $(this).attr('href');
                this.component.publish(BaseEvents_1.BaseEvents.EXTERNAL_LINK_CLICKED, url);
            });
            this.resize();
        };
        RestrictedDialogue.prototype.close = function () {
            _super.prototype.close.call(this);
            if (!this.isAccepted && this.acceptCallback) {
                this.isAccepted = true;
                this.acceptCallback();
            }
        };
        RestrictedDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return RestrictedDialogue;
    }(Dialogue_1.Dialogue));
    exports.RestrictedDialogue = RestrictedDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/GenericDialogue',["require", "exports", "./BaseEvents", "./Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GenericDialogue = /** @class */ (function (_super) {
        __extends(GenericDialogue, _super);
        function GenericDialogue($element) {
            return _super.call(this, $element) || this;
        }
        GenericDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('genericDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_GENERIC_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_GENERIC_DIALOGUE;
            this.component.subscribe(this.openCommand, function (params) {
                _this.acceptCallback = params.acceptCallback;
                _this.showMessage(params);
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$message = $('<p></p>');
            this.$content.append(this.$message);
            this.$acceptButton = $("\n          <button class=\"btn btn-primary accept default\">\n            " + this.content.ok + "\n          </button>\n        ");
            this.$buttons.append(this.$acceptButton);
            // Hide the redundant close button
            this.$buttons.find('.close').hide();
            this.$acceptButton.onPressed(function () {
                _this.accept();
            });
            this.returnFunc = function () {
                if (_this.isActive) {
                    _this.accept();
                }
            };
            this.$element.hide();
        };
        GenericDialogue.prototype.accept = function () {
            this.component.publish(BaseEvents_1.BaseEvents.CLOSE_ACTIVE_DIALOGUE);
            if (this.acceptCallback)
                this.acceptCallback();
        };
        GenericDialogue.prototype.showMessage = function (params) {
            this.$message.html(params.message);
            if (params.buttonText) {
                this.$acceptButton.text(params.buttonText);
            }
            else {
                this.$acceptButton.text(this.content.ok);
            }
            if (params.allowClose === false) {
                this.disableClose();
            }
            this.open();
        };
        GenericDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return GenericDialogue;
    }(Dialogue_1.Dialogue));
    exports.GenericDialogue = GenericDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/Shell',["require", "exports", "./BaseEvents", "./BaseView", "./GenericDialogue"], function (require, exports, BaseEvents_1, BaseView_1, GenericDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Shell = /** @class */ (function (_super) {
        __extends(Shell, _super);
        function Shell($element) {
            return _super.call(this, $element, true, true) || this;
        }
        Shell.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_OVERLAY, function () {
                _this.$overlays.show();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_OVERLAY, function () {
                _this.$overlays.hide();
            });
            this.$headerPanel = $('<div class="headerPanel"></div>');
            this.$element.append(this.$headerPanel);
            this.$mainPanel = $('<div class="mainPanel"></div>');
            this.$element.append(this.$mainPanel);
            this.$centerPanel = $('<div class="centerPanel"></div>');
            this.$mainPanel.append(this.$centerPanel);
            this.$leftPanel = $('<div class="leftPanel"></div>');
            this.$mainPanel.append(this.$leftPanel);
            this.$rightPanel = $('<div class="rightPanel"></div>');
            this.$mainPanel.append(this.$rightPanel);
            this.$footerPanel = $('<div class="footerPanel"></div>');
            this.$element.append(this.$footerPanel);
            this.$mobileFooterPanel = $('<div class="mobileFooterPanel"></div>');
            this.$element.append(this.$mobileFooterPanel);
            this.$overlays = $('<div class="overlays"></div>');
            this.$element.append(this.$overlays);
            this.$genericDialogue = $('<div class="overlay genericDialogue" aria-hidden="true"></div>');
            this.$overlays.append(this.$genericDialogue);
            this.$overlays.on('click', function (e) {
                if ($(e.target).hasClass('overlays')) {
                    e.preventDefault();
                    _this.component.publish(BaseEvents_1.BaseEvents.CLOSE_ACTIVE_DIALOGUE);
                }
            });
            // create shared views.
            new GenericDialogue_1.GenericDialogue(this.$genericDialogue);
        };
        Shell.prototype.resize = function () {
            var _this = this;
            _super.prototype.resize.call(this);
            setTimeout(function () {
                _this.$overlays.width(_this.extension.width());
                _this.$overlays.height(_this.extension.height());
            }, 1);
            var mainHeight = this.$element.height() - parseInt(this.$mainPanel.css('paddingTop'))
                - (this.$headerPanel.is(':visible') ? this.$headerPanel.height() : 0)
                - (this.$footerPanel.is(':visible') ? this.$footerPanel.height() : 0)
                - (this.$mobileFooterPanel.is(':visible') ? this.$mobileFooterPanel.height() : 0);
            this.$mainPanel.height(mainHeight);
        };
        return Shell;
    }(BaseView_1.BaseView));
    exports.Shell = Shell;
});

define('SynchronousRequire',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SynchronousRequire = /** @class */ (function () {
        function SynchronousRequire() {
        }
        SynchronousRequire.load = function (deps, cb) {
            var loaders = [];
            for (var i = 0; i < deps.length; i++) {
                var depLoader = new DependencyLoader(i, deps[i], deps, cb);
                loaders.push(depLoader);
            }
            var sequence = Promise.resolve();
            loaders.forEach(function (loader) {
                sequence = sequence.then(function () {
                    return loader.load();
                });
            });
            return sequence;
        };
        return SynchronousRequire;
    }());
    exports.SynchronousRequire = SynchronousRequire;
    var DependencyLoader = /** @class */ (function () {
        function DependencyLoader(index, dep, deps, cb) {
            this._dep = dep;
            this._deps = deps;
            this._cb = cb;
            this._index = index;
        }
        DependencyLoader.prototype.getDependencyIndex = function (dep) {
            return this._deps.findIndex(function (el) { return el.includes(dep); });
        };
        DependencyLoader.prototype.load = function () {
            var that = this;
            return new Promise(function (resolve) {
                requirejs([that._dep], function (dep) {
                    that._cb(that._index, dep);
                    resolve();
                });
            });
        };
        return DependencyLoader;
    }());
    exports.DependencyLoader = DependencyLoader;
});

define('modules/uv-shared-module/BaseExtension',["require", "exports", "../../Utils", "./Auth09", "./Auth1", "../../modules/uv-dialogues-module/AuthDialogue", "./BaseEvents", "../../modules/uv-dialogues-module/ClickThroughDialogue", "../../modules/uv-dialogues-module/LoginDialogue", "../../modules/uv-shared-module/MetricType", "../../modules/uv-dialogues-module/RestrictedDialogue", "./Shell", "../../SynchronousRequire"], function (require, exports, Utils_1, Auth09_1, Auth1_1, AuthDialogue_1, BaseEvents_1, ClickThroughDialogue_1, LoginDialogue_1, MetricType_1, RestrictedDialogue_1, Shell_1, SynchronousRequire_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseExtension = /** @class */ (function () {
        function BaseExtension() {
            this.isCreated = false;
            this.isLoggedIn = false;
            this.metric = MetricType_1.MetricType.NONE;
            this.metrics = [];
            this.shifted = false;
            this.tabbing = false;
        }
        BaseExtension.prototype.create = function () {
            var _this = this;
            var that = this;
            Auth09_1.Auth09.publish = this.component.publish;
            Auth1_1.Auth1.publish = this.component.publish;
            this.$element = $(this.component.options.target);
            this.$element.data("component", this.component);
            this.fire(BaseEvents_1.BaseEvents.CREATE, {
                data: this.data,
                settings: this.getSettings(),
                preview: this.getSharePreview()
            });
            this._parseMetrics();
            this._initLocales();
            // add/remove classes.
            this.$element.empty();
            this.$element.removeClass();
            this.$element.addClass('uv');
            if (this.data.locales) {
                this.$element.addClass(this.data.locales[0].name.toLowerCase());
            }
            this.$element.addClass(this.name);
            this.$element.addClass('browser-' + window.browserDetect.browser);
            this.$element.addClass('browser-version-' + window.browserDetect.version);
            this.$element.prop('tabindex', 0);
            if (this.data.embedded) {
                this.$element.addClass('embedded');
            }
            if (this.isMobile()) {
                this.$element.addClass('mobile');
            }
            // todo: deprecate?
            if (this.data.isLightbox) {
                this.$element.addClass('lightbox');
            }
            if (Utils.Documents.supportsFullscreen()) {
                this.$element.addClass('fullscreen-supported');
            }
            this.$element.on('mousemove', function (e) {
                _this.mouseX = e.pageX;
                _this.mouseY = e.pageY;
            });
            // events
            if (!this.data.isReload) {
                var visibilityProp = Utils.Documents.getHiddenProp();
                if (visibilityProp) {
                    var event_1 = visibilityProp.replace(/[H|h]idden/, '') + 'visibilitychange';
                    document.addEventListener(event_1, function () {
                        // resize after a tab has been shown (fixes safari layout issue)
                        if (!Utils.Documents.isHidden()) {
                            _this.resize();
                        }
                    });
                }
                if (Utils.Bools.getBool(this.data.config.options.dropEnabled, true)) {
                    this.$element.on('drop', (function (e) {
                        e.preventDefault();
                        var dropUrl = e.originalEvent.dataTransfer.getData('URL');
                        var a = Utils.Urls.getUrlParts(dropUrl);
                        var iiifResourceUri = Utils.Urls.getQuerystringParameterFromString('manifest', a.search);
                        if (!iiifResourceUri) {
                            // look for collection param
                            iiifResourceUri = Utils.Urls.getQuerystringParameterFromString('collection', a.search);
                        }
                        //var canvasUri = Utils.Urls.getQuerystringParameterFromString('canvas', url.search);
                        if (iiifResourceUri) {
                            _this.fire(BaseEvents_1.BaseEvents.DROP, iiifResourceUri);
                            var data = {};
                            data.iiifResourceUri = iiifResourceUri;
                            _this.reload(data);
                        }
                    }));
                }
                this.$element.on('dragover', (function (e) {
                    // allow drop
                    e.preventDefault();
                }));
                // keyboard events.
                this.$element.on('keyup keydown', function (e) {
                    _this.shifted = e.shiftKey;
                    _this.tabbing = e.keyCode === KeyCodes.KeyDown.Tab;
                });
                this.$element.on('keydown', function (e) {
                    var event = null;
                    var preventDefault = true;
                    if (!e.ctrlKey && !e.altKey && !e.shiftKey) {
                        if (e.keyCode === KeyCodes.KeyDown.Enter) {
                            event = BaseEvents_1.BaseEvents.RETURN;
                            preventDefault = false;
                        }
                        if (e.keyCode === KeyCodes.KeyDown.Escape)
                            event = BaseEvents_1.BaseEvents.ESCAPE;
                        if (e.keyCode === KeyCodes.KeyDown.PageUp)
                            event = BaseEvents_1.BaseEvents.PAGE_UP;
                        if (e.keyCode === KeyCodes.KeyDown.PageDown)
                            event = BaseEvents_1.BaseEvents.PAGE_DOWN;
                        if (e.keyCode === KeyCodes.KeyDown.End)
                            event = BaseEvents_1.BaseEvents.END;
                        if (e.keyCode === KeyCodes.KeyDown.Home)
                            event = BaseEvents_1.BaseEvents.HOME;
                        if (e.keyCode === KeyCodes.KeyDown.NumpadPlus || e.keyCode === 171 || e.keyCode === KeyCodes.KeyDown.Equals) {
                            event = BaseEvents_1.BaseEvents.PLUS;
                            preventDefault = false;
                        }
                        if (e.keyCode === KeyCodes.KeyDown.NumpadMinus || e.keyCode === 173 || e.keyCode === KeyCodes.KeyDown.Dash) {
                            event = BaseEvents_1.BaseEvents.MINUS;
                            preventDefault = false;
                        }
                        if (that.useArrowKeysToNavigate()) {
                            if (e.keyCode === KeyCodes.KeyDown.LeftArrow)
                                event = BaseEvents_1.BaseEvents.LEFT_ARROW;
                            if (e.keyCode === KeyCodes.KeyDown.UpArrow)
                                event = BaseEvents_1.BaseEvents.UP_ARROW;
                            if (e.keyCode === KeyCodes.KeyDown.RightArrow)
                                event = BaseEvents_1.BaseEvents.RIGHT_ARROW;
                            if (e.keyCode === KeyCodes.KeyDown.DownArrow)
                                event = BaseEvents_1.BaseEvents.DOWN_ARROW;
                        }
                    }
                    if (event) {
                        if (preventDefault) {
                            e.preventDefault();
                        }
                        _this.component.publish(event);
                    }
                });
            }
            this.component.subscribe(BaseEvents_1.BaseEvents.EXIT_FULLSCREEN, function () {
                if (_this.isOverlayActive()) {
                    _this.component.publish(BaseEvents_1.BaseEvents.ESCAPE);
                }
                _this.component.publish(BaseEvents_1.BaseEvents.ESCAPE);
                _this.component.publish(BaseEvents_1.BaseEvents.RESIZE);
            });
            this.$element.append('<a href="/" id="top"></a>');
            this.$element.append('<iframe id="commsFrame" style="display:none"></iframe>');
            //this.$element.append('<div id="debug"><span id="watch">Watch</span><span id="mobile-portrait">Mobile Portrait</span><span id="mobile-landscape">Mobile Landscape</span><span id="desktop">Desktop</span></div>');
            this.component.subscribe(BaseEvents_1.BaseEvents.ACCEPT_TERMS, function () {
                _this.fire(BaseEvents_1.BaseEvents.ACCEPT_TERMS);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LOGIN_FAILED, function () {
                _this.fire(BaseEvents_1.BaseEvents.LOGIN_FAILED);
                _this.showMessage(_this.data.config.content.authorisationFailedMessage);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LOGIN, function () {
                _this.isLoggedIn = true;
                _this.fire(BaseEvents_1.BaseEvents.LOGIN);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LOGOUT, function () {
                _this.isLoggedIn = false;
                _this.fire(BaseEvents_1.BaseEvents.LOGOUT);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.BOOKMARK, function () {
                _this.bookmark();
                _this.fire(BaseEvents_1.BaseEvents.BOOKMARK);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED, function () {
                _this.fire(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.data.canvasIndex = canvasIndex;
                _this.lastCanvasIndex = _this.helper.canvasIndex;
                _this.helper.canvasIndex = canvasIndex;
                _this.fire(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.data.canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLICKTHROUGH, function () {
                _this.fire(BaseEvents_1.BaseEvents.CLICKTHROUGH);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLOSE_ACTIVE_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.CLOSE_ACTIVE_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLOSE_LEFT_PANEL, function () {
                _this.fire(BaseEvents_1.BaseEvents.CLOSE_LEFT_PANEL);
                _this.resize();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLOSE_RIGHT_PANEL, function () {
                _this.fire(BaseEvents_1.BaseEvents.CLOSE_RIGHT_PANEL);
                _this.resize();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.COLLECTION_INDEX_CHANGED, function (collectionIndex) {
                _this.data.collectionIndex = collectionIndex;
                _this.fire(BaseEvents_1.BaseEvents.COLLECTION_INDEX_CHANGED, _this.data.collectionIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CREATED, function () {
                _this.isCreated = true;
                _this.fire(BaseEvents_1.BaseEvents.CREATED);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.DOWN_ARROW, function () {
                _this.fire(BaseEvents_1.BaseEvents.DOWN_ARROW);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.DOWNLOAD, function (obj) {
                _this.fire(BaseEvents_1.BaseEvents.DOWNLOAD, obj);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.END, function () {
                _this.fire(BaseEvents_1.BaseEvents.END);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ESCAPE, function () {
                _this.fire(BaseEvents_1.BaseEvents.ESCAPE);
                if (_this.isFullScreen() && !_this.isOverlayActive()) {
                    _this.component.publish(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN);
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.EXTERNAL_LINK_CLICKED, function (url) {
                _this.fire(BaseEvents_1.BaseEvents.EXTERNAL_LINK_CLICKED, url);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.FEEDBACK, function () {
                _this.feedback();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.FORBIDDEN, function () {
                _this.fire(BaseEvents_1.BaseEvents.FORBIDDEN);
                _this.component.publish(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_DOWNLOAD_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_DOWNLOAD_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_EMBED_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_EMBED_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_EXTERNALCONTENT_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_EXTERNALCONTENT_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_GENERIC_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_GENERIC_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_HELP_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_HELP_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_INFORMATION, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_INFORMATION);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_LOGIN_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_LOGIN_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_OVERLAY, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_OVERLAY);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_RESTRICTED_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_RESTRICTED_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_SETTINGS_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.HIDE_SETTINGS_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HOME, function () {
                _this.fire(BaseEvents_1.BaseEvents.HOME);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFT_ARROW, function () {
                _this.fire(BaseEvents_1.BaseEvents.LEFT_ARROW);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH, function () {
                _this.fire(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_START, function () {
                _this.fire(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_START);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_FINISH, function () {
                _this.fire(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_FINISH);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START, function () {
                _this.fire(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LOAD_FAILED, function () {
                _this.fire(BaseEvents_1.BaseEvents.LOAD_FAILED);
                if (!that.lastCanvasIndex == null && that.lastCanvasIndex !== that.helper.canvasIndex) {
                    _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, that.lastCanvasIndex);
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.MANIFEST_INDEX_CHANGED, function (manifestIndex) {
                _this.data.manifestIndex = manifestIndex;
                _this.fire(BaseEvents_1.BaseEvents.MANIFEST_INDEX_CHANGED, _this.data.manifestIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.NOT_FOUND, function () {
                _this.fire(BaseEvents_1.BaseEvents.NOT_FOUND);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN, function () {
                _this.fire(BaseEvents_1.BaseEvents.OPEN);
                var openUri = Utils.Strings.format(_this.data.config.options.openTemplate, _this.helper.iiifResourceUri);
                window.open(openUri);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_LEFT_PANEL, function () {
                _this.fire(BaseEvents_1.BaseEvents.OPEN_LEFT_PANEL);
                _this.resize();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, function () {
                _this.fire(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_RIGHT_PANEL, function () {
                _this.fire(BaseEvents_1.BaseEvents.OPEN_RIGHT_PANEL);
                _this.resize();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.PAGE_DOWN, function () {
                _this.fire(BaseEvents_1.BaseEvents.PAGE_DOWN);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.PAGE_UP, function () {
                _this.fire(BaseEvents_1.BaseEvents.PAGE_UP);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RANGE_CHANGED, function (range) {
                if (range) {
                    _this.data.rangeId = range.id;
                    _this.helper.rangeId = range.id;
                    _this.fire(BaseEvents_1.BaseEvents.RANGE_CHANGED, _this.data.rangeId);
                }
                else {
                    _this.data.rangeId = undefined;
                    _this.helper.rangeId = null;
                    _this.fire(BaseEvents_1.BaseEvents.RANGE_CHANGED, null);
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RESOURCE_DEGRADED, function (resource) {
                _this.fire(BaseEvents_1.BaseEvents.RESOURCE_DEGRADED);
                Auth09_1.Auth09.handleDegraded(resource);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RETURN, function () {
                _this.fire(BaseEvents_1.BaseEvents.RETURN);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RIGHT_ARROW, function () {
                _this.fire(BaseEvents_1.BaseEvents.RIGHT_ARROW);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RIGHTPANEL_COLLAPSE_FULL_FINISH, function () {
                _this.fire(BaseEvents_1.BaseEvents.RIGHTPANEL_COLLAPSE_FULL_FINISH);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RIGHTPANEL_COLLAPSE_FULL_START, function () {
                _this.fire(BaseEvents_1.BaseEvents.RIGHTPANEL_COLLAPSE_FULL_START);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RIGHTPANEL_EXPAND_FULL_FINISH, function () {
                _this.fire(BaseEvents_1.BaseEvents.RIGHTPANEL_EXPAND_FULL_FINISH);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RIGHTPANEL_EXPAND_FULL_START, function () {
                _this.fire(BaseEvents_1.BaseEvents.RIGHTPANEL_EXPAND_FULL_START);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SEQUENCE_INDEX_CHANGED, function (sequenceIndex) {
                _this.data.sequenceIndex = sequenceIndex;
                _this.fire(BaseEvents_1.BaseEvents.SEQUENCE_INDEX_CHANGED, _this.data.sequenceIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, function (args) {
                _this.fire(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, args);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_DOWNLOAD_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_DOWNLOAD_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_EMBED_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_EMBED_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_EXTERNALCONTENT_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_EXTERNALCONTENT_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_GENERIC_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_GENERIC_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_HELP_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_HELP_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_INFORMATION, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_INFORMATION);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_LOGIN_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_LOGIN_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_CLICKTHROUGH_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_CLICKTHROUGH_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_MESSAGE, function (message) {
                _this.showMessage(message);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_RESTRICTED_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_RESTRICTED_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_OVERLAY, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_OVERLAY);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_SETTINGS_DIALOGUE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_SETTINGS_DIALOGUE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_TERMS_OF_USE, function () {
                _this.fire(BaseEvents_1.BaseEvents.SHOW_TERMS_OF_USE);
                var terms = _this.helper.getLicense();
                if (!terms) {
                    var requiredStatement = _this.helper.getRequiredStatement();
                    if (requiredStatement && requiredStatement.value) {
                        terms = requiredStatement.value;
                    }
                }
                if (terms) {
                    _this.showMessage(terms);
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.THUMB_SELECTED, function (thumb) {
                _this.fire(BaseEvents_1.BaseEvents.THUMB_SELECTED, thumb.index);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN, function () {
                $('#top').focus();
                _this.component.isFullScreen = !_this.component.isFullScreen;
                if (_this.component.isFullScreen) {
                    _this.$element.addClass('fullscreen');
                }
                else {
                    _this.$element.removeClass('fullscreen');
                }
                _this.fire(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN, {
                    isFullScreen: _this.component.isFullScreen,
                    overrideFullScreen: _this.data.config.options.overrideFullScreen
                });
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.UP_ARROW, function () {
                _this.fire(BaseEvents_1.BaseEvents.UP_ARROW);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.UPDATE_SETTINGS, function () {
                _this.fire(BaseEvents_1.BaseEvents.UPDATE_SETTINGS);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.VIEW_FULL_TERMS, function () {
                _this.fire(BaseEvents_1.BaseEvents.VIEW_FULL_TERMS);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.WINDOW_UNLOAD, function () {
                _this.fire(BaseEvents_1.BaseEvents.WINDOW_UNLOAD);
            });
            // create shell and shared views.
            this.shell = new Shell_1.Shell(this.$element);
            // dependencies
            this.getDependencies(function (deps) {
                _this.loadDependencies(deps);
            });
        };
        BaseExtension.prototype.createModules = function () {
            this.$authDialogue = $('<div class="overlay auth" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$authDialogue);
            this.authDialogue = new AuthDialogue_1.AuthDialogue(this.$authDialogue);
            this.$clickThroughDialogue = $('<div class="overlay clickthrough" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$clickThroughDialogue);
            this.clickThroughDialogue = new ClickThroughDialogue_1.ClickThroughDialogue(this.$clickThroughDialogue);
            this.$restrictedDialogue = $('<div class="overlay login" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$restrictedDialogue);
            this.restrictedDialogue = new RestrictedDialogue_1.RestrictedDialogue(this.$restrictedDialogue);
            this.$loginDialogue = $('<div class="overlay login" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$loginDialogue);
            this.loginDialogue = new LoginDialogue_1.LoginDialogue(this.$loginDialogue);
        };
        BaseExtension.prototype.modulesCreated = function () {
        };
        BaseExtension.prototype.getDependencies = function (cb) {
            var that = this;
            var depsUri = this.data.root + '/lib/' + this.name + '-dependencies';
            // check if the deps are already loaded
            var scripts = $('script[data-requiremodule]')
                .filter(function () {
                var attr = $(this).attr('data-requiremodule');
                return (attr.indexOf(that.name) !== -1 && attr.indexOf('dependencies') !== -1);
            });
            if (!scripts.length) {
                requirejs([depsUri], function (getDeps) {
                    // getDeps is a function that accepts a file format.
                    // it uses this to determine which dependencies are appropriate
                    // for example, 'application/vnd.apple.mpegurl' for the AV extension
                    // would return hls.min.js, and not dash.all.min.js.
                    var canvas = that.helper.getCurrentCanvas();
                    var mediaFormats = that.getMediaFormats(canvas);
                    var formats = [];
                    if (mediaFormats && mediaFormats.length) {
                        formats = mediaFormats.map(function (f) {
                            return f.getFormat().toString();
                        });
                    }
                    var deps = getDeps(formats);
                    var baseUri = that.data.root + '/lib/';
                    // for each dependency, prepend baseUri unless it starts with a ! which indicates to ignore it.
                    // check for a requirejs.config that sets a specific path, such as the PDF extension
                    if (deps.sync) {
                        for (var i = 0; i < deps.sync.length; i++) {
                            var dep = deps.sync[i];
                            if (!dep.startsWith('!')) {
                                deps.sync[i] = baseUri + dep;
                            }
                        }
                    }
                    if (deps.async) {
                        for (var i = 0; i < deps.async.length; i++) {
                            var dep = deps.async[i];
                            if (!dep.startsWith('!')) {
                                deps.async[i] = baseUri + dep;
                            }
                        }
                    }
                    cb(deps);
                });
            }
            else {
                cb(null);
            }
        };
        BaseExtension.prototype.loadDependencies = function (deps) {
            var that = this;
            if (!deps) {
                that.dependenciesLoaded();
            }
            else if (deps.sync) {
                // load each sync script.
                // necessary for cases like this: https://github.com/mrdoob/three.js/issues/9602
                // then load the async scripts
                SynchronousRequire_1.SynchronousRequire.load(deps.sync, that.dependencyLoaded).then(function () {
                    if (deps.async) {
                        requirejs(deps.async, function () {
                            that.dependenciesLoaded(arguments);
                        });
                    }
                    else {
                        that.dependenciesLoaded();
                    }
                });
            }
            else if (deps.async) {
                requirejs(deps.async, function () {
                    that.dependenciesLoaded(arguments);
                });
            }
            else {
                that.dependenciesLoaded();
            }
        };
        BaseExtension.prototype.dependencyLoaded = function (index, dep) {
        };
        BaseExtension.prototype.dependenciesLoaded = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.createModules();
            this.modulesCreated();
            this.component.publish(BaseEvents_1.BaseEvents.RESIZE); // initial sizing
            setTimeout(function () {
                _this.render();
                _this.component.publish(BaseEvents_1.BaseEvents.CREATED);
                _this._setDefaultFocus();
            }, 1);
        };
        BaseExtension.prototype.render = function () {
            if (!this.isCreated || (this.data.collectionIndex !== this.helper.collectionIndex)) {
                this.component.publish(BaseEvents_1.BaseEvents.COLLECTION_INDEX_CHANGED, this.data.collectionIndex);
            }
            if (!this.isCreated || (this.data.manifestIndex !== this.helper.manifestIndex)) {
                this.component.publish(BaseEvents_1.BaseEvents.MANIFEST_INDEX_CHANGED, this.data.manifestIndex);
            }
            if (!this.isCreated || (this.data.sequenceIndex !== this.helper.sequenceIndex)) {
                this.component.publish(BaseEvents_1.BaseEvents.SEQUENCE_INDEX_CHANGED, this.data.sequenceIndex);
            }
            if (!this.isCreated || (this.data.canvasIndex !== this.helper.canvasIndex)) {
                this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, this.data.canvasIndex);
            }
            if (!this.isCreated || (this.data.rangeId !== this.helper.rangeId)) {
                if (this.data.rangeId) {
                    var range = this.helper.getRangeById(this.data.rangeId);
                    if (range) {
                        this.component.publish(BaseEvents_1.BaseEvents.RANGE_CHANGED, range);
                    }
                    else {
                        console.warn('range id not found:', this.data.rangeId);
                    }
                }
            }
        };
        BaseExtension.prototype._setDefaultFocus = function () {
            var _this = this;
            setTimeout(function () {
                if (_this.data.config.options.allowStealFocus) {
                    $('[tabindex=0]').focus();
                }
            }, 1);
        };
        BaseExtension.prototype.width = function () {
            return this.$element.width();
        };
        BaseExtension.prototype.height = function () {
            return this.$element.height();
        };
        BaseExtension.prototype.exitFullScreen = function () {
            this.component.publish(BaseEvents_1.BaseEvents.EXIT_FULLSCREEN);
        };
        BaseExtension.prototype.fire = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            this.component.fire(name, arguments[1]);
        };
        BaseExtension.prototype.redirect = function (uri) {
            this.fire(BaseEvents_1.BaseEvents.REDIRECT, uri);
        };
        BaseExtension.prototype.refresh = function () {
            this.fire(BaseEvents_1.BaseEvents.REFRESH, null);
        };
        BaseExtension.prototype._initLocales = function () {
            var availableLocales = this.data.config.localisation.locales.slice(0);
            var configuredLocales = this.data.locales;
            var finalLocales = [];
            // loop through configuredLocales array (those passed in when initialising the UV component)
            // if availableLocales (those available in each extension's l10n directory) contains a configured locale, add it to finalLocales.
            // if the configured locale has a label, substitute it
            // mark locale as added.
            // if limitLocales is disabled,
            // loop through remaining availableLocales and add to finalLocales.
            if (configuredLocales) {
                configuredLocales.forEach(function (configuredLocale) {
                    var match = availableLocales.filter(function (item) { return item.name === configuredLocale.name; });
                    if (match.length) {
                        var m = match[0];
                        if (configuredLocale.label)
                            m.label = configuredLocale.label;
                        m.added = true;
                        finalLocales.push(m);
                    }
                });
                var limitLocales = Utils.Bools.getBool(this.data.config.options.limitLocales, false);
                if (!limitLocales) {
                    availableLocales.forEach(function (availableLocale) {
                        if (!availableLocale.added) {
                            finalLocales.push(availableLocale);
                        }
                        delete availableLocale.added;
                    });
                }
                this.data.locales = finalLocales;
            }
            else {
                console.warn("No locales configured");
            }
        };
        BaseExtension.prototype._parseMetrics = function () {
            var metrics = this.data.config.options.metrics;
            if (metrics) {
                for (var i = 0; i < metrics.length; i++) {
                    var m = metrics[i];
                    if (typeof (m.type) === "string") {
                        m.type = new MetricType_1.MetricType(m.type);
                    }
                    this.metrics.push(m);
                }
            }
        };
        BaseExtension.prototype._updateMetric = function () {
            var _this = this;
            setTimeout(function () {
                // loop through all metrics
                // find one that matches the current dimensions
                // if a metric is found, and it's not the current metric, set it to be the current metric and publish a METRIC_CHANGED event
                // if no metric is found, set MetricType.NONE to be the current metric and publish a METRIC_CHANGED event
                var metricFound = false;
                for (var i = 0; i < _this.metrics.length; i++) {
                    var metric = _this.metrics[i];
                    // if the current width and height is within this metric's defined range
                    if (_this.width() >= metric.minWidth && _this.width() <= metric.maxWidth &&
                        _this.height() >= metric.minHeight && _this.height() <= metric.maxHeight) {
                        metricFound = true;
                        if (_this.metric !== metric.type) {
                            _this.metric = metric.type;
                            _this.component.publish(BaseEvents_1.BaseEvents.METRIC_CHANGED);
                        }
                    }
                }
                if (!metricFound) {
                    if (_this.metric !== MetricType_1.MetricType.NONE) {
                        _this.metric = MetricType_1.MetricType.NONE;
                        _this.component.publish(BaseEvents_1.BaseEvents.METRIC_CHANGED);
                    }
                }
            }, 1);
        };
        BaseExtension.prototype.resize = function () {
            this._updateMetric();
            this.component.publish(BaseEvents_1.BaseEvents.RESIZE);
        };
        // re-bootstraps the application with new querystring params
        BaseExtension.prototype.reload = function (data) {
            this.component.publish(BaseEvents_1.BaseEvents.RELOAD, data);
        };
        BaseExtension.prototype.isSeeAlsoEnabled = function () {
            return this.data.config.options.seeAlsoEnabled !== false;
        };
        BaseExtension.prototype.getShareUrl = function () {
            // If not embedded on an external domain (this causes CORS errors when fetching parent url)
            if (!this.data.embedded) {
                // Use the current page URL with hash params
                if (Utils.Documents.isInIFrame()) {
                    return parent.document.location.href;
                }
                else {
                    return document.location.href;
                }
            }
            else {
                // If there's a `related` property of format `text/html` in the manifest
                if (this.helper.hasRelatedPage()) {
                    // Use the `related` property in the URL box
                    var related = this.helper.getRelated();
                    if (related && related.length) {
                        related = related[0];
                    }
                    return related['@id'];
                }
            }
            return null;
        };
        BaseExtension.prototype.getIIIFShareUrl = function () {
            return this.helper.iiifResourceUri + "?manifest=" + this.helper.iiifResourceUri;
        };
        BaseExtension.prototype.addTimestamp = function (uri) {
            return uri + "?t=" + Utils.Dates.getTimeStamp();
        };
        BaseExtension.prototype.getDomain = function () {
            var parts = Utils.Urls.getUrlParts(this.helper.iiifResourceUri);
            return parts.host;
        };
        BaseExtension.prototype.getAppUri = function () {
            var parts = Utils.Urls.getUrlParts(document.location.href);
            var origin = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
            var pathname = parts.pathname;
            if (!pathname.startsWith('/')) {
                pathname = '/' + pathname;
            }
            pathname = pathname.substr(0, pathname.lastIndexOf('/') + 1); // remove the file name
            var appUri = origin + pathname;
            var root = '';
            if (!Utils.Documents.isInIFrame()) {
                root = this.data.root || '';
                if (root.startsWith('./')) {
                    root = root.substr(2);
                }
                if (root && !root.endsWith('/')) {
                    root += '/';
                }
            }
            // if root is a URL, use that instead of appUri.
            if (Utils_1.UVUtils.isValidUrl(root)) {
                return root + 'uv.html';
            }
            return appUri + root + 'uv.html';
        };
        BaseExtension.prototype.getSettings = function () {
            if (Utils.Bools.getBool(this.data.config.options.saveUserSettings, false)) {
                var settings = Utils.Storage.get("uv.settings", Utils.StorageType.local);
                if (settings) {
                    return $.extend(this.data.config.options, settings.value);
                }
            }
            return this.data.config.options;
        };
        BaseExtension.prototype.updateSettings = function (settings) {
            if (Utils.Bools.getBool(this.data.config.options.saveUserSettings, false)) {
                var storedSettings = Utils.Storage.get("uv.settings", Utils.StorageType.local);
                if (storedSettings) {
                    settings = $.extend(storedSettings.value, settings);
                }
                // store for ten years
                Utils.Storage.set("uv.settings", settings, 315360000, Utils.StorageType.local);
            }
            this.data.config.options = $.extend(this.data.config.options, settings);
        };
        BaseExtension.prototype.getLocale = function () {
            return this.helper.options.locale;
        };
        BaseExtension.prototype.getSharePreview = function () {
            var title = this.helper.getLabel();
            // todo: use getThumb (when implemented)
            var canvas = this.helper.getCurrentCanvas();
            var thumbnail = canvas.getProperty('thumbnail');
            if (!thumbnail || !(typeof (thumbnail) === 'string')) {
                thumbnail = canvas.getCanonicalImageUri(this.data.config.options.bookmarkThumbWidth);
            }
            return {
                title: title,
                image: thumbnail
            };
        };
        BaseExtension.prototype.getPagedIndices = function (canvasIndex) {
            if (canvasIndex === void 0) { canvasIndex = this.helper.canvasIndex; }
            return [canvasIndex];
        };
        BaseExtension.prototype.getCurrentCanvases = function () {
            var indices = this.getPagedIndices(this.helper.canvasIndex);
            var canvases = [];
            for (var i = 0; i < indices.length; i++) {
                var index = indices[i];
                var canvas = this.helper.getCanvasByIndex(index);
                canvases.push(canvas);
            }
            return canvases;
        };
        BaseExtension.prototype.getCanvasLabels = function (label) {
            var indices = this.getPagedIndices();
            var labels = "";
            if (indices.length === 1) {
                labels = label;
            }
            else {
                for (var i = 1; i <= indices.length; i++) {
                    if (labels.length)
                        labels += ",";
                    labels += label + " " + i;
                }
            }
            return labels;
        };
        BaseExtension.prototype.getCurrentCanvasRange = function () {
            //var rangePath: string = this.currentRangePath ? this.currentRangePath : '';
            //var range: Manifesto.IRange = this.helper.getCanvasRange(this.helper.getCurrentCanvas(), rangePath);
            var range = this.helper.getCanvasRange(this.helper.getCurrentCanvas());
            return range;
        };
        // todo: move to manifold?
        BaseExtension.prototype.getExternalResources = function (resources) {
            var _this = this;
            var indices = this.getPagedIndices();
            var resourcesToLoad = [];
            indices.forEach(function (index) {
                var canvas = _this.helper.getCanvasByIndex(index);
                var r;
                if (!canvas.externalResource) {
                    r = new Manifold.ExternalResource(canvas, {
                        authApiVersion: _this.data.config.options.authAPIVersion
                    });
                }
                else {
                    r = canvas.externalResource;
                }
                // reload resources if passed
                if (resources) {
                    var found = resources.find(function (f) {
                        return f.dataUri === r.dataUri;
                    });
                    if (found) {
                        resourcesToLoad.push(found);
                    }
                    else {
                        resourcesToLoad.push(r);
                    }
                }
                else {
                    resourcesToLoad.push(r);
                }
            });
            var storageStrategy = this.data.config.options.tokenStorage;
            var authAPIVersion = this.data.config.options.authAPIVersion;
            // if using auth api v1
            if (authAPIVersion === 1) {
                return new Promise(function (resolve) {
                    var options = {
                        locale: _this.helper.options.locale
                    };
                    Auth1_1.Auth1.loadExternalResources(resourcesToLoad, storageStrategy, options).then(function (r) {
                        _this.resources = r.map(function (resource) {
                            return _this._prepareResourceData(resource);
                        });
                        resolve(_this.resources);
                    });
                });
            }
            else {
                return new Promise(function (resolve) {
                    Auth09_1.Auth09.loadExternalResources(resourcesToLoad, storageStrategy).then(function (r) {
                        _this.resources = r.map(function (resource) {
                            return _this._prepareResourceData(resource);
                        });
                        resolve(_this.resources);
                    });
                });
            }
        };
        // copy useful properties over to the data object to be opened in center panel's openMedia method
        // this is the info.json if there is one, which can be opened natively by openseadragon.
        BaseExtension.prototype._prepareResourceData = function (resource) {
            resource.data.hasServiceDescriptor = resource.hasServiceDescriptor();
            // if the data isn't an info.json, give it the necessary viewing properties
            if (!resource.hasServiceDescriptor()) {
                resource.data.id = resource.dataUri;
                resource.data.width = resource.width;
                resource.data.height = resource.height;
            }
            resource.data.index = resource.index;
            return Utils.Objects.toPlainObject(resource.data);
        };
        BaseExtension.prototype.getMediaFormats = function (canvas) {
            var annotations = canvas.getContent();
            if (annotations && annotations.length) {
                var annotation = annotations[0];
                return annotation.getBody();
            }
            else {
                // legacy IxIF compatibility
                var body = {
                    id: canvas.id,
                    type: canvas.getType(),
                    getFormat: function () {
                        return '';
                    }
                };
                return [body];
            }
        };
        BaseExtension.prototype.viewCanvas = function (canvasIndex) {
            if (this.helper.isCanvasIndexOutOfRange(canvasIndex)) {
                this.showMessage(this.data.config.content.canvasIndexOutOfRange);
                return;
            }
            this.component.publish(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE);
        };
        BaseExtension.prototype.showMessage = function (message, acceptCallback, buttonText, allowClose) {
            this.closeActiveDialogue();
            this.component.publish(BaseEvents_1.BaseEvents.SHOW_GENERIC_DIALOGUE, {
                message: message,
                acceptCallback: acceptCallback,
                buttonText: buttonText,
                allowClose: allowClose
            });
        };
        BaseExtension.prototype.closeActiveDialogue = function () {
            this.component.publish(BaseEvents_1.BaseEvents.CLOSE_ACTIVE_DIALOGUE);
        };
        BaseExtension.prototype.isOverlayActive = function () {
            return this.shell.$overlays.is(':visible');
        };
        BaseExtension.prototype.isDesktopMetric = function () {
            return this.metric.toString() === MetricType_1.MetricType.DESKTOP.toString();
        };
        BaseExtension.prototype.isWatchMetric = function () {
            return this.metric.toString() === MetricType_1.MetricType.WATCH.toString();
        };
        BaseExtension.prototype.isCatchAllMetric = function () {
            return this.metric.toString() === MetricType_1.MetricType.NONE.toString();
        };
        // todo: use redux in manifold to get reset state
        BaseExtension.prototype.viewManifest = function (manifest) {
            var data = {};
            data.iiifResourceUri = this.helper.iiifResourceUri;
            data.collectionIndex = this.helper.getCollectionIndex(manifest);
            data.manifestIndex = manifest.index;
            data.sequenceIndex = 0;
            data.canvasIndex = 0;
            this.reload(data);
        };
        // todo: use redux in manifold to get reset state
        BaseExtension.prototype.viewCollection = function (collection) {
            var data = {};
            //data.iiifResourceUri = this.helper.iiifResourceUri;
            data.iiifResourceUri = collection.parentCollection ? collection.parentCollection.id : this.helper.iiifResourceUri;
            data.collectionIndex = collection.index;
            data.manifestIndex = 0;
            data.sequenceIndex = 0;
            data.canvasIndex = 0;
            this.reload(data);
        };
        BaseExtension.prototype.isFullScreen = function () {
            return this.component.isFullScreen;
        };
        BaseExtension.prototype.isHeaderPanelEnabled = function () {
            return Utils.Bools.getBool(this.data.config.options.headerPanelEnabled, true);
        };
        BaseExtension.prototype.isLeftPanelEnabled = function () {
            if (Utils.Bools.getBool(this.data.config.options.leftPanelEnabled, true)) {
                if (this.helper.hasParentCollection()) {
                    return true;
                }
                else if (this.helper.isMultiCanvas()) {
                    var viewingHint = this.helper.getViewingHint();
                    if (!viewingHint || (viewingHint && viewingHint.toString() !== manifesto.ViewingHint.continuous().toString())) {
                        return true;
                    }
                }
            }
            return false;
        };
        BaseExtension.prototype.isRightPanelEnabled = function () {
            return Utils.Bools.getBool(this.data.config.options.rightPanelEnabled, true);
        };
        BaseExtension.prototype.isFooterPanelEnabled = function () {
            return Utils.Bools.getBool(this.data.config.options.footerPanelEnabled, true);
        };
        BaseExtension.prototype.isMobile = function () {
            return $.browser.mobile;
        };
        BaseExtension.prototype.useArrowKeysToNavigate = function () {
            return Utils.Bools.getBool(this.data.config.options.useArrowKeysToNavigate, true);
        };
        BaseExtension.prototype.bookmark = function () {
            // override for each extension
        };
        BaseExtension.prototype.feedback = function () {
            this.fire(BaseEvents_1.BaseEvents.FEEDBACK, this.data);
        };
        BaseExtension.prototype.getAlternateLocale = function () {
            var alternateLocale = null;
            if (this.data.locales && this.data.locales.length > 1) {
                alternateLocale = this.data.locales[1];
            }
            return alternateLocale;
        };
        BaseExtension.prototype.getSerializedLocales = function () {
            if (this.data.locales) {
                return this.serializeLocales(this.data.locales);
            }
            return null;
        };
        BaseExtension.prototype.serializeLocales = function (locales) {
            var serializedLocales = '';
            for (var i = 0; i < locales.length; i++) {
                var l = locales[i];
                if (i > 0)
                    serializedLocales += ',';
                serializedLocales += l.name;
                if (l.label) {
                    serializedLocales += ':' + l.label;
                }
            }
            return serializedLocales;
        };
        BaseExtension.prototype.changeLocale = function (locale) {
            // re-order locales so the passed locale is first
            var data = {};
            if (this.data.locales) {
                data.locales = this.data.locales.slice(0);
                var fromIndex = data.locales.findIndex(function (l) {
                    return l.name === locale;
                });
                var toIndex = 0;
                data.locales.splice(toIndex, 0, data.locales.splice(fromIndex, 1)[0]);
                this.reload(data);
            }
        };
        return BaseExtension;
    }());
    exports.BaseExtension = BaseExtension;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-contentleftpanel-module/GalleryView',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/BaseView"], function (require, exports, BaseEvents_1, BaseView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GalleryView = /** @class */ (function (_super) {
        __extends(GalleryView, _super);
        function GalleryView($element) {
            var _this = _super.call(this, $element, true, true) || this;
            _this.isOpen = false;
            return _this;
        }
        GalleryView.prototype.create = function () {
            this.setConfig('contentLeftPanel');
            _super.prototype.create.call(this);
            // search preview doesn't work well with the gallery because it loads thumbs in "chunks"
            // this.component.subscribe(Events.SEARCH_PREVIEW_START, (e, canvasIndex) => {
            //     this.galleryComponent.searchPreviewStart(canvasIndex);
            // });
            // this.component.subscribe(Events.SEARCH_PREVIEW_FINISH, () => {
            //     this.galleryComponent.searchPreviewFinish();
            // });
            this.$gallery = $('<div class="iiif-gallery-component"></div>');
            this.$element.append(this.$gallery);
            // stencil.js demo
            // const gallery = document.createElement('iiif-gallery');
            // gallery.setAttribute('manifest', this.extension.helper.manifest.id);
            // this.$element[0].appendChild(gallery);
        };
        GalleryView.prototype.setup = function () {
            var that = this;
            this.galleryComponent = new IIIFComponents.GalleryComponent({
                target: this.$gallery[0]
            });
            this.galleryComponent.on('thumbSelected', function (thumb) {
                that.component.publish(BaseEvents_1.BaseEvents.GALLERY_THUMB_SELECTED, thumb);
                that.component.publish(BaseEvents_1.BaseEvents.THUMB_SELECTED, thumb);
            }, false);
            this.galleryComponent.on('decreaseSize', function () {
                that.component.publish(BaseEvents_1.BaseEvents.GALLERY_DECREASE_SIZE);
            }, false);
            this.galleryComponent.on('increaseSize', function () {
                that.component.publish(BaseEvents_1.BaseEvents.GALLERY_INCREASE_SIZE);
            }, false);
        };
        GalleryView.prototype.databind = function () {
            this.galleryComponent.options.data = this.galleryData;
            this.galleryComponent.set(this.galleryData);
            this.resize();
        };
        GalleryView.prototype.show = function () {
            var _this = this;
            this.isOpen = true;
            this.$element.show();
            // todo: would be better to have no imperative methods on components and use a reactive pattern
            setTimeout(function () {
                _this.galleryComponent.selectIndex(_this.extension.helper.canvasIndex);
            }, 10);
        };
        GalleryView.prototype.hide = function () {
            this.isOpen = false;
            this.$element.hide();
        };
        GalleryView.prototype.resize = function () {
            _super.prototype.resize.call(this);
            var $main = this.$gallery.find('.main');
            var $header = this.$gallery.find('.header');
            $main.height(this.$element.height() - $header.height());
        };
        return GalleryView;
    }(BaseView_1.BaseView));
    exports.GalleryView = GalleryView;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/BaseExpandPanel',["require", "exports", "./BaseView"], function (require, exports, BaseView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseExpandPanel = /** @class */ (function (_super) {
        __extends(BaseExpandPanel, _super);
        function BaseExpandPanel($element) {
            var _this = _super.call(this, $element, false, true) || this;
            _this.isExpanded = false;
            _this.isFullyExpanded = false;
            _this.isUnopened = true;
            _this.autoToggled = false;
            _this.expandFullEnabled = true;
            return _this;
        }
        BaseExpandPanel.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            this.$top = $('<div class="top"></div>');
            this.$element.append(this.$top);
            this.$title = $('<div class="title"></div>');
            this.$title.prop('title', this.content.title);
            this.$top.append(this.$title);
            this.$expandFullButton = $('<a class="expandFullButton" tabindex="0"></a>');
            this.$expandFullButton.prop('title', this.content.expandFull);
            this.$top.append(this.$expandFullButton);
            if (!Utils.Bools.getBool(this.config.options.expandFullEnabled, true)) {
                this.$expandFullButton.hide();
            }
            this.$collapseButton = $('<div class="collapseButton" tabindex="0"></div>');
            this.$collapseButton.prop('title', this.content.collapse);
            this.$top.append(this.$collapseButton);
            this.$closed = $('<div class="closed"></div>');
            this.$element.append(this.$closed);
            this.$expandButton = $('<a class="expandButton" tabindex="0"></a>');
            this.$expandButton.prop('title', this.content.expand);
            this.$closed.append(this.$expandButton);
            this.$closedTitle = $('<a class="title"></a>');
            this.$closedTitle.prop('title', this.content.title);
            this.$closed.append(this.$closedTitle);
            this.$main = $('<div class="main"></div>');
            this.$element.append(this.$main);
            this.$expandButton.onPressed(function () {
                _this.toggle();
            });
            this.$expandFullButton.onPressed(function () {
                _this.expandFull();
            });
            this.$closedTitle.onPressed(function () {
                _this.toggle();
            });
            this.$title.onPressed(function () {
                if (_this.isFullyExpanded) {
                    _this.collapseFull();
                }
                else {
                    _this.toggle();
                }
            });
            this.$collapseButton.onPressed(function () {
                if (_this.isFullyExpanded) {
                    _this.collapseFull();
                }
                else {
                    _this.toggle();
                }
            });
            this.$top.hide();
            this.$main.hide();
        };
        BaseExpandPanel.prototype.init = function () {
            _super.prototype.init.call(this);
        };
        BaseExpandPanel.prototype.setTitle = function (title) {
            this.$title.text(title);
            this.$closedTitle.text(title);
        };
        BaseExpandPanel.prototype.toggle = function (autoToggled) {
            var _this = this;
            (autoToggled) ? this.autoToggled = true : this.autoToggled = false;
            // if collapsing, hide contents immediately.
            if (this.isExpanded) {
                this.$top.attr('aria-hidden', 'true');
                this.$main.attr('aria-hidden', 'true');
                this.$closed.attr('aria-hidden', 'false');
                this.$top.hide();
                this.$main.hide();
                this.$closed.show();
            }
            this.$element.stop().animate({
                width: this.getTargetWidth(),
                left: this.getTargetLeft()
            }, this.options.panelAnimationDuration, function () {
                _this.toggled();
            });
        };
        BaseExpandPanel.prototype.toggled = function () {
            this.toggleStart();
            this.isExpanded = !this.isExpanded;
            // if expanded show content when animation finished.
            if (this.isExpanded) {
                this.$top.attr('aria-hidden', 'false');
                this.$main.attr('aria-hidden', 'false');
                this.$closed.attr('aria-hidden', 'true');
                this.$closed.hide();
                this.$top.show();
                this.$main.show();
            }
            this.toggleFinish();
            this.isUnopened = false;
        };
        BaseExpandPanel.prototype.expandFull = function () {
            var _this = this;
            if (!this.isExpanded) {
                this.toggled();
            }
            var targetWidth = this.getFullTargetWidth();
            var targetLeft = this.getFullTargetLeft();
            this.expandFullStart();
            this.$element.stop().animate({
                width: targetWidth,
                left: targetLeft
            }, this.options.panelAnimationDuration, function () {
                _this.expandFullFinish();
            });
        };
        BaseExpandPanel.prototype.collapseFull = function () {
            var _this = this;
            var targetWidth = this.getTargetWidth();
            var targetLeft = this.getTargetLeft();
            this.collapseFullStart();
            this.$element.stop().animate({
                width: targetWidth,
                left: targetLeft
            }, this.options.panelAnimationDuration, function () {
                _this.collapseFullFinish();
            });
        };
        BaseExpandPanel.prototype.getTargetWidth = function () {
            return 0;
        };
        BaseExpandPanel.prototype.getTargetLeft = function () {
            return 0;
        };
        BaseExpandPanel.prototype.getFullTargetWidth = function () {
            return 0;
        };
        BaseExpandPanel.prototype.getFullTargetLeft = function () {
            return 0;
        };
        BaseExpandPanel.prototype.toggleStart = function () {
        };
        BaseExpandPanel.prototype.toggleFinish = function () {
            if (this.isExpanded && !this.autoToggled) {
                this.focusCollapseButton();
            }
            else {
                this.focusExpandButton();
            }
        };
        BaseExpandPanel.prototype.expandFullStart = function () {
        };
        BaseExpandPanel.prototype.expandFullFinish = function () {
            this.isFullyExpanded = true;
            this.$expandFullButton.hide();
            this.focusCollapseButton();
        };
        BaseExpandPanel.prototype.collapseFullStart = function () {
        };
        BaseExpandPanel.prototype.collapseFullFinish = function () {
            this.isFullyExpanded = false;
            if (this.expandFullEnabled) {
                this.$expandFullButton.show();
            }
            this.focusExpandFullButton();
        };
        BaseExpandPanel.prototype.focusExpandButton = function () {
            var _this = this;
            setTimeout(function () {
                _this.$expandButton.focus();
            }, 1);
        };
        BaseExpandPanel.prototype.focusExpandFullButton = function () {
            var _this = this;
            setTimeout(function () {
                _this.$expandFullButton.focus();
            }, 1);
        };
        BaseExpandPanel.prototype.focusCollapseButton = function () {
            var _this = this;
            setTimeout(function () {
                _this.$collapseButton.focus();
            }, 1);
        };
        BaseExpandPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$main.height(this.$element.parent().height() - this.$top.outerHeight(true));
        };
        return BaseExpandPanel;
    }(BaseView_1.BaseView));
    exports.BaseExpandPanel = BaseExpandPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/LeftPanel',["require", "exports", "./BaseEvents", "./BaseExpandPanel"], function (require, exports, BaseEvents_1, BaseExpandPanel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LeftPanel = /** @class */ (function (_super) {
        __extends(LeftPanel, _super);
        function LeftPanel($element) {
            return _super.call(this, $element) || this;
        }
        LeftPanel.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            this.$element.width(this.options.panelCollapsedWidth);
            this.component.subscribe(BaseEvents_1.BaseEvents.TOGGLE_EXPAND_LEFT_PANEL, function () {
                if (_this.isFullyExpanded) {
                    _this.collapseFull();
                }
                else {
                    _this.expandFull();
                }
            });
        };
        LeftPanel.prototype.init = function () {
            _super.prototype.init.call(this);
            var shouldOpenPanel = Utils.Bools.getBool(this.extension.getSettings().leftPanelOpen, this.options.panelOpen);
            if (shouldOpenPanel) {
                this.toggle(true);
            }
        };
        LeftPanel.prototype.getTargetWidth = function () {
            if (this.isFullyExpanded || !this.isExpanded) {
                return this.options.panelExpandedWidth;
            }
            else {
                return this.options.panelCollapsedWidth;
            }
        };
        LeftPanel.prototype.getFullTargetWidth = function () {
            return this.$element.parent().width();
        };
        LeftPanel.prototype.toggleFinish = function () {
            _super.prototype.toggleFinish.call(this);
            if (this.isExpanded) {
                this.component.publish(BaseEvents_1.BaseEvents.OPEN_LEFT_PANEL);
            }
            else {
                this.component.publish(BaseEvents_1.BaseEvents.CLOSE_LEFT_PANEL);
            }
            this.extension.updateSettings({ leftPanelOpen: this.isExpanded });
        };
        LeftPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            if (this.isFullyExpanded) {
                this.$element.width(this.$element.parent().width());
            }
        };
        return LeftPanel;
    }(BaseExpandPanel_1.BaseExpandPanel));
    exports.LeftPanel = LeftPanel;
});

define('extensions/uv-seadragon-extension/Mode',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Mode = /** @class */ (function () {
        function Mode(value) {
            this.value = value;
        }
        Mode.prototype.toString = function () {
            return this.value;
        };
        Mode.image = new Mode("image");
        Mode.page = new Mode("page");
        return Mode;
    }());
    exports.Mode = Mode;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/ThumbsView',["require", "exports", "./BaseEvents", "./BaseView"], function (require, exports, BaseEvents_1, BaseView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ThumbsView = /** @class */ (function (_super) {
        __extends(ThumbsView, _super);
        function ThumbsView($element) {
            var _this = _super.call(this, $element, true, true) || this;
            _this.isCreated = false;
            _this.isOpen = false;
            return _this;
        }
        ThumbsView.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (index) {
                _this.selectIndex(parseInt(index));
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LOGIN, function () {
                _this.loadThumbs();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLICKTHROUGH, function () {
                _this.loadThumbs();
            });
            this.$thumbs = $('<div class="thumbs"></div>');
            this.$element.append(this.$thumbs);
            var viewingDirection = this.extension.helper.getViewingDirection() || manifesto.ViewingDirection.leftToRight();
            this.$thumbs.addClass(viewingDirection.toString()); // defaults to "left-to-right"
            var that = this;
            $.templates({
                thumbsTemplate: '<div id="thumb{{>index}}" class="{{:~className()}}" data-src="{{>uri}}" data-visible="{{>visible}}" data-index="{{>index}}">\
                                <div class="wrap" style="height:{{>height + ~extraHeight()}}px"></div>\
                                <div class="info">\
                                    <span class="index">{{:#index + 1}}</span>\
                                    <span class="label" title="{{>label}}">{{>label}}&nbsp;</span>\
                                    <span class="searchResults" title="{{:~searchResultsTitle()}}">{{>data.searchResults}}</span>\
                                </div>\
                             </div>\
                             {{if ~separator()}} \
                                 <div class="separator"></div> \
                             {{/if}}'
            });
            var extraHeight = this.options.thumbsExtraHeight;
            $.views.helpers({
                separator: function () {
                    return false;
                },
                extraHeight: function () {
                    return extraHeight;
                },
                className: function () {
                    var className = "thumb";
                    if (this.data.index === 0) {
                        className += " first";
                    }
                    if (!this.data.uri) {
                        className += " placeholder";
                    }
                    var viewingDirection = that.extension.helper.getViewingDirection();
                    if (viewingDirection && (viewingDirection.toString() === manifesto.ViewingDirection.leftToRight().toString() || viewingDirection.toString() === manifesto.ViewingDirection.rightToLeft().toString())) {
                        className += " twoCol";
                    }
                    else if (that.extension.helper.isPaged()) {
                        className += " twoCol";
                    }
                    else {
                        className += " oneCol";
                    }
                    return className;
                },
                searchResultsTitle: function () {
                    var searchResults = Number(this.data.data.searchResults);
                    if (searchResults) {
                        if (searchResults > 1) {
                            return Utils.Strings.format(that.content.searchResults, searchResults.toString());
                        }
                        return Utils.Strings.format(that.content.searchResult, searchResults.toString());
                    }
                    return '';
                }
            });
            // use unevent to detect scroll stop.
            this.$element.on('scroll', function () {
                _this.scrollStop();
            }, 100);
            this.resize();
        };
        ThumbsView.prototype.databind = function () {
            if (!this.thumbs)
                return;
            this._$thumbsCache = null; // delete cache
            this.createThumbs();
            // do initial load to show padlocks
            this.loadThumbs(0);
            this.selectIndex(this.extension.helper.canvasIndex);
        };
        ThumbsView.prototype.createThumbs = function () {
            var that = this;
            if (!this.thumbs)
                return;
            // get median height
            var heights = [];
            for (var i = 0; i < this.thumbs.length; i++) {
                var thumb = this.thumbs[i];
                heights.push(thumb.height);
            }
            var medianHeight = Utils.Maths.median(heights);
            for (var i = 0; i < this.thumbs.length; i++) {
                var thumb = this.thumbs[i];
                thumb.height = medianHeight;
            }
            this.$thumbs.link($.templates.thumbsTemplate, this.thumbs);
            this.$thumbs.undelegate('.thumb', 'click');
            this.$thumbs.delegate(".thumb", "click", function (e) {
                e.preventDefault();
                var data = $.view(this).data;
                that.lastThumbClickedIndex = data.index;
                that.component.publish(BaseEvents_1.BaseEvents.THUMB_SELECTED, data);
            });
            this.setLabel();
            this.isCreated = true;
        };
        ThumbsView.prototype.scrollStop = function () {
            var scrollPos = 1 / ((this.$thumbs.height() - this.$element.height()) / this.$element.scrollTop());
            if (scrollPos > 1)
                scrollPos = 1;
            var thumbRangeMid = Math.floor((this.thumbs.length - 1) * scrollPos);
            this.loadThumbs(thumbRangeMid);
        };
        ThumbsView.prototype.loadThumbs = function (index) {
            if (index === void 0) { index = this.extension.helper.canvasIndex; }
            if (!this.thumbs || !this.thumbs.length)
                return;
            var thumbType;
            // get the type of the canvas content
            var canvas = this.extension.helper.getCanvasByIndex(index);
            var annotations = canvas.getContent();
            if (annotations.length) {
                var annotation = annotations[0];
                var body = annotation.getBody();
                if (body.length) {
                    var type = body[0].getType();
                    if (type) {
                        thumbType = type.toString().toLowerCase();
                    }
                }
            }
            var thumbRangeMid = index;
            var thumbLoadRange = this.options.thumbsLoadRange;
            var thumbRange = {
                start: (thumbRangeMid > thumbLoadRange) ? thumbRangeMid - thumbLoadRange : 0,
                end: (thumbRangeMid < (this.thumbs.length - 1) - thumbLoadRange) ? thumbRangeMid + thumbLoadRange : this.thumbs.length - 1
            };
            var fadeDuration = this.options.thumbsImageFadeInDuration;
            var that = this;
            for (var i = thumbRange.start; i <= thumbRange.end; i++) {
                var $thumb = this.getThumbByIndex(i);
                var $wrap = $thumb.find('.wrap');
                // if no img has been added yet
                if (!$wrap.hasClass('loading') && !$wrap.hasClass('loaded')) {
                    var visible = $thumb.attr('data-visible');
                    if (visible !== "false") {
                        $wrap.removeClass('loadingFailed');
                        $wrap.addClass('loading');
                        if (thumbType) {
                            $wrap.addClass(thumbType);
                        }
                        var src = $thumb.attr('data-src');
                        if (that.config.options.thumbsCacheInvalidation && that.config.options.thumbsCacheInvalidation.enabled) {
                            src += that.config.options.thumbsCacheInvalidation.paramType + "t=" + Utils.Dates.getTimeStamp();
                        }
                        var $img = $('<img src="' + src + '" alt=""/>');
                        // fade in on load.
                        $img.hide();
                        $img.on('load', function () {
                            $(this).fadeIn(fadeDuration, function () {
                                $(this).parent().switchClass('loading', 'loaded');
                            });
                        });
                        $img.on('error', function () {
                            $(this).parent().switchClass('loading', 'loadingFailed');
                        });
                        $wrap.append($img);
                    }
                    else {
                        $wrap.addClass('hidden');
                    }
                }
            }
        };
        ThumbsView.prototype.show = function () {
            var _this = this;
            this.isOpen = true;
            this.$element.show();
            setTimeout(function () {
                _this.selectIndex(_this.extension.helper.canvasIndex);
            }, 1);
        };
        ThumbsView.prototype.hide = function () {
            this.isOpen = false;
            this.$element.hide();
        };
        ThumbsView.prototype.isPDF = function () {
            var canvas = this.extension.helper.getCurrentCanvas();
            var type = canvas.getType();
            if (type) {
                return (type.toString().includes("pdf"));
            }
            return false;
        };
        ThumbsView.prototype.setLabel = function () {
            $(this.$thumbs).find('span.index').hide();
            $(this.$thumbs).find('span.label').show();
        };
        ThumbsView.prototype.addSelectedClassToThumbs = function (index) {
            this.getThumbByIndex(index).addClass('selected');
        };
        ThumbsView.prototype.selectIndex = function (index) {
            // may be authenticating
            if (index === -1)
                return;
            if (!this.thumbs || !this.thumbs.length)
                return;
            this.getAllThumbs().removeClass('selected');
            this.$selectedThumb = this.getThumbByIndex(index);
            this.addSelectedClassToThumbs(index);
            var indices = this.extension.getPagedIndices(index);
            // scroll to thumb if the index change didn't originate
            // within the thumbs view.
            if (!~indices.indexOf(this.lastThumbClickedIndex)) {
                this.$element.scrollTop(this.$selectedThumb.position().top);
            }
            // make sure visible images are loaded.
            this.loadThumbs(index);
        };
        ThumbsView.prototype.getAllThumbs = function () {
            if (!this._$thumbsCache) {
                this._$thumbsCache = this.$thumbs.find('.thumb');
            }
            return this._$thumbsCache;
        };
        ThumbsView.prototype.getThumbByIndex = function (canvasIndex) {
            return this.$thumbs.find('[data-index="' + canvasIndex + '"]');
        };
        ThumbsView.prototype.scrollToThumb = function (canvasIndex) {
            var $thumb = this.getThumbByIndex(canvasIndex);
            this.$element.scrollTop($thumb.position().top);
        };
        ThumbsView.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ThumbsView;
    }(BaseView_1.BaseView));
    exports.ThumbsView = ThumbsView;
});

define('extensions/uv-seadragon-extension/Events',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Events = /** @class */ (function () {
        function Events() {
        }
        Events.namespace = 'openseadragonExtension.';
        Events.CURRENT_VIEW_URI = Events.namespace + 'currentViewUri';
        Events.IMAGE_SEARCH = Events.namespace + 'imageSearch';
        Events.MODE_CHANGED = Events.namespace + 'modeChanged';
        Events.NEXT_SEARCH_RESULT = Events.namespace + 'nextSearchResult';
        Events.NEXT_IMAGES_SEARCH_RESULT_UNAVAILABLE = Events.namespace + 'nextImagesSearchResultUnavailable';
        Events.PREV_IMAGES_SEARCH_RESULT_UNAVAILABLE = Events.namespace + 'prevImagesSearchResultUnavailable';
        Events.PAGE_SEARCH = Events.namespace + 'pageSearch';
        Events.PAGING_TOGGLED = Events.namespace + 'pagingToggled';
        Events.PREV_SEARCH_RESULT = Events.namespace + 'prevSearchResult';
        Events.PRINT = Events.namespace + 'print';
        Events.ROTATE = Events.namespace + 'rotate';
        Events.SEADRAGON_ANIMATION_FINISH = Events.namespace + 'animationFinish';
        Events.SEADRAGON_ANIMATION_START = Events.namespace + 'animationStart';
        Events.SEADRAGON_ANIMATION = Events.namespace + 'animation';
        Events.SEADRAGON_OPEN = Events.namespace + 'open';
        Events.SEADRAGON_RESIZE = Events.namespace + 'resize';
        Events.SEADRAGON_ROTATION = Events.namespace + 'rotationChanged';
        Events.SEARCH_PREVIEW_FINISH = Events.namespace + 'searchPreviewFinish';
        Events.SEARCH_PREVIEW_START = Events.namespace + 'searchPreviewStart';
        Events.SEARCH = Events.namespace + 'search';
        Events.XYWH_CHANGED = Events.namespace + 'xywhChanged';
        Events.ZOOM_IN = Events.namespace + 'zoomIn';
        Events.ZOOM_OUT = Events.namespace + 'zoomOut';
        return Events;
    }());
    exports.Events = Events;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-contentleftpanel-module/ThumbsView',["require", "exports", "../uv-shared-module/ThumbsView", "../../extensions/uv-seadragon-extension/Events", "../../extensions/uv-seadragon-extension/Mode"], function (require, exports, ThumbsView_1, Events_1, Mode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ThumbsView = /** @class */ (function (_super) {
        __extends(ThumbsView, _super);
        function ThumbsView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ThumbsView.prototype.create = function () {
            var _this = this;
            this.setConfig('contentLeftPanel');
            _super.prototype.create.call(this);
            // todo: this should be a setting
            this.component.subscribe(Events_1.Events.MODE_CHANGED, function () {
                _this.setLabel();
            });
            this.component.subscribe(Events_1.Events.SEARCH_PREVIEW_START, function (canvasIndex) {
                _this.searchPreviewStart(canvasIndex);
            });
            this.component.subscribe(Events_1.Events.SEARCH_PREVIEW_FINISH, function () {
                _this.searchPreviewFinish();
            });
            if (this.extension.helper.isPaged()) {
                this.$thumbs.addClass('paged');
            }
            var that = this;
            $.views.helpers({
                separator: function () {
                    // two thumbs per line
                    if (that.extension.helper.isPaged()) {
                        return ((this.data.index - 1) % 2 == 0) ? false : true;
                    }
                    return true; // default to one thumbnail per row
                }
            });
        };
        ThumbsView.prototype.addSelectedClassToThumbs = function (index) {
            var indices = this.extension.getPagedIndices(index);
            for (var i = 0; i < indices.length; i++) {
                this.getThumbByIndex(indices[i]).addClass('selected');
            }
        };
        ThumbsView.prototype.isPageModeEnabled = function () {
            // todo: move getMode to BaseExtension. call it getIndexingMode which can be Label or Index
            if (typeof this.extension.getMode === "function") {
                return this.config.options.pageModeEnabled && this.extension.getMode().toString() === Mode_1.Mode.page.toString();
            }
            return this.config.options.pageModeEnabled;
        };
        ThumbsView.prototype.searchPreviewStart = function (canvasIndex) {
            this.scrollToThumb(canvasIndex);
            var $thumb = this.getThumbByIndex(canvasIndex);
            $thumb.addClass('searchpreview');
        };
        ThumbsView.prototype.searchPreviewFinish = function () {
            this.scrollToThumb(this.extension.helper.canvasIndex);
            this.getAllThumbs().removeClass('searchpreview');
        };
        ThumbsView.prototype.setLabel = function () {
            if (this.isPDF()) {
                $(this.$thumbs).find('span.index').hide();
                $(this.$thumbs).find('span.label').hide();
            }
            else {
                if (this.isPageModeEnabled()) {
                    $(this.$thumbs).find('span.index').hide();
                    $(this.$thumbs).find('span.label').show();
                }
                else {
                    $(this.$thumbs).find('span.index').show();
                    $(this.$thumbs).find('span.label').hide();
                }
            }
        };
        return ThumbsView;
    }(ThumbsView_1.ThumbsView));
    exports.ThumbsView = ThumbsView;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-contentleftpanel-module/TreeView',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/BaseView"], function (require, exports, BaseEvents_1, BaseView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TreeView = /** @class */ (function (_super) {
        __extends(TreeView, _super);
        function TreeView($element) {
            var _this = _super.call(this, $element, true, true) || this;
            _this.isOpen = false;
            return _this;
        }
        TreeView.prototype.create = function () {
            this.setConfig('contentLeftPanel');
            _super.prototype.create.call(this);
            this.$tree = $('<div class="iiif-tree-component"></div>');
            this.$element.append(this.$tree);
        };
        TreeView.prototype.setup = function () {
            var that = this;
            this.treeComponent = new IIIFComponents.TreeComponent({
                target: this.$tree[0],
                data: this.treeData
            });
            this.treeComponent.on('treeNodeSelected', function (node) {
                that.component.publish(BaseEvents_1.BaseEvents.TREE_NODE_SELECTED, node);
            }, false);
            this.treeComponent.on('treeNodeMultiSelected', function (node) {
                that.component.publish(BaseEvents_1.BaseEvents.TREE_NODE_MULTISELECTED, node);
            }, false);
        };
        TreeView.prototype.databind = function () {
            this.treeComponent.set(this.treeData);
            this.resize();
        };
        TreeView.prototype.show = function () {
            this.isOpen = true;
            this.$element.show();
        };
        TreeView.prototype.hide = function () {
            this.isOpen = false;
            this.$element.hide();
        };
        TreeView.prototype.selectNode = function (node) {
            if (!this.treeComponent.selectedNode) {
                this.treeComponent.expandParents(node, true);
                var link = this.$tree.find("#tree-link-" + node.id)[0];
                if (link) {
                    link.scrollIntoViewIfNeeded();
                }
            }
            this.treeComponent.selectNode(node);
        };
        TreeView.prototype.expandNode = function (node, expanded) {
            this.treeComponent.expandNode(node, expanded);
        };
        TreeView.prototype.getAllNodes = function () {
            return this.treeComponent.getAllNodes();
        };
        TreeView.prototype.deselectCurrentNode = function () {
            this.treeComponent.deselectCurrentNode();
        };
        TreeView.prototype.getNodeById = function (id) {
            return this.treeComponent.getNodeById(id);
        };
        TreeView.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return TreeView;
    }(BaseView_1.BaseView));
    exports.TreeView = TreeView;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-contentleftpanel-module/ContentLeftPanel',["require", "exports", "../uv-shared-module/BaseEvents", "./GalleryView", "../uv-shared-module/LeftPanel", "../../extensions/uv-seadragon-extension/Mode", "./ThumbsView", "./TreeView"], function (require, exports, BaseEvents_1, GalleryView_1, LeftPanel_1, Mode_1, ThumbsView_1, TreeView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ContentLeftPanel = /** @class */ (function (_super) {
        __extends(ContentLeftPanel, _super);
        function ContentLeftPanel($element) {
            var _this = _super.call(this, $element) || this;
            _this.expandFullEnabled = false;
            _this.isThumbsViewOpen = false;
            _this.isTreeViewOpen = false;
            _this.treeSortType = Manifold.TreeSortType.NONE;
            return _this;
        }
        ContentLeftPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('contentLeftPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, function () {
                _this.databind();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.GALLERY_THUMB_SELECTED, function () {
                _this.collapseFull();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.METRIC_CHANGED, function () {
                if (!_this.extension.isDesktopMetric()) {
                    if (_this.isFullyExpanded) {
                        _this.collapseFull();
                    }
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS, function () {
                _this.databindThumbsView();
                _this.databindGalleryView();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS_CLEARED, function () {
                _this.databindThumbsView();
                _this.databindGalleryView();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS_EMPTY, function () {
                _this.databindThumbsView();
                _this.databindGalleryView();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function () {
                if (_this.isFullyExpanded) {
                    _this.collapseFull();
                }
                _this.selectCurrentTreeNode();
                _this.updateTreeTabBySelection();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RANGE_CHANGED, function () {
                if (_this.isFullyExpanded) {
                    _this.collapseFull();
                }
                _this.selectCurrentTreeNode();
                _this.updateTreeTabBySelection();
            });
            this.$tabs = $('<div class="tabs"></div>');
            this.$main.append(this.$tabs);
            this.$treeButton = $('<a class="index tab" tabindex="0">' + this.content.index + '</a>');
            this.$tabs.append(this.$treeButton);
            this.$thumbsButton = $('<a class="thumbs tab" tabindex="0">' + this.content.thumbnails + '</a>');
            this.$thumbsButton.prop('title', this.content.thumbnails);
            this.$tabs.append(this.$thumbsButton);
            this.$tabsContent = $('<div class="tabsContent"></div>');
            this.$main.append(this.$tabsContent);
            this.$options = $('<div class="options"></div>');
            this.$tabsContent.append(this.$options);
            this.$topOptions = $('<div class="top"></div>');
            this.$options.append(this.$topOptions);
            this.$treeSelect = $('<select aria-label="' + this.content.manifestRanges + '"></select>');
            this.$topOptions.append(this.$treeSelect);
            this.$bottomOptions = $('<div class="bottom"></div>');
            this.$options.append(this.$bottomOptions);
            this.$leftOptions = $('<div class="left"></div>');
            this.$bottomOptions.append(this.$leftOptions);
            this.$rightOptions = $('<div class="right"></div>');
            this.$bottomOptions.append(this.$rightOptions);
            this.$treeViewOptions = $('<div class="treeView"></div>');
            this.$leftOptions.append(this.$treeViewOptions);
            this.$sortByLabel = $('<span class="sort">' + this.content.sortBy + '</span>');
            this.$treeViewOptions.append(this.$sortByLabel);
            this.$sortButtonGroup = $('<div class="btn-group"></div>');
            this.$treeViewOptions.append(this.$sortButtonGroup);
            this.$sortByDateButton = $('<button class="btn tabindex="0"">' + this.content.date + '</button>');
            this.$sortButtonGroup.append(this.$sortByDateButton);
            this.$sortByVolumeButton = $('<button class="btn" tabindex="0">' + this.content.volume + '</button>');
            this.$sortButtonGroup.append(this.$sortByVolumeButton);
            this.$views = $('<div class="views"></div>');
            this.$tabsContent.append(this.$views);
            this.$treeView = $('<div class="treeView"></div>');
            this.$views.append(this.$treeView);
            this.$thumbsView = $('<div class="thumbsView" tabindex="0"></div>');
            this.$views.append(this.$thumbsView);
            this.$galleryView = $('<div class="galleryView"></div>');
            this.$views.append(this.$galleryView);
            this.$treeSelect.hide();
            this.$treeSelect.change(function () {
                _this.databindTreeView();
                _this.selectCurrentTreeNode();
                _this.updateTreeTabBySelection();
            });
            this.$sortByDateButton.on('click', function () {
                _this.sortByDate();
            });
            this.$sortByVolumeButton.on('click', function () {
                _this.sortByVolume();
            });
            this.$treeViewOptions.hide();
            this.$treeButton.onPressed(function () {
                _this.openTreeView();
            });
            this.$thumbsButton.onPressed(function () {
                _this.openThumbsView();
            });
            this.setTitle(this.content.title);
            this.$sortByVolumeButton.addClass('on');
            var tabOrderConfig = this.options.tabOrder;
            if (tabOrderConfig) {
                // sort tabs
                tabOrderConfig = tabOrderConfig.toLowerCase();
                tabOrderConfig = tabOrderConfig.replace(/ /g, "");
                var tabOrder = tabOrderConfig.split(',');
                if (tabOrder[0] === 'thumbs') {
                    this.$treeButton.before(this.$thumbsButton);
                    this.$thumbsButton.addClass('first');
                }
                else {
                    this.$treeButton.addClass('first');
                }
            }
        };
        ContentLeftPanel.prototype.createTreeView = function () {
            this.treeView = new TreeView_1.TreeView(this.$treeView);
            this.treeView.treeData = this.getTreeData();
            this.treeView.setup();
            this.databindTreeView();
            // populate the tree select drop down when there are multiple top-level ranges
            var topRanges = this.extension.helper.getTopRanges();
            if (topRanges.length > 1) {
                for (var i = 0; i < topRanges.length; i++) {
                    var range = topRanges[i];
                    this.$treeSelect.append('<option value="' + range.id + '">' + Manifesto.LanguageMap.getValue(range.getLabel()) + '</option>');
                }
            }
            this.updateTreeViewOptions();
        };
        ContentLeftPanel.prototype.databind = function () {
            this.databindThumbsView();
            this.databindTreeView();
            this.databindGalleryView();
        };
        ContentLeftPanel.prototype.updateTreeViewOptions = function () {
            var treeData = this.getTree();
            if (!treeData) {
                return;
            }
            if (this.isCollection() && this.extension.helper.treeHasNavDates(treeData)) {
                this.$treeViewOptions.show();
            }
            else {
                this.$treeViewOptions.hide();
            }
            if (this.$treeSelect.find('option').length) {
                this.$treeSelect.show();
            }
            else {
                this.$treeSelect.hide();
            }
        };
        ContentLeftPanel.prototype.sortByDate = function () {
            this.treeSortType = Manifold.TreeSortType.DATE;
            this.treeView.treeData = this.getTreeData();
            this.treeView.databind();
            this.selectCurrentTreeNode();
            this.$sortByDateButton.addClass('on');
            this.$sortByVolumeButton.removeClass('on');
            this.resize();
        };
        ContentLeftPanel.prototype.sortByVolume = function () {
            this.treeSortType = Manifold.TreeSortType.NONE;
            this.treeView.treeData = this.getTreeData();
            this.treeView.databind();
            this.selectCurrentTreeNode();
            this.$sortByDateButton.removeClass('on');
            this.$sortByVolumeButton.addClass('on');
            this.resize();
        };
        ContentLeftPanel.prototype.isCollection = function () {
            var treeData = this.getTree();
            if (treeData) {
                return treeData.data.type === manifesto.TreeNodeType.collection().toString();
            }
            throw new Error("Tree not available");
        };
        ContentLeftPanel.prototype.databindTreeView = function () {
            if (!this.treeView)
                return;
            this.treeView.treeData = this.getTreeData();
            this.treeView.databind();
            this.selectCurrentTreeNode();
        };
        ContentLeftPanel.prototype.getTreeData = function () {
            return {
                autoExpand: this._isTreeAutoExpanded(),
                branchNodesExpandOnClick: Utils.Bools.getBool(this.config.options.branchNodesExpandOnClick, true),
                branchNodesSelectable: Utils.Bools.getBool(this.config.options.branchNodesSelectable, false),
                helper: this.extension.helper,
                topRangeIndex: this.getSelectedTopRangeIndex(),
                treeSortType: this.treeSortType
            };
        };
        ContentLeftPanel.prototype._isTreeAutoExpanded = function () {
            var autoExpandTreeEnabled = Utils.Bools.getBool(this.config.options.autoExpandTreeEnabled, false);
            var autoExpandTreeIfFewerThan = this.config.options.autoExpandTreeIfFewerThan || 0;
            if (autoExpandTreeEnabled) {
                // get total number of tree nodes
                var flatTree = this.extension.helper.getFlattenedTree();
                if (flatTree.length < autoExpandTreeIfFewerThan) {
                    return true;
                }
            }
            return false;
        };
        ContentLeftPanel.prototype.updateTreeTabByCanvasIndex = function () {
            // update tab to current top range label (if there is one)
            var topRanges = this.extension.helper.getTopRanges();
            if (topRanges.length > 1) {
                var index = this.getCurrentCanvasTopRangeIndex();
                if (index === -1) {
                    return;
                }
                var currentRange = topRanges[index];
                this.setTreeTabTitle(Manifesto.LanguageMap.getValue(currentRange.getLabel()));
            }
            else {
                this.setTreeTabTitle(this.content.index);
            }
        };
        ContentLeftPanel.prototype.setTreeTabTitle = function (title) {
            this.$treeButton.text(title);
            this.$treeButton.prop('title', title);
        };
        ContentLeftPanel.prototype.updateTreeTabBySelection = function () {
            var title = null;
            var topRanges = this.extension.helper.getTopRanges();
            if (topRanges.length > 1) {
                if (this.treeView) {
                    title = this.getSelectedTree().text();
                }
                else {
                    title = Manifesto.LanguageMap.getValue(topRanges[0].getLabel());
                }
            }
            if (title) {
                this.setTreeTabTitle(title);
            }
            else {
                this.setTreeTabTitle(this.content.index);
            }
        };
        ContentLeftPanel.prototype.getViewingHint = function () {
            return this.extension.helper.getViewingHint();
        };
        ContentLeftPanel.prototype.getViewingDirection = function () {
            return this.extension.helper.getViewingDirection();
        };
        ContentLeftPanel.prototype.createThumbsView = function () {
            this.thumbsView = new ThumbsView_1.ThumbsView(this.$thumbsView);
            this.databindThumbsView();
        };
        ContentLeftPanel.prototype.databindThumbsView = function () {
            if (!this.thumbsView)
                return;
            var width;
            var height;
            var viewingHint = this.getViewingHint();
            var viewingDirection = this.getViewingDirection();
            if (viewingDirection && (viewingDirection.toString() === manifesto.ViewingDirection.leftToRight().toString() || viewingDirection.toString() === manifesto.ViewingDirection.rightToLeft().toString())) {
                width = this.config.options.twoColThumbWidth;
                height = this.config.options.twoColThumbHeight;
            }
            else if (viewingHint && viewingHint.toString() === manifesto.ViewingHint.paged().toString()) {
                width = this.config.options.twoColThumbWidth;
                height = this.config.options.twoColThumbHeight;
            }
            else {
                width = this.config.options.oneColThumbWidth;
                height = this.config.options.oneColThumbHeight;
            }
            var thumbs = this.extension.helper.getThumbs(width, height);
            if (viewingDirection && viewingDirection.toString() === manifesto.ViewingDirection.bottomToTop().toString()) {
                thumbs.reverse();
            }
            // add a search result icon for pages with results
            var searchResults = this.extension.annotations;
            if (searchResults && searchResults.length) {
                var _loop_1 = function (i) {
                    var searchResult = searchResults[i];
                    // find the thumb with the same canvasIndex and add the searchResult
                    var thumb = thumbs.en().where(function (t) { return t.index === searchResult.canvasIndex; }).first();
                    if (thumb) {
                        // clone the data so searchResults isn't persisted on the canvas.
                        var data = $.extend(true, {}, thumb.data);
                        data.searchResults = searchResult.rects.length;
                        thumb.data = data;
                    }
                };
                for (var i = 0; i < searchResults.length; i++) {
                    _loop_1(i);
                }
            }
            this.thumbsView.thumbs = thumbs;
            this.thumbsView.databind();
        };
        ContentLeftPanel.prototype.createGalleryView = function () {
            this.galleryView = new GalleryView_1.GalleryView(this.$galleryView);
            this.galleryView.galleryData = this.getGalleryData();
            this.galleryView.setup();
            this.databindGalleryView();
        };
        ContentLeftPanel.prototype.databindGalleryView = function () {
            if (!this.galleryView)
                return;
            this.galleryView.galleryData = this.getGalleryData();
            this.galleryView.databind();
        };
        ContentLeftPanel.prototype.getGalleryData = function () {
            return {
                helper: this.extension.helper,
                chunkedResizingThreshold: this.config.options.galleryThumbChunkedResizingThreshold,
                content: this.config.content,
                debug: false,
                imageFadeInDuration: 300,
                initialZoom: 6,
                minLabelWidth: 20,
                pageModeEnabled: this.isPageModeEnabled(),
                scrollStopDuration: 100,
                searchResults: this.extension.annotations,
                sizingEnabled: Modernizr.inputtypes.range,
                thumbHeight: this.config.options.galleryThumbHeight,
                thumbLoadPadding: this.config.options.galleryThumbLoadPadding,
                thumbWidth: this.config.options.galleryThumbWidth,
                viewingDirection: this.getViewingDirection()
            };
        };
        ContentLeftPanel.prototype.isPageModeEnabled = function () {
            // todo: checks if the panel is being used in the openseadragon extension.
            // pass a `isPageModeEnabled` function to the panel's constructor instead?
            if (typeof this.extension.getMode === "function") {
                return Utils.Bools.getBool(this.config.options.pageModeEnabled, true) && this.extension.getMode().toString() === Mode_1.Mode.page.toString();
            }
            return Utils.Bools.getBool(this.config.options.pageModeEnabled, true);
        };
        ContentLeftPanel.prototype.getSelectedTree = function () {
            return this.$treeSelect.find(':selected');
        };
        ContentLeftPanel.prototype.getSelectedTopRangeIndex = function () {
            var topRangeIndex = this.getSelectedTree().index();
            if (topRangeIndex === -1) {
                topRangeIndex = 0;
            }
            return topRangeIndex;
        };
        ContentLeftPanel.prototype.getTree = function () {
            var topRangeIndex = this.getSelectedTopRangeIndex();
            return this.extension.helper.getTree(topRangeIndex, Manifold.TreeSortType.NONE);
        };
        ContentLeftPanel.prototype.toggleFinish = function () {
            _super.prototype.toggleFinish.call(this);
            if (this.isUnopened) {
                var treeEnabled = Utils.Bools.getBool(this.config.options.treeEnabled, true);
                var thumbsEnabled = Utils.Bools.getBool(this.config.options.thumbsEnabled, true);
                var treeData = this.getTree();
                if (!treeData || !treeData.nodes.length) {
                    treeEnabled = false;
                }
                // hide the tabs if either tree or thumbs are disabled
                if (!treeEnabled || !thumbsEnabled)
                    this.$tabs.hide();
                if (thumbsEnabled && this.defaultToThumbsView()) {
                    this.openThumbsView();
                }
                else if (treeEnabled) {
                    this.openTreeView();
                }
            }
        };
        ContentLeftPanel.prototype.defaultToThumbsView = function () {
            var defaultToTreeEnabled = Utils.Bools.getBool(this.config.options.defaultToTreeEnabled, false);
            var defaultToTreeIfGreaterThan = this.config.options.defaultToTreeIfGreaterThan || 0;
            var treeData = this.getTree();
            if (defaultToTreeEnabled) {
                if (treeData && treeData.nodes.length > defaultToTreeIfGreaterThan) {
                    return false;
                }
            }
            return true;
        };
        ContentLeftPanel.prototype.expandFullStart = function () {
            _super.prototype.expandFullStart.call(this);
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START);
        };
        ContentLeftPanel.prototype.expandFullFinish = function () {
            _super.prototype.expandFullFinish.call(this);
            if (this.$treeButton.hasClass('on')) {
                this.openTreeView();
            }
            else if (this.$thumbsButton.hasClass('on')) {
                this.openThumbsView();
            }
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_FINISH);
        };
        ContentLeftPanel.prototype.collapseFullStart = function () {
            _super.prototype.collapseFullStart.call(this);
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_START);
        };
        ContentLeftPanel.prototype.collapseFullFinish = function () {
            _super.prototype.collapseFullFinish.call(this);
            // todo: write a more generic tabs system with base tab class.
            // thumbsView may not necessarily have been created yet.
            // replace thumbsView with galleryView.
            if (this.$thumbsButton.hasClass('on')) {
                this.openThumbsView();
            }
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH);
        };
        ContentLeftPanel.prototype.openTreeView = function () {
            this.isTreeViewOpen = true;
            this.isThumbsViewOpen = false;
            if (!this.treeView) {
                this.createTreeView();
            }
            this.$treeButton.addClass('on');
            this.$thumbsButton.removeClass('on');
            this.treeView.show();
            if (this.thumbsView)
                this.thumbsView.hide();
            if (this.galleryView)
                this.galleryView.hide();
            this.updateTreeViewOptions();
            this.selectCurrentTreeNode();
            this.resize();
            this.treeView.resize();
            this.component.publish(BaseEvents_1.BaseEvents.OPEN_TREE_VIEW);
        };
        ContentLeftPanel.prototype.openThumbsView = function () {
            this.isTreeViewOpen = false;
            this.isThumbsViewOpen = true;
            if (!this.thumbsView) {
                this.createThumbsView();
            }
            if (this.isFullyExpanded && !this.galleryView) {
                this.createGalleryView();
            }
            this.$treeButton.removeClass('on');
            this.$thumbsButton.addClass('on');
            if (this.treeView)
                this.treeView.hide();
            this.$treeSelect.hide();
            this.$treeViewOptions.hide();
            this.resize();
            if (this.isFullyExpanded) {
                this.thumbsView.hide();
                if (this.galleryView)
                    this.galleryView.show();
                if (this.galleryView)
                    this.galleryView.resize();
            }
            else {
                if (this.galleryView)
                    this.galleryView.hide();
                this.thumbsView.show();
                this.thumbsView.resize();
            }
            this.component.publish(BaseEvents_1.BaseEvents.OPEN_THUMBS_VIEW);
        };
        ContentLeftPanel.prototype.selectTopRangeIndex = function (index) {
            this.$treeSelect.prop('selectedIndex', index);
        };
        ContentLeftPanel.prototype.getCurrentCanvasTopRangeIndex = function () {
            var topRangeIndex = -1;
            var range = this.extension.getCurrentCanvasRange();
            if (range) {
                topRangeIndex = Number(range.path.split('/')[0]);
            }
            return topRangeIndex;
        };
        ContentLeftPanel.prototype.selectCurrentTreeNode = function () {
            // todo: merge selectCurrentTreeNodeByCanvas and selectCurrentTreeNodeByRange
            // the openseadragon extension should keep track of the current range instead of using canvas index
            if (this.extension.name === 'uv-seadragon-extension') {
                this.selectCurrentTreeNodeByCanvas();
            }
            else {
                this.selectCurrentTreeNodeByRange();
            }
        };
        ContentLeftPanel.prototype.selectCurrentTreeNodeByRange = function () {
            if (this.treeView) {
                var range = this.extension.helper.getCurrentRange();
                var node = null;
                if (range && range.treeNode) {
                    node = this.treeView.getNodeById(range.treeNode.id);
                }
                if (node) {
                    this.treeView.selectNode(node);
                }
                else {
                    this.selectTreeNodeByManifest();
                }
            }
        };
        ContentLeftPanel.prototype.selectCurrentTreeNodeByCanvas = function () {
            if (this.treeView) {
                var node = null;
                var currentCanvasTopRangeIndex = this.getCurrentCanvasTopRangeIndex();
                var selectedTopRangeIndex = this.getSelectedTopRangeIndex();
                var usingCorrectTree = currentCanvasTopRangeIndex === selectedTopRangeIndex;
                var range = null;
                if (currentCanvasTopRangeIndex !== -1) {
                    range = this.extension.getCurrentCanvasRange();
                    //range = this.extension.helper.getCurrentRange();
                    if (range && range.treeNode) {
                        node = this.treeView.getNodeById(range.treeNode.id);
                    }
                }
                // use manifest root node
                // if (!node){
                //     id = this.extension.helper.manifest.defaultTree.id;
                //     node = this.treeView.getNodeById(id);
                // }
                if (node && usingCorrectTree) {
                    this.treeView.selectNode(node);
                }
                else {
                    range = this.extension.helper.getCurrentRange();
                    if (range && range.treeNode) {
                        node = this.treeView.getNodeById(range.treeNode.id);
                    }
                    if (node) {
                        this.treeView.selectNode(node);
                    }
                    else {
                        this.selectTreeNodeByManifest();
                    }
                }
            }
        };
        // fall through to this is there's no current range or canvas
        ContentLeftPanel.prototype.selectTreeNodeByManifest = function () {
            var _this = this;
            var collectionIndex = this.extension.helper.collectionIndex;
            var manifestIndex = this.extension.helper.manifestIndex;
            var allNodes = this.treeView.getAllNodes();
            var nodeFound = false;
            allNodes.map(function (node) {
                if (node.isCollection() && node.data.index === collectionIndex) {
                    _this.treeView.selectNode(node);
                    _this.treeView.expandNode(node, true);
                    nodeFound = true;
                }
                if (node.isManifest() && node.data.index === manifestIndex) {
                    _this.treeView.selectNode(node);
                    nodeFound = true;
                }
            });
            if (!nodeFound) {
                this.treeView.deselectCurrentNode();
            }
        };
        ContentLeftPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$tabsContent.height(this.$main.height() - (this.$tabs.is(':visible') ? this.$tabs.height() : 0) - this.$tabsContent.verticalPadding());
            this.$views.height(this.$tabsContent.height() - this.$options.outerHeight());
        };
        return ContentLeftPanel;
    }(LeftPanel_1.LeftPanel));
    exports.ContentLeftPanel = ContentLeftPanel;
});

define('modules/uv-shared-module/DownloadOption',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownloadOption;
    (function (DownloadOption) {
        DownloadOption["CANVAS_RENDERINGS"] = "canvasRenderings";
        DownloadOption["CURRENT_VIEW"] = "currentView";
        DownloadOption["ENTIRE_DOCUMENT_AS_PDF"] = "entireDocumentAsPdf";
        DownloadOption["ENTIRE_DOCUMENT_AS_TEXT"] = "entireDocumentAsText";
        DownloadOption["ENTIRE_FILE_AS_ORIGINAL"] = "entireFileAsOriginal";
        DownloadOption["IMAGE_RENDERINGS"] = "imageRenderings";
        DownloadOption["MANIFEST_RENDERINGS"] = "manifestRenderings";
        DownloadOption["RANGE_RENDERINGS"] = "rangeRenderings";
        DownloadOption["SELECTION"] = "selection";
        //SEQUENCE_RENDERINGS = "sequenceRenderings",
        DownloadOption["UNKNOWN"] = "unknown";
        DownloadOption["WHOLE_IMAGE_HIGH_RES"] = "wholeImageHighRes";
        DownloadOption["WHOLE_IMAGE_LOW_RES"] = "wholeImageLowRes";
        DownloadOption["WHOLE_IMAGES_HIGH_RES"] = "wholeImagesHighRes";
    })(DownloadOption = exports.DownloadOption || (exports.DownloadOption = {}));
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/DownloadDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue", "../uv-shared-module/DownloadOption"], function (require, exports, BaseEvents_1, Dialogue_1, DownloadOption_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownloadDialogue = /** @class */ (function (_super) {
        __extends(DownloadDialogue, _super);
        function DownloadDialogue($element) {
            return _super.call(this, $element) || this;
        }
        DownloadDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('downloadDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_DOWNLOAD_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_DOWNLOAD_DIALOGUE;
            this.component.subscribe(this.openCommand, function (triggerButton) {
                _this.open(triggerButton);
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            // create ui.
            this.$title = $('<h1>' + this.content.title + '</h1>');
            this.$content.append(this.$title);
            this.$noneAvailable = $('<div class="noneAvailable">' + this.content.noneAvailable + '</div>');
            this.$content.append(this.$noneAvailable);
            this.$downloadOptions = $('<ol class="options"></ol>');
            this.$content.append(this.$downloadOptions);
            this.$footer = $('<div class="footer"></div>');
            this.$content.append(this.$footer);
            this.$termsOfUseButton = $('<a href="#">' + this.extension.data.config.content.termsOfUse + '</a>');
            this.$footer.append(this.$termsOfUseButton);
            this.$termsOfUseButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_TERMS_OF_USE);
            });
            // hide
            this.$element.hide();
            this.updateTermsOfUseButton();
        };
        DownloadDialogue.prototype.addEntireFileDownloadOptions = function () {
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.ENTIRE_FILE_AS_ORIGINAL)) {
                this.$downloadOptions.empty();
                //
                // add each file src
                var canvas = this.extension.helper.getCurrentCanvas();
                var renderingFound = false;
                var renderings = canvas.getRenderings();
                for (var i = 0; i < renderings.length; i++) {
                    var rendering = renderings[i];
                    var renderingFormat = rendering.getFormat();
                    var format = '';
                    if (renderingFormat) {
                        format = renderingFormat.toString();
                    }
                    this.addEntireFileDownloadOption(rendering.id, Manifesto.LanguageMap.getValue(rendering.getLabel()), format);
                    renderingFound = true;
                }
                if (!renderingFound) {
                    var annotationFound = false;
                    var annotations = canvas.getContent();
                    for (var i = 0; i < annotations.length; i++) {
                        var annotation = annotations[i];
                        var body = annotation.getBody();
                        if (body.length) {
                            var format = body[0].getFormat();
                            if (format) {
                                this.addEntireFileDownloadOption(body[0].id, '', format.toString());
                                annotationFound = true;
                            }
                        }
                    }
                    if (!annotationFound) {
                        this.addEntireFileDownloadOption(canvas.id, '', '');
                    }
                }
            }
        };
        DownloadDialogue.prototype.addEntireFileDownloadOption = function (uri, label, format) {
            var fileType;
            if (format) {
                fileType = Utils.Files.simplifyMimeType(format);
            }
            else {
                fileType = this.getFileExtension(uri);
            }
            if (!label) {
                label = this.content.entireFileAsOriginal;
            }
            if (fileType) {
                label += " (" + fileType + ")";
            }
            this.$downloadOptions.append('<li><a href="' + uri + '" target="_blank" download tabindex="0">' + label + '</li>');
        };
        DownloadDialogue.prototype.resetDynamicDownloadOptions = function () {
            this.renderingUrls = [];
            this.renderingUrlsCount = 0;
            this.$downloadOptions.find('li.dynamic').remove();
        };
        DownloadDialogue.prototype.getDownloadOptionsForRenderings = function (resource, defaultLabel, type) {
            var renderings = resource.getRenderings();
            var downloadOptions = [];
            for (var i = 0; i < renderings.length; i++) {
                var rendering = renderings[i];
                if (rendering) {
                    var label = Manifesto.LanguageMap.getValue(rendering.getLabel(), this.extension.getLocale());
                    var currentId = "downloadOption" + ++this.renderingUrlsCount;
                    if (label) {
                        label += " ({0})";
                    }
                    else {
                        label = defaultLabel;
                    }
                    var mime = Utils.Files.simplifyMimeType(rendering.getFormat().toString());
                    label = Utils.Strings.format(label, mime);
                    this.renderingUrls[currentId] = rendering.id;
                    var $button = $('<li class="option dynamic"><input id="' + currentId + '" data-mime="' + mime + '" title="' + label + '" type="radio" name="downloadOptions" tabindex="0" /><label for="' + currentId + '">' + label + '</label></li>');
                    downloadOptions.push({
                        type: type,
                        button: $button
                    });
                }
            }
            return downloadOptions;
        };
        DownloadDialogue.prototype.getSelectedOption = function () {
            return this.$downloadOptions.find("li.option input:checked");
        };
        DownloadDialogue.prototype.getCurrentResourceId = function () {
            var canvas = this.extension.helper.getCurrentCanvas();
            return canvas.externalResource.data.id;
        };
        DownloadDialogue.prototype.getCurrentResourceFormat = function () {
            var id = this.getCurrentResourceId();
            return id.substr(id.lastIndexOf('.') + 1).toLowerCase();
        };
        DownloadDialogue.prototype.updateNoneAvailable = function () {
            if (!this.$downloadOptions.find('li:visible').length) {
                this.$noneAvailable.show();
            }
            else {
                // select first option.
                this.$noneAvailable.hide();
            }
        };
        DownloadDialogue.prototype.updateTermsOfUseButton = function () {
            var requiredStatement = this.extension.helper.getRequiredStatement();
            if (Utils.Bools.getBool(this.extension.data.config.options.termsOfUseEnabled, false) && requiredStatement && requiredStatement.value) {
                this.$termsOfUseButton.show();
            }
            else {
                this.$termsOfUseButton.hide();
            }
        };
        DownloadDialogue.prototype.getFileExtension = function (fileUri) {
            var extension = fileUri.split('.').pop();
            // if it's not a valid file extension
            if (extension.length > 5 || extension.indexOf('/') !== -1) {
                return null;
            }
            return extension;
        };
        DownloadDialogue.prototype.isMediaDownloadEnabled = function () {
            return this.extension.helper.isUIEnabled('mediaDownload');
        };
        DownloadDialogue.prototype.isDownloadOptionAvailable = function (option) {
            switch (option) {
                case DownloadOption_1.DownloadOption.ENTIRE_FILE_AS_ORIGINAL:
                    return this.isMediaDownloadEnabled();
            }
            return true;
        };
        DownloadDialogue.prototype.close = function () {
            _super.prototype.close.call(this);
        };
        DownloadDialogue.prototype.resize = function () {
            this.setDockedPosition();
        };
        return DownloadDialogue;
    }(Dialogue_1.Dialogue));
    exports.DownloadDialogue = DownloadDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-av-extension/DownloadDialogue',["require", "exports", "../../modules/uv-dialogues-module/DownloadDialogue", "../../modules/uv-shared-module/DownloadOption", "../../modules/uv-shared-module/BaseEvents"], function (require, exports, DownloadDialogue_1, DownloadOption_1, BaseEvents_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownloadDialogue = /** @class */ (function (_super) {
        __extends(DownloadDialogue, _super);
        function DownloadDialogue($element) {
            return _super.call(this, $element) || this;
        }
        DownloadDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('downloadDialogue');
            _super.prototype.create.call(this);
            this.$entireFileAsOriginal = $('<li class="option single"><input id="' + DownloadOption_1.DownloadOption.ENTIRE_FILE_AS_ORIGINAL + '" type="radio" name="downloadOptions" tabindex="0" /><label id="' + DownloadOption_1.DownloadOption.ENTIRE_FILE_AS_ORIGINAL + 'label" for="' + DownloadOption_1.DownloadOption.ENTIRE_FILE_AS_ORIGINAL + '"></label></li>');
            this.$downloadOptions.append(this.$entireFileAsOriginal);
            this.$entireFileAsOriginal.hide();
            this.$downloadButton = $('<a class="btn btn-primary" href="#" tabindex="0">' + this.content.download + '</a>');
            this.$buttons.prepend(this.$downloadButton);
            this.$imageOptionsContainer = $('<li class="group image"></li>');
            this.$imageOptions = $('<ul></ul>');
            this.$imageOptionsContainer.append(this.$imageOptions);
            this.$canvasOptionsContainer = $('<li class="group canvas"></li>');
            this.$canvasOptions = $('<ul></ul>');
            this.$canvasOptionsContainer.append(this.$canvasOptions);
            this.$manifestOptionsContainer = $('<li class="group manifest"></li>');
            this.$manifestOptions = $('<ul></ul>');
            this.$manifestOptionsContainer.append(this.$manifestOptions);
            var that = this;
            this.$downloadButton.on('click', function (e) {
                e.preventDefault();
                var $selectedOption = that.getSelectedOption();
                var id = $selectedOption.attr('id');
                var label = $selectedOption.attr('title');
                var type = DownloadOption_1.DownloadOption.UNKNOWN;
                if (_this.renderingUrls[id]) {
                    window.open(_this.renderingUrls[id]);
                }
                else {
                    var id_1 = _this.getCurrentResourceId();
                    window.open(id_1);
                }
                _this.component.publish(BaseEvents_1.BaseEvents.DOWNLOAD, {
                    "type": type,
                    "label": label
                });
                _this.close();
            });
        };
        DownloadDialogue.prototype._isAdaptive = function () {
            var format = this.getCurrentResourceFormat();
            return format === 'mpd' || format === 'm3u8';
        };
        DownloadDialogue.prototype.open = function (triggerButton) {
            _super.prototype.open.call(this, triggerButton);
            var canvas = this.extension.helper.getCurrentCanvas();
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.ENTIRE_FILE_AS_ORIGINAL) && !this._isAdaptive()) {
                var $input = this.$entireFileAsOriginal.find('input');
                var $label = this.$entireFileAsOriginal.find('label');
                var label = Utils.Strings.format(this.content.entireFileAsOriginalWithFormat, this.getCurrentResourceFormat());
                $label.text(label);
                $input.prop('title', label);
                this.$entireFileAsOriginal.show();
            }
            this.resetDynamicDownloadOptions();
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.RANGE_RENDERINGS)) {
                if (canvas.ranges && canvas.ranges.length) {
                    for (var i = 0; i < canvas.ranges.length; i++) {
                        var range = canvas.ranges[i];
                        var renderingOptions = this.getDownloadOptionsForRenderings(range, this.content.entireFileAsOriginal, DownloadOption_1.DownloadOption.CANVAS_RENDERINGS);
                        this.addDownloadOptionsForRenderings(renderingOptions);
                    }
                }
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.IMAGE_RENDERINGS)) {
                var images = canvas.getImages();
                if (images.length) {
                    this.$downloadOptions.append(this.$imageOptionsContainer);
                }
                for (var i = 0; i < images.length; i++) {
                    var renderingOptions = this.getDownloadOptionsForRenderings(images[i].getResource(), this.content.entireFileAsOriginal, DownloadOption_1.DownloadOption.IMAGE_RENDERINGS);
                    this.addDownloadOptionsForRenderings(renderingOptions);
                }
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.CANVAS_RENDERINGS)) {
                var renderingOptions = this.getDownloadOptionsForRenderings(canvas, this.content.entireFileAsOriginal, DownloadOption_1.DownloadOption.CANVAS_RENDERINGS);
                if (renderingOptions.length) {
                    this.$downloadOptions.append(this.$canvasOptionsContainer);
                    this.addDownloadOptionsForRenderings(renderingOptions);
                }
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS)) {
                var renderingOptions = this.getDownloadOptionsForRenderings(this.extension.helper.getCurrentSequence(), this.content.entireDocument, DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS);
                if (!renderingOptions.length) {
                    renderingOptions = this.getDownloadOptionsForRenderings(this.extension.helper.manifest, this.content.entireDocument, DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS);
                }
                if (renderingOptions.length) {
                    this.$downloadOptions.append(this.$manifestOptionsContainer);
                    this.addDownloadOptionsForRenderings(renderingOptions);
                }
            }
            if (this.$downloadOptions.length) {
                this.$entireFileAsOriginal.hide();
            }
            if (!this.$downloadOptions.find('li.option:visible').length) {
                this.$noneAvailable.show();
                this.$downloadButton.hide();
            }
            else {
                // select first option.
                this.$downloadOptions.find('li.option input:visible:first').prop('checked', true);
                this.$noneAvailable.hide();
                this.$downloadButton.show();
            }
            this.resize();
        };
        DownloadDialogue.prototype.addDownloadOptionsForRenderings = function (renderingOptions) {
            var _this = this;
            renderingOptions.forEach(function (option) {
                switch (option.type) {
                    case DownloadOption_1.DownloadOption.IMAGE_RENDERINGS:
                        _this.$imageOptions.append(option.button);
                        break;
                    case DownloadOption_1.DownloadOption.CANVAS_RENDERINGS:
                        _this.$canvasOptions.append(option.button);
                        break;
                    case DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS:
                        _this.$manifestOptions.append(option.button);
                        break;
                }
            });
        };
        DownloadDialogue.prototype.isDownloadOptionAvailable = function (option) {
            return this.isMediaDownloadEnabled();
        };
        return DownloadDialogue;
    }(DownloadDialogue_1.DownloadDialogue));
    exports.DownloadDialogue = DownloadDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/FooterPanel',["require", "exports", "./BaseEvents", "./BaseView"], function (require, exports, BaseEvents_1, BaseView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FooterPanel = /** @class */ (function (_super) {
        __extends(FooterPanel, _super);
        function FooterPanel($element) {
            return _super.call(this, $element) || this;
        }
        FooterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('footerPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN, function () {
                _this.updateFullScreenButton();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.METRIC_CHANGED, function () {
                _this.updateMinimisedButtons();
                _this.updateMoreInfoButton();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, function () {
                _this.updateDownloadButton();
            });
            this.$options = $('<div class="options"></div>');
            this.$element.append(this.$options);
            this.$feedbackButton = $("\n          <button class=\"feedback btn imageBtn\" title=\"" + this.content.feedback + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-feedback\" aria-hidden=\"true\"></i>" + this.content.feedback + "\n          </button>\n        ");
            this.$options.prepend(this.$feedbackButton);
            this.$openButton = $("\n          <button class=\"open btn imageBtn\" title=\"" + this.content.open + "\" tabindex=\"0\">\n            <i class=\"uv-icon-open\" aria-hidden=\"true\"></i>" + this.content.open + "\n          </button>\n        ");
            this.$options.prepend(this.$openButton);
            this.$bookmarkButton = $("\n          <button class=\"bookmark btn imageBtn\" title=\"" + this.content.bookmark + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-bookmark\" aria-hidden=\"true\"></i>" + this.content.bookmark + "\n          </button>\n        ");
            this.$options.prepend(this.$bookmarkButton);
            this.$shareButton = $("\n          <button class=\"share btn imageBtn\" title=\"" + this.content.share + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-share\" aria-hidden=\"true\"></i>" + this.content.share + "\n          </button>\n        ");
            this.$options.append(this.$shareButton);
            this.$embedButton = $("\n          <button class=\"embed btn imageBtn\" title=\"" + this.content.embed + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-embed\" aria-hidden=\"true\"></i>" + this.content.embed + "\n          </button>\n        ");
            this.$options.append(this.$embedButton);
            this.$downloadButton = $("\n          <button class=\"download btn imageBtn\" title=\"" + this.content.download + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-download\" aria-hidden=\"true\"></i>" + this.content.download + "\n          </button>\n        ");
            this.$options.prepend(this.$downloadButton);
            this.$moreInfoButton = $("\n          <button class=\"moreInfo btn imageBtn\" title=\"" + this.content.moreInfo + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-more-info\" aria-hidden=\"true\"></i>" + this.content.moreInfo + "\n          </button>\n        ");
            this.$options.prepend(this.$moreInfoButton);
            this.$fullScreenBtn = $("\n          <button class=\"fullScreen btn imageBtn\" title=\"" + this.content.fullScreen + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-fullscreen\" aria-hidden=\"true\"></i>" + this.content.fullScreen + "\n          </button>\n        ");
            this.$options.append(this.$fullScreenBtn);
            this.$openButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.OPEN);
            });
            this.$feedbackButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.FEEDBACK);
            });
            this.$bookmarkButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.BOOKMARK);
            });
            this.$shareButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_SHARE_DIALOGUE, _this.$shareButton);
            });
            this.$embedButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_EMBED_DIALOGUE, _this.$embedButton);
            });
            this.$downloadButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_DOWNLOAD_DIALOGUE, _this.$downloadButton);
            });
            this.$moreInfoButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_MOREINFO_DIALOGUE, _this.$moreInfoButton);
            });
            this.$fullScreenBtn.on('click', function (e) {
                e.preventDefault();
                _this.component.publish(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN);
            });
            if (!Utils.Bools.getBool(this.options.embedEnabled, true)) {
                this.$embedButton.hide();
            }
            this.updateMoreInfoButton();
            this.updateOpenButton();
            this.updateFeedbackButton();
            this.updateBookmarkButton();
            this.updateEmbedButton();
            this.updateDownloadButton();
            this.updateFullScreenButton();
            this.updateShareButton();
            this.updateMinimisedButtons();
        };
        FooterPanel.prototype.updateMinimisedButtons = function () {
            if (!this.extension.isDesktopMetric()) {
                this.$options.addClass('minimiseButtons');
            }
            else {
                this.$options.removeClass('minimiseButtons');
            }
        };
        FooterPanel.prototype.updateMoreInfoButton = function () {
            var configEnabled = Utils.Bools.getBool(this.options.moreInfoEnabled, false);
            if (configEnabled && !this.extension.isDesktopMetric() && !this.extension.isCatchAllMetric()) {
                this.$moreInfoButton.show();
            }
            else {
                this.$moreInfoButton.hide();
            }
        };
        FooterPanel.prototype.updateOpenButton = function () {
            var configEnabled = Utils.Bools.getBool(this.options.openEnabled, false);
            if (configEnabled && Utils.Documents.isInIFrame()) {
                this.$openButton.show();
            }
            else {
                this.$openButton.hide();
            }
        };
        FooterPanel.prototype.updateFullScreenButton = function () {
            if (!Utils.Bools.getBool(this.options.fullscreenEnabled, true) || !Utils.Documents.supportsFullscreen()) {
                this.$fullScreenBtn.hide();
                return;
            }
            if (this.extension.data.isLightbox) {
                this.$fullScreenBtn.addClass('lightbox');
            }
            if (this.extension.isFullScreen()) {
                this.$fullScreenBtn.switchClass('fullScreen', 'exitFullscreen');
                this.$fullScreenBtn.find('i').switchClass('uv-icon-fullscreen', 'uv-icon-exit-fullscreen');
                this.$fullScreenBtn.attr('title', this.content.exitFullScreen);
                $(this.$fullScreenBtn[0].firstChild.nextSibling.nextSibling).replaceWith(this.content.exitFullScreen);
            }
            else {
                this.$fullScreenBtn.switchClass('exitFullscreen', 'fullScreen');
                this.$fullScreenBtn.find('i').switchClass('uv-icon-exit-fullscreen', 'uv-icon-fullscreen');
                this.$fullScreenBtn.attr('title', this.content.fullScreen);
                $(this.$fullScreenBtn[0].firstChild.nextSibling.nextSibling).replaceWith(this.content.fullScreen);
            }
        };
        FooterPanel.prototype.updateEmbedButton = function () {
            if (this.extension.helper.isUIEnabled('embed') && Utils.Bools.getBool(this.options.embedEnabled, false)) {
                // current jquery version sets display to 'inline' in mobile version, while this should remain hidden (see media query)
                if (!this.extension.isMobile()) {
                    this.$embedButton.show();
                }
            }
            else {
                this.$embedButton.hide();
            }
        };
        FooterPanel.prototype.updateShareButton = function () {
            if (this.extension.helper.isUIEnabled('share') && Utils.Bools.getBool(this.options.shareEnabled, true)) {
                this.$shareButton.show();
            }
            else {
                this.$shareButton.hide();
            }
        };
        FooterPanel.prototype.updateDownloadButton = function () {
            var configEnabled = Utils.Bools.getBool(this.options.downloadEnabled, true);
            if (configEnabled) {
                this.$downloadButton.show();
            }
            else {
                this.$downloadButton.hide();
            }
        };
        FooterPanel.prototype.updateFeedbackButton = function () {
            var configEnabled = Utils.Bools.getBool(this.options.feedbackEnabled, false);
            if (configEnabled) {
                this.$feedbackButton.show();
            }
            else {
                this.$feedbackButton.hide();
            }
        };
        FooterPanel.prototype.updateBookmarkButton = function () {
            var configEnabled = Utils.Bools.getBool(this.options.bookmarkEnabled, false);
            if (configEnabled) {
                this.$bookmarkButton.show();
            }
            else {
                this.$bookmarkButton.hide();
            }
        };
        FooterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return FooterPanel;
    }(BaseView_1.BaseView));
    exports.FooterPanel = FooterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-avmobilefooterpanel-module/MobileFooter',["require", "exports", "../uv-shared-module/FooterPanel"], function (require, exports, FooterPanel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FooterPanel = /** @class */ (function (_super) {
        __extends(FooterPanel, _super);
        function FooterPanel($element) {
            return _super.call(this, $element) || this;
        }
        FooterPanel.prototype.create = function () {
            this.setConfig('mobileFooterPanel');
            _super.prototype.create.call(this);
        };
        FooterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$options.css('left', Math.floor((this.$element.width() / 2) - (this.$options.width() / 2)));
        };
        return FooterPanel;
    }(FooterPanel_1.FooterPanel));
    exports.FooterPanel = FooterPanel;
});

define('modules/uv-shared-module/Information',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Information = /** @class */ (function () {
        function Information(message, actions) {
            this.message = message;
            this.actions = actions;
        }
        return Information;
    }());
    exports.Information = Information;
});

define('modules/uv-shared-module/InformationAction',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var InformationAction = /** @class */ (function () {
        function InformationAction() {
        }
        return InformationAction;
    }());
    exports.InformationAction = InformationAction;
});

define('modules/uv-shared-module/InformationFactory',["require", "exports", "./BaseEvents", "./Information", "./InformationAction", "./InformationType"], function (require, exports, BaseEvents_1, Information_1, InformationAction_1, InformationType_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var InformationFactory = /** @class */ (function () {
        function InformationFactory(extension) {
            this.extension = extension;
        }
        InformationFactory.prototype.Get = function (args) {
            var _this = this;
            switch (args.informationType) {
                case (InformationType_1.InformationType.AUTH_CORS_ERROR):
                    return new Information_1.Information(this.extension.data.config.content.authCORSError, []);
                case (InformationType_1.InformationType.DEGRADED_RESOURCE):
                    var actions = [];
                    var loginAction = new InformationAction_1.InformationAction();
                    var label = args.param.loginService.getConfirmLabel();
                    if (!label) {
                        label = this.extension.data.config.content.fallbackDegradedLabel;
                    }
                    loginAction.label = label;
                    var resource_1 = args.param;
                    loginAction.action = function () {
                        resource_1.authHoldingPage = window.open("", "_blank");
                        _this.extension.component.publish(BaseEvents_1.BaseEvents.HIDE_INFORMATION);
                        _this.extension.component.publish(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, [[resource_1]]);
                    };
                    actions.push(loginAction);
                    var message = args.param.loginService.getServiceLabel();
                    if (!message) {
                        message = this.extension.data.config.content.fallbackDegradedMessage;
                    }
                    return new Information_1.Information(message, actions);
            }
        };
        return InformationFactory;
    }());
    exports.InformationFactory = InformationFactory;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/HeaderPanel',["require", "exports", "./BaseEvents", "./BaseView", "../uv-shared-module/InformationFactory"], function (require, exports, BaseEvents_1, BaseView_1, InformationFactory_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HeaderPanel = /** @class */ (function (_super) {
        __extends(HeaderPanel, _super);
        function HeaderPanel($element) {
            return _super.call(this, $element, false, false) || this;
        }
        HeaderPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('headerPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_INFORMATION, function (args) {
                _this.showInformation(args);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_INFORMATION, function () {
                _this.hideInformation();
            });
            this.$options = $('<div class="options"></div>');
            this.$element.append(this.$options);
            this.$centerOptions = $('<div class="centerOptions"></div>');
            this.$options.append(this.$centerOptions);
            this.$rightOptions = $('<div class="rightOptions"></div>');
            this.$options.append(this.$rightOptions);
            //this.$helpButton = $('<a href="#" class="action help">' + this.content.help + '</a>');
            //this.$rightOptions.append(this.$helpButton);
            this.$localeToggleButton = $('<a class="localeToggle" tabindex="0"></a>');
            this.$rightOptions.append(this.$localeToggleButton);
            this.$settingsButton = $("\n          <button class=\"btn imageBtn settings\" tabindex=\"0\" title=\"" + this.content.settings + "\">\n            <i class=\"uv-icon-settings\" aria-hidden=\"true\"></i>" + this.content.settings + "\n          </button>\n        ");
            this.$settingsButton.attr('title', this.content.settings);
            this.$rightOptions.append(this.$settingsButton);
            this.$informationBox = $('<div class="informationBox" aria-hidden="true"> \
                                    <div class="message"></div> \
                                    <div class="actions"></div> \
                                    <button type="button" class="close" aria-label="Close"> \
                                        <span aria-hidden="true">&times;</span>\
                                    </button> \
                                  </div>');
            this.$element.append(this.$informationBox);
            this.$informationBox.hide();
            this.$informationBox.find('.close').attr('title', this.content.close);
            this.$informationBox.find('.close').on('click', function (e) {
                e.preventDefault();
                _this.component.publish(BaseEvents_1.BaseEvents.HIDE_INFORMATION);
            });
            this.$localeToggleButton.on('click', function () {
                _this.extension.changeLocale(String(_this.$localeToggleButton.data('locale')));
            });
            this.$settingsButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_SETTINGS_DIALOGUE);
            });
            if (!Utils.Bools.getBool(this.options.centerOptionsEnabled, true)) {
                this.$centerOptions.hide();
            }
            this.updateLocaleToggle();
            this.updateSettingsButton();
        };
        HeaderPanel.prototype.updateLocaleToggle = function () {
            if (!this.localeToggleIsVisible()) {
                this.$localeToggleButton.hide();
                return;
            }
            var alternateLocale = this.extension.getAlternateLocale();
            var text = alternateLocale.name.split('-')[0].toUpperCase();
            this.$localeToggleButton.data('locale', alternateLocale.name);
            this.$localeToggleButton.attr('title', alternateLocale.label);
            this.$localeToggleButton.text(text);
        };
        HeaderPanel.prototype.updateSettingsButton = function () {
            var settingsEnabled = Utils.Bools.getBool(this.options.settingsButtonEnabled, true);
            if (!settingsEnabled) {
                this.$settingsButton.hide();
            }
            else {
                this.$settingsButton.show();
            }
        };
        HeaderPanel.prototype.localeToggleIsVisible = function () {
            var locales = this.extension.data.locales;
            if (locales) {
                return locales.length > 1 && Utils.Bools.getBool(this.options.localeToggleEnabled, false);
            }
            return false;
        };
        HeaderPanel.prototype.showInformation = function (args) {
            var informationFactory = new InformationFactory_1.InformationFactory(this.extension);
            this.information = informationFactory.Get(args);
            var $message = this.$informationBox.find('.message');
            $message.html(this.information.message).find('a').attr('target', '_top');
            var $actions = this.$informationBox.find('.actions');
            $actions.empty();
            for (var i = 0; i < this.information.actions.length; i++) {
                var action = this.information.actions[i];
                var $action = $('<a href="#" class="btn btn-default">' + action.label + '</a>');
                $action.on('click', action.action);
                $actions.append($action);
            }
            this.$informationBox.attr('aria-hidden', 'false');
            this.$informationBox.show();
            this.$element.addClass('showInformation');
            this.extension.resize();
        };
        HeaderPanel.prototype.hideInformation = function () {
            this.$element.removeClass('showInformation');
            this.$informationBox.attr('aria-hidden', 'true');
            this.$informationBox.hide();
            this.extension.resize();
        };
        HeaderPanel.prototype.getSettings = function () {
            return this.extension.getSettings();
        };
        HeaderPanel.prototype.updateSettings = function (settings) {
            this.extension.updateSettings(settings);
            this.component.publish(BaseEvents_1.BaseEvents.UPDATE_SETTINGS, settings);
        };
        HeaderPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            var headerWidth = this.$element.width();
            var center = headerWidth / 2;
            var containerWidth = this.$centerOptions.outerWidth();
            var pos = center - (containerWidth / 2);
            this.$centerOptions.css({
                left: pos
            });
            if (this.$informationBox.is(':visible')) {
                var $actions = this.$informationBox.find('.actions');
                var $message = this.$informationBox.find('.message');
                $message.width(Math.floor(this.$element.width()) - Math.ceil($message.horizontalMargins()) - Math.ceil($actions.outerWidth(true)) - Math.ceil(this.$informationBox.find('.close').outerWidth(true)) - 2);
                $message.text(this.information.message);
            }
            // hide toggle buttons below minimum width
            if (this.extension.width() < this.extension.data.config.options.minWidthBreakPoint) {
                if (this.localeToggleIsVisible())
                    this.$localeToggleButton.hide();
            }
            else {
                if (this.localeToggleIsVisible())
                    this.$localeToggleButton.show();
            }
        };
        return HeaderPanel;
    }(BaseView_1.BaseView));
    exports.HeaderPanel = HeaderPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-shared-module/RightPanel',["require", "exports", "./BaseEvents", "./BaseExpandPanel"], function (require, exports, BaseEvents_1, BaseExpandPanel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RightPanel = /** @class */ (function (_super) {
        __extends(RightPanel, _super);
        function RightPanel($element) {
            return _super.call(this, $element) || this;
        }
        RightPanel.prototype.create = function () {
            _super.prototype.create.call(this);
            this.$element.width(this.options.panelCollapsedWidth);
        };
        RightPanel.prototype.init = function () {
            var _this = this;
            _super.prototype.init.call(this);
            var shouldOpenPanel = Utils.Bools.getBool(this.extension.getSettings().rightPanelOpen, this.options.panelOpen);
            if (shouldOpenPanel) {
                this.toggle(true);
            }
            this.component.subscribe(BaseEvents_1.BaseEvents.TOGGLE_EXPAND_RIGHT_PANEL, function () {
                if (_this.isFullyExpanded) {
                    _this.collapseFull();
                }
                else {
                    _this.expandFull();
                }
            });
        };
        RightPanel.prototype.getTargetWidth = function () {
            return this.isExpanded ? this.options.panelCollapsedWidth : this.options.panelExpandedWidth;
        };
        RightPanel.prototype.getTargetLeft = function () {
            return this.isExpanded ? this.$element.parent().width() - this.options.panelCollapsedWidth : this.$element.parent().width() - this.options.panelExpandedWidth;
        };
        RightPanel.prototype.toggleFinish = function () {
            _super.prototype.toggleFinish.call(this);
            if (this.isExpanded) {
                this.component.publish(BaseEvents_1.BaseEvents.OPEN_RIGHT_PANEL);
            }
            else {
                this.component.publish(BaseEvents_1.BaseEvents.CLOSE_RIGHT_PANEL);
            }
            this.extension.updateSettings({ rightPanelOpen: this.isExpanded });
        };
        RightPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$element.css({
                'left': Math.floor(this.$element.parent().width() - this.$element.outerWidth())
            });
        };
        return RightPanel;
    }(BaseExpandPanel_1.BaseExpandPanel));
    exports.RightPanel = RightPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-moreinforightpanel-module/MoreInfoRightPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/RightPanel", "../../Utils"], function (require, exports, BaseEvents_1, RightPanel_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MoreInfoRightPanel = /** @class */ (function (_super) {
        __extends(MoreInfoRightPanel, _super);
        function MoreInfoRightPanel($element) {
            return _super.call(this, $element) || this;
        }
        MoreInfoRightPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('moreInfoRightPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function () {
                _this.databind();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RANGE_CHANGED, function () {
                _this.databind();
            });
            this.setTitle(this.config.content.title);
            this.$metadata = $('<div class="iiif-metadata-component"></div>');
            this.$main.append(this.$metadata);
            this.metadataComponent = new IIIFComponents.MetadataComponent({
                target: this.$metadata[0],
                data: this._getData()
            });
            this.metadataComponent.on('iiifViewerLinkClicked', function (href) {
                // get the hash param.
                var rangeId = Utils.Urls.getHashParameterFromString('rid', href);
                if (rangeId) {
                    var range = _this.extension.helper.getRangeById(rangeId);
                    if (range) {
                        _this.component.publish(BaseEvents_1.BaseEvents.RANGE_CHANGED, range);
                    }
                }
            }, false);
        };
        MoreInfoRightPanel.prototype.toggleFinish = function () {
            _super.prototype.toggleFinish.call(this);
            this.databind();
        };
        MoreInfoRightPanel.prototype.databind = function () {
            this.metadataComponent.set(this._getData());
        };
        MoreInfoRightPanel.prototype._getCurrentRange = function () {
            var range = this.extension.helper.getCurrentRange();
            return range;
        };
        MoreInfoRightPanel.prototype._getData = function () {
            return {
                canvasDisplayOrder: this.config.options.canvasDisplayOrder,
                canvases: this.extension.getCurrentCanvases(),
                canvasExclude: this.config.options.canvasExclude,
                canvasLabels: this.extension.getCanvasLabels(this.content.page),
                content: this.config.content,
                copiedMessageDuration: 2000,
                copyToClipboardEnabled: Utils.Bools.getBool(this.config.options.copyToClipboardEnabled, false),
                helper: this.extension.helper,
                licenseFormatter: new Manifold.UriLabeller(this.config.license ? this.config.license : {}),
                limit: this.config.options.textLimit || 4,
                limitType: IIIFComponents.LimitType.LINES,
                limitToRange: Utils.Bools.getBool(this.config.options.limitToRange, false),
                manifestDisplayOrder: this.config.options.manifestDisplayOrder,
                manifestExclude: this.config.options.manifestExclude,
                range: this._getCurrentRange(),
                rtlLanguageCodes: this.config.options.rtlLanguageCodes,
                sanitizer: function (html) {
                    return Utils_1.UVUtils.sanitize(html);
                },
                showAllLanguages: this.config.options.showAllLanguages
            };
        };
        MoreInfoRightPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$main.height(this.$element.height() - this.$top.height() - this.$main.verticalMargins());
        };
        return MoreInfoRightPanel;
    }(RightPanel_1.RightPanel));
    exports.MoreInfoRightPanel = MoreInfoRightPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/SettingsDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsDialogue = /** @class */ (function (_super) {
        __extends(SettingsDialogue, _super);
        function SettingsDialogue($element) {
            return _super.call(this, $element) || this;
        }
        SettingsDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('settingsDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_SETTINGS_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_SETTINGS_DIALOGUE;
            this.component.subscribe(this.openCommand, function () {
                _this.open();
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$title = $('<h1></h1>');
            this.$content.append(this.$title);
            this.$scroll = $('<div class="scroll"></div>');
            this.$content.append(this.$scroll);
            this.$version = $('<div class="version"></div>');
            this.$content.append(this.$version);
            this.$website = $('<div class="website"></div>');
            this.$content.append(this.$website);
            this.$locale = $('<div class="setting locale"></div>');
            this.$scroll.append(this.$locale);
            this.$localeLabel = $('<label for="locale">' + this.content.locale + '</label>');
            this.$locale.append(this.$localeLabel);
            this.$localeDropDown = $('<select id="locale"></select>');
            this.$locale.append(this.$localeDropDown);
            // initialise ui.
            this.$title.text(this.content.title);
            this.$website.html(this.content.website);
            this.$website.targetBlank();
            this._createLocalesMenu();
            this.$element.hide();
        };
        SettingsDialogue.prototype.getSettings = function () {
            return this.extension.getSettings();
        };
        SettingsDialogue.prototype.updateSettings = function (settings) {
            this.extension.updateSettings(settings);
            this.component.publish(BaseEvents_1.BaseEvents.UPDATE_SETTINGS, settings);
        };
        SettingsDialogue.prototype.open = function () {
            var _this = this;
            _super.prototype.open.call(this);
            $.getJSON(this.extension.data.root + "/info.json", function (pjson) {
                _this.$version.text("v" + pjson.version);
            });
        };
        SettingsDialogue.prototype._createLocalesMenu = function () {
            var _this = this;
            var locales = this.extension.data.locales;
            if (locales && locales.length > 1) {
                for (var i = 0; i < locales.length; i++) {
                    var locale = locales[i];
                    this.$localeDropDown.append('<option value="' + locale.name + '">' + locale.label + '</option>');
                }
                this.$localeDropDown.val(locales[0].name);
            }
            else {
                this.$locale.hide();
            }
            this.$localeDropDown.change(function () {
                _this.extension.changeLocale(_this.$localeDropDown.val());
            });
        };
        SettingsDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return SettingsDialogue;
    }(Dialogue_1.Dialogue));
    exports.SettingsDialogue = SettingsDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-av-extension/SettingsDialogue',["require", "exports", "../../modules/uv-dialogues-module/SettingsDialogue"], function (require, exports, SettingsDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsDialogue = /** @class */ (function (_super) {
        __extends(SettingsDialogue, _super);
        function SettingsDialogue($element) {
            return _super.call(this, $element) || this;
        }
        SettingsDialogue.prototype.create = function () {
            this.setConfig('settingsDialogue');
            _super.prototype.create.call(this);
        };
        return SettingsDialogue;
    }(SettingsDialogue_1.SettingsDialogue));
    exports.SettingsDialogue = SettingsDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/ShareDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShareDialogue = /** @class */ (function (_super) {
        __extends(ShareDialogue, _super);
        function ShareDialogue($element) {
            var _this = _super.call(this, $element) || this;
            _this.aspectRatio = .75;
            _this.isEmbedViewVisible = false;
            _this.isShareViewVisible = false;
            _this.maxWidth = 8000;
            _this.maxHeight = _this.maxWidth * _this.aspectRatio;
            _this.minWidth = 200;
            _this.minHeight = _this.minWidth * _this.aspectRatio;
            return _this;
        }
        ShareDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('shareDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_SHARE_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_SHARE_DIALOGUE;
            this.component.subscribe(this.openCommand, function (triggerButton) {
                _this.open(triggerButton);
                if (_this.isShareAvailable()) {
                    _this.openShareView();
                }
                else {
                    _this.openEmbedView();
                }
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_EMBED_DIALOGUE, function (triggerButton) {
                _this.open(triggerButton);
                _this.openEmbedView();
            });
            this.$tabs = $('<div class="tabs"></div>');
            this.$content.append(this.$tabs);
            this.$shareButton = $('<a class="share tab default" tabindex="0">' + this.content.share + '</a>');
            this.$shareButton.prop('title', this.content.share);
            this.$tabs.append(this.$shareButton);
            this.$embedButton = $('<a class="embed tab" tabindex="0">' + this.content.embed + '</a>');
            this.$embedButton.prop('title', this.content.embed);
            this.$tabs.append(this.$embedButton);
            this.$tabsContent = $('<div class="tabsContent"></div>');
            this.$content.append(this.$tabsContent);
            this.$footer = $('<div class="footer"></div>');
            this.$content.append(this.$footer);
            this.$shareView = $('<div class="shareView view"></div>');
            this.$tabsContent.append(this.$shareView);
            this.$shareHeader = $('<div class="header"></div>');
            this.$shareView.append(this.$shareHeader);
            this.$shareLink = $('<a class="shareLink" onclick="return false;"></a>');
            this.$shareView.append(this.$shareLink);
            this.$shareInput = $("<input class=\"shareInput\" type=\"text\" readonly aria-label=\"" + this.content.shareUrl + "\"/>");
            this.$shareView.append(this.$shareInput);
            this.$shareFrame = $('<iframe class="shareFrame"></iframe>');
            this.$shareView.append(this.$shareFrame);
            this.$embedView = $('<div class="embedView view"></div>');
            this.$tabsContent.append(this.$embedView);
            this.$embedHeader = $('<div class="header"></div>');
            this.$embedView.append(this.$embedHeader);
            // this.$link = $('<a target="_blank"></a>');
            // this.$embedView.find('.leftCol').append(this.$link);
            // this.$image = $('<img class="share" />');
            // this.$embedView.append(this.$image);
            this.$code = $("<input class=\"code\" type=\"text\" readonly aria-label=\"" + this.content.embed + "\"/>");
            this.$embedView.append(this.$code);
            this.$customSize = $('<div class="customSize"></div>');
            this.$embedView.append(this.$customSize);
            this.$size = $('<span class="size">' + this.content.size + '</span>');
            this.$customSize.append(this.$size);
            this.$customSizeDropDown = $('<select id="size" aria-label="' + this.content.size + '"></select>');
            this.$customSize.append(this.$customSizeDropDown);
            this.$customSizeDropDown.append('<option value="small" data-width="560" data-height="420">560 x 420</option>');
            this.$customSizeDropDown.append('<option value="medium" data-width="640" data-height="480">640 x 480</option>');
            this.$customSizeDropDown.append('<option value="large" data-width="800" data-height="600">800 x 600</option>');
            this.$customSizeDropDown.append('<option value="custom">' + this.content.customSize + '</option>');
            this.$widthInput = $('<input class="width" type="text" maxlength="10" aria-label="' + this.content.width + '"/>');
            this.$customSize.append(this.$widthInput);
            this.$x = $('<span class="x">x</span>');
            this.$customSize.append(this.$x);
            this.$heightInput = $('<input class="height" type="text" maxlength="10" aria-label="' + this.content.height + '"/>');
            this.$customSize.append(this.$heightInput);
            var iiifUrl = this.extension.getIIIFShareUrl();
            this.$iiifButton = $('<a class="imageBtn iiif" href="' + iiifUrl + '" title="' + this.content.iiif + '" target="_blank"></a>');
            this.$footer.append(this.$iiifButton);
            this.$termsOfUseButton = $('<a href="#">' + this.extension.data.config.content.termsOfUse + '</a>');
            this.$footer.append(this.$termsOfUseButton);
            this.$widthInput.on('keydown', function (e) {
                return Utils.Numbers.numericalInput(e);
            });
            this.$heightInput.on('keydown', function (e) {
                return Utils.Numbers.numericalInput(e);
            });
            this.$shareInput.focus(function () {
                $(this).select();
            });
            this.$code.focus(function () {
                $(this).select();
            });
            this.$shareButton.onPressed(function () {
                _this.openShareView();
            });
            this.$embedButton.onPressed(function () {
                _this.openEmbedView();
            });
            this.$customSizeDropDown.change(function () {
                _this.update();
            });
            this.$widthInput.change(function () {
                _this.updateHeightRatio();
                _this.update();
            });
            this.$heightInput.change(function () {
                _this.updateWidthRatio();
                _this.update();
            });
            this.$termsOfUseButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_TERMS_OF_USE);
            });
            this.$element.hide();
            this.update();
        };
        ShareDialogue.prototype.open = function (triggerButton) {
            _super.prototype.open.call(this, triggerButton);
            this.update();
        };
        ShareDialogue.prototype.getShareUrl = function () {
            return this.extension.getShareUrl();
        };
        ShareDialogue.prototype.isShareAvailable = function () {
            return !!this.getShareUrl();
        };
        ShareDialogue.prototype.update = function () {
            if (this.isShareAvailable()) {
                this.$shareButton.show();
            }
            else {
                this.$shareButton.hide();
            }
            var $selected = this.getSelectedSize();
            if ($selected.val() === 'custom') {
                this.$widthInput.show();
                this.$x.show();
                this.$heightInput.show();
            }
            else {
                this.$widthInput.hide();
                this.$x.hide();
                this.$heightInput.hide();
                this.currentWidth = Number($selected.data('width'));
                this.currentHeight = Number($selected.data('height'));
                this.$widthInput.val(String(this.currentWidth));
                this.$heightInput.val(String(this.currentHeight));
            }
            this.updateInstructions();
            this.updateShareOptions();
            this.updateShareFrame();
            this.updateTermsOfUseButton();
        };
        ShareDialogue.prototype.updateShareOptions = function () {
            var shareUrl = this.getShareUrl();
            if (shareUrl) {
                this.$shareInput.val(shareUrl);
                this.$shareLink.prop('href', shareUrl);
                this.$shareLink.text(shareUrl);
            }
            if (this.extension.isMobile()) {
                this.$shareInput.hide();
                this.$shareLink.show();
            }
            else {
                this.$shareInput.show();
                this.$shareLink.hide();
            }
        };
        ShareDialogue.prototype.updateInstructions = function () {
            if (Utils.Bools.getBool(this.options.instructionsEnabled, false)) {
                this.$shareHeader.show();
                this.$embedHeader.show();
                this.$shareHeader.text(this.content.shareInstructions);
                this.$embedHeader.text(this.content.embedInstructions);
            }
            else {
                this.$shareHeader.hide();
                this.$embedHeader.hide();
            }
        };
        // updateThumbnail(): void {
        //     var canvas: Manifesto.ICanvas = this.extension.helper.getCurrentCanvas();
        //     if (!canvas) return;
        //     var thumbnail = canvas.getProperty('thumbnail');
        //     if (!thumbnail || !_.isString(thumbnail)){
        //         thumbnail = canvas.getCanonicalImageUri(this.extension.data.config.options.bookmarkThumbWidth);
        //     }
        //     this.$link.attr('href', thumbnail);
        //     this.$image.attr('src', thumbnail);
        // }
        ShareDialogue.prototype.getSelectedSize = function () {
            return this.$customSizeDropDown.find(':selected');
        };
        ShareDialogue.prototype.updateWidthRatio = function () {
            this.currentHeight = Number(this.$heightInput.val());
            if (this.currentHeight < this.minHeight) {
                this.currentHeight = this.minHeight;
                this.$heightInput.val(String(this.currentHeight));
            }
            else if (this.currentHeight > this.maxHeight) {
                this.currentHeight = this.maxHeight;
                this.$heightInput.val(String(this.currentHeight));
            }
            this.currentWidth = Math.floor(this.currentHeight / this.aspectRatio);
            this.$widthInput.val(String(this.currentWidth));
        };
        ShareDialogue.prototype.updateHeightRatio = function () {
            this.currentWidth = Number(this.$widthInput.val());
            if (this.currentWidth < this.minWidth) {
                this.currentWidth = this.minWidth;
                this.$widthInput.val(String(this.currentWidth));
            }
            else if (this.currentWidth > this.maxWidth) {
                this.currentWidth = this.maxWidth;
                this.$widthInput.val(String(this.currentWidth));
            }
            this.currentHeight = Math.floor(this.currentWidth * this.aspectRatio);
            this.$heightInput.val(String(this.currentHeight));
        };
        ShareDialogue.prototype.updateShareFrame = function () {
            var shareUrl = this.extension.helper.getShareServiceUrl();
            if (!shareUrl) {
                return;
            }
            if (Utils.Bools.getBool(this.config.options.shareFrameEnabled, true) && shareUrl) {
                this.$shareFrame.prop('src', shareUrl);
                this.$shareFrame.show();
            }
            else {
                this.$shareFrame.hide();
            }
        };
        ShareDialogue.prototype.updateTermsOfUseButton = function () {
            var requiredStatement = this.extension.helper.getRequiredStatement();
            if (Utils.Bools.getBool(this.extension.data.config.options.termsOfUseEnabled, false) && requiredStatement && requiredStatement.value) {
                this.$termsOfUseButton.show();
            }
            else {
                this.$termsOfUseButton.hide();
            }
        };
        ShareDialogue.prototype.openShareView = function () {
            this.isShareViewVisible = true;
            this.isEmbedViewVisible = false;
            this.$embedView.hide();
            this.$shareView.show();
            this.$shareButton.addClass('on default');
            this.$embedButton.removeClass('on default');
            this.resize();
        };
        ShareDialogue.prototype.openEmbedView = function () {
            this.isShareViewVisible = false;
            this.isEmbedViewVisible = true;
            this.$embedView.show();
            this.$shareView.hide();
            this.$shareButton.removeClass('on default');
            this.$embedButton.addClass('on default');
            this.resize();
        };
        ShareDialogue.prototype.close = function () {
            _super.prototype.close.call(this);
        };
        ShareDialogue.prototype.getViews = function () {
            return this.$tabsContent.find('.view');
        };
        ShareDialogue.prototype.equaliseViewHeights = function () {
            this.getViews().equaliseHeight(true);
        };
        ShareDialogue.prototype.resize = function () {
            this.equaliseViewHeights();
            this.setDockedPosition();
        };
        return ShareDialogue;
    }(Dialogue_1.Dialogue));
    exports.ShareDialogue = ShareDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-av-extension/ShareDialogue',["require", "exports", "../../modules/uv-dialogues-module/ShareDialogue"], function (require, exports, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShareDialogue = /** @class */ (function (_super) {
        __extends(ShareDialogue, _super);
        function ShareDialogue($element) {
            return _super.call(this, $element) || this;
        }
        ShareDialogue.prototype.create = function () {
            this.setConfig('shareDialogue');
            _super.prototype.create.call(this);
        };
        ShareDialogue.prototype.update = function () {
            _super.prototype.update.call(this);
            this.code = this.extension.getEmbedScript(this.options.embedTemplate, this.currentWidth, this.currentHeight);
            this.$code.val(this.code);
        };
        ShareDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ShareDialogue;
    }(ShareDialogue_1.ShareDialogue));
    exports.ShareDialogue = ShareDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-av-extension/Extension',["require", "exports", "../../modules/uv-avcenterpanel-module/AVCenterPanel", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-shared-module/BaseExtension", "../../modules/uv-contentleftpanel-module/ContentLeftPanel", "./DownloadDialogue", "../../modules/uv-shared-module/FooterPanel", "../../modules/uv-avmobilefooterpanel-module/MobileFooter", "../../modules/uv-shared-module/HeaderPanel", "../../modules/uv-moreinforightpanel-module/MoreInfoRightPanel", "./SettingsDialogue", "./ShareDialogue"], function (require, exports, AVCenterPanel_1, BaseEvents_1, BaseExtension_1, ContentLeftPanel_1, DownloadDialogue_1, FooterPanel_1, MobileFooter_1, HeaderPanel_1, MoreInfoRightPanel_1, SettingsDialogue_1, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Extension = /** @class */ (function (_super) {
        __extends(Extension, _super);
        function Extension() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Extension.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            //requirejs.config({shim: {'uv/lib/hls.min': { deps: ['require'], exports: "Hls"}}});
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.viewCanvas(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.TREE_NODE_SELECTED, function (node) {
                _this.fire(BaseEvents_1.BaseEvents.TREE_NODE_SELECTED, node.data.path);
                _this.treeNodeSelected(node);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.THUMB_SELECTED, function (thumb) {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, thumb.index);
            });
        };
        Extension.prototype.dependencyLoaded = function (index, dep) {
            if (index === this.getDependencyIndex('waveform-data')) {
                window.WaveformData = dep;
            }
            else if (index === this.getDependencyIndex('hls')) {
                window.Hls = dep; //https://github.com/mrdoob/three.js/issues/9602
            }
        };
        Extension.prototype.createModules = function () {
            _super.prototype.createModules.call(this);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel = new HeaderPanel_1.HeaderPanel(this.shell.$headerPanel);
            }
            else {
                this.shell.$headerPanel.hide();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel = new ContentLeftPanel_1.ContentLeftPanel(this.shell.$leftPanel);
            }
            else {
                this.shell.$leftPanel.hide();
            }
            this.centerPanel = new AVCenterPanel_1.AVCenterPanel(this.shell.$centerPanel);
            if (this.isRightPanelEnabled()) {
                this.rightPanel = new MoreInfoRightPanel_1.MoreInfoRightPanel(this.shell.$rightPanel);
            }
            else {
                this.shell.$rightPanel.hide();
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel = new FooterPanel_1.FooterPanel(this.shell.$footerPanel);
                this.mobileFooterPanel = new MobileFooter_1.FooterPanel(this.shell.$mobileFooterPanel);
            }
            else {
                this.shell.$footerPanel.hide();
            }
            this.$shareDialogue = $('<div class="overlay share" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$shareDialogue);
            this.shareDialogue = new ShareDialogue_1.ShareDialogue(this.$shareDialogue);
            this.$downloadDialogue = $('<div class="overlay download" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$downloadDialogue);
            this.downloadDialogue = new DownloadDialogue_1.DownloadDialogue(this.$downloadDialogue);
            this.$settingsDialogue = $('<div class="overlay settings" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$settingsDialogue);
            this.settingsDialogue = new SettingsDialogue_1.SettingsDialogue(this.$settingsDialogue);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel.init();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel.init();
            }
            if (this.isRightPanelEnabled()) {
                this.rightPanel.init();
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel.init();
            }
        };
        Extension.prototype.isLeftPanelEnabled = function () {
            var isEnabled = _super.prototype.isLeftPanelEnabled.call(this);
            var tree = this.helper.getTree();
            if (tree && tree.nodes.length) {
                isEnabled = true;
            }
            return isEnabled;
        };
        Extension.prototype.render = function () {
            _super.prototype.render.call(this);
        };
        Extension.prototype.getEmbedScript = function (template, width, height) {
            var appUri = this.getAppUri();
            var iframeSrc = appUri + "#?manifest=" + this.helper.iiifResourceUri + "&c=" + this.helper.collectionIndex + "&m=" + this.helper.manifestIndex + "&s=" + this.helper.sequenceIndex + "&cv=" + this.helper.canvasIndex + "&rid=" + this.helper.rangeId;
            var script = Utils.Strings.format(template, iframeSrc, width.toString(), height.toString());
            return script;
        };
        Extension.prototype.treeNodeSelected = function (node) {
            var data = node.data;
            if (!data.type)
                return;
            switch (data.type) {
                case manifesto.IIIFResourceType.manifest().toString():
                    // do nothing
                    break;
                case manifesto.IIIFResourceType.collection().toString():
                    // do nothing
                    break;
                default:
                    this.viewRange(data.path);
                    break;
            }
        };
        Extension.prototype.viewRange = function (path) {
            var range = this.helper.getRangeByPath(path);
            if (!range)
                return;
            this.component.publish(BaseEvents_1.BaseEvents.RANGE_CHANGED, range);
            // don't update the canvas index, only when thumbs are clicked
            // if (range.canvases && range.canvases.length) {
            //     const canvasId: string = range.canvases[0];
            //     const canvas: Manifesto.ICanvas | null = this.helper.getCanvasById(canvasId);
            //     if (canvas) {
            //         const canvasIndex: number = canvas.index;
            //         if (canvasIndex !== this.helper.canvasIndex) {
            //             this.component.publish(BaseEvents.CANVAS_INDEX_CHANGED, [canvasIndex]);
            //         }
            //     }
            // }
        };
        return Extension;
    }(BaseExtension_1.BaseExtension));
    exports.Extension = Extension;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-filelinkcenterpanel-module/FileLinkCenterPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/CenterPanel", "../../Utils"], function (require, exports, BaseEvents_1, CenterPanel_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileLinkCenterPanel = /** @class */ (function (_super) {
        __extends(FileLinkCenterPanel, _super);
        function FileLinkCenterPanel($element) {
            return _super.call(this, $element) || this;
        }
        FileLinkCenterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('fileLinkCenterPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, function (resources) {
                _this.openMedia(resources);
            });
            this.$scroll = $('<div class="scroll"><div>');
            this.$content.append(this.$scroll);
            this.$downloadItems = $('<ol></ol>');
            this.$scroll.append(this.$downloadItems);
            this.$downloadItemTemplate = $('<li><img><div class="col2"><a class="filename" target="_blank" download></a><span class="label"></span><a class="description" target="_blank" download></a></div></li>');
            this.title = this.extension.helper.getLabel();
        };
        FileLinkCenterPanel.prototype.openMedia = function (resources) {
            var _this = this;
            this.extension.getExternalResources(resources).then(function () {
                var canvas = _this.extension.helper.getCurrentCanvas();
                var annotations = canvas.getContent();
                var $item;
                for (var i = 0; i < annotations.length; i++) {
                    var annotation = annotations[i];
                    if (!annotation.getBody().length) {
                        continue;
                    }
                    $item = _this.$downloadItemTemplate.clone();
                    var $fileName = $item.find('.filename');
                    var $label = $item.find('.label');
                    var $thumb = $item.find('img');
                    var $description = $item.find('.description');
                    var annotationBody = annotation.getBody()[0];
                    var id = annotationBody.getProperty('id');
                    if (id) {
                        $fileName.prop('href', id);
                        $fileName.text(id.substr(id.lastIndexOf('/') + 1));
                    }
                    var label = Manifesto.LanguageMap.getValue(annotationBody.getLabel());
                    if (label) {
                        $label.text(Utils_1.UVUtils.sanitize(label));
                    }
                    var thumbnail = annotation.getProperty('thumbnail');
                    if (thumbnail) {
                        $thumb.prop('src', thumbnail);
                    }
                    else {
                        $thumb.hide();
                    }
                    var description = annotationBody.getProperty('description');
                    if (description) {
                        $description.text(Utils_1.UVUtils.sanitize(description));
                        if (id) {
                            $description.prop('href', id);
                        }
                    }
                    _this.$downloadItems.append($item);
                }
            });
        };
        FileLinkCenterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            if (this.title) {
                this.$title.text(Utils_1.UVUtils.sanitize(this.title));
            }
            this.$scroll.height(this.$content.height() - this.$scroll.verticalMargins());
        };
        return FileLinkCenterPanel;
    }(CenterPanel_1.CenterPanel));
    exports.FileLinkCenterPanel = FileLinkCenterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/HelpDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HelpDialogue = /** @class */ (function (_super) {
        __extends(HelpDialogue, _super);
        function HelpDialogue($element) {
            return _super.call(this, $element) || this;
        }
        HelpDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('helpDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_HELP_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_HELP_DIALOGUE;
            this.component.subscribe(this.openCommand, function () {
                _this.open();
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$title = $('<h1></h1>');
            this.$content.append(this.$title);
            this.$scroll = $('<div class="scroll"></div>');
            this.$content.append(this.$scroll);
            this.$message = $('<p></p>');
            this.$scroll.append(this.$message);
            // initialise ui.
            this.$title.text(this.content.title);
            this.$message.html(this.content.text);
            // ensure anchor tags link to _blank.
            this.$message.targetBlank();
            this.$element.hide();
        };
        HelpDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return HelpDialogue;
    }(Dialogue_1.Dialogue));
    exports.HelpDialogue = HelpDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-resourcesleftpanel-module/ThumbsView',["require", "exports", "../uv-shared-module/ThumbsView"], function (require, exports, ThumbsView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ThumbsView = /** @class */ (function (_super) {
        __extends(ThumbsView, _super);
        function ThumbsView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ThumbsView.prototype.create = function () {
            this.setConfig('resourcesLeftPanel');
            _super.prototype.create.call(this);
        };
        return ThumbsView;
    }(ThumbsView_1.ThumbsView));
    exports.ThumbsView = ThumbsView;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-resourcesleftpanel-module/ResourcesLeftPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/LeftPanel", "./ThumbsView"], function (require, exports, BaseEvents_1, LeftPanel_1, ThumbsView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ResourcesLeftPanel = /** @class */ (function (_super) {
        __extends(ResourcesLeftPanel, _super);
        function ResourcesLeftPanel($element) {
            return _super.call(this, $element) || this;
        }
        ResourcesLeftPanel.prototype.create = function () {
            this.setConfig('resourcesLeftPanel');
            _super.prototype.create.call(this);
            this.setTitle(this.content.title);
            /*
             TODO: make tabs work
            this.$tabs = $('<div class="tabs"></div>');
            this.$main.append(this.$tabs);

            this.$thumbsButton = $('<a class="thumbs tab">' + this.content.thumbnails + '</a>');
            this.$thumbsButton.prop('title', this.content.thumbnails);
            this.$tabs.append(this.$thumbsButton);

            this.$resourcesButton = $('<a class="resources tab">' + this.content.resources+ '</a>');
            this.$resourcesButton.prop('title', this.content.resources);
            this.$tabs.append(this.$resourcesButton);
             */
            this.$tabsContent = $('<div class="tabsContent"></div>');
            this.$main.append(this.$tabsContent);
            this.$views = $('<div class="views"></div>');
            this.$tabsContent.append(this.$views);
            this.$thumbsView = $('<div class="thumbsView"></div>');
            this.$views.append(this.$thumbsView);
            this.$resourcesView = $('<div class="resourcesView"></div>');
            this.$resources = $('<ul></ul>');
            this.$resourcesView.append(this.$resources);
            this.$views.append(this.$resourcesView);
            this.thumbsView = new ThumbsView_1.ThumbsView(this.$thumbsView);
            this.dataBind();
        };
        ResourcesLeftPanel.prototype.dataBind = function () {
            this.dataBindThumbsView();
            var annotations = this.extension.helper.getCurrentCanvas().getResources();
            if (annotations.length === 0) {
                this.$resourcesView.hide();
            }
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                var resource = annotation.getResource();
                if (resource) {
                    var label = Manifesto.LanguageMap.getValue(resource.getLabel());
                    if (label) {
                        var mime = Utils.Files.simplifyMimeType(resource.getFormat().toString());
                        var $listItem = $('<li><a href="' + resource.id + '" target="_blank">' + label + ' (' + mime + ')' + '</li>');
                        this.$resources.append($listItem);
                    }
                }
            }
        };
        ResourcesLeftPanel.prototype.dataBindThumbsView = function () {
            if (!this.thumbsView)
                return;
            var width;
            var height;
            var viewingDirection = this.extension.helper.getViewingDirection();
            if (viewingDirection && (viewingDirection.toString() === manifesto.ViewingDirection.leftToRight().toString() || viewingDirection.toString() === manifesto.ViewingDirection.rightToLeft().toString())) {
                width = this.config.options.twoColThumbWidth;
                height = this.config.options.twoColThumbHeight;
            }
            else {
                width = this.config.options.oneColThumbWidth;
                height = this.config.options.oneColThumbHeight;
            }
            if (typeof (width) === "undefined") {
                width = 100;
            }
            if (typeof (height) === "undefined") {
                height = 100;
            }
            this.thumbsView.thumbs = this.extension.helper.getThumbs(width, height);
            // hide thumb selector for single-part manifests
            if (this.thumbsView.thumbs.length < 2) {
                this.$thumbsView.hide();
            }
            this.thumbsView.databind();
        };
        ResourcesLeftPanel.prototype.expandFullStart = function () {
            _super.prototype.expandFullStart.call(this);
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START);
        };
        ResourcesLeftPanel.prototype.expandFullFinish = function () {
            _super.prototype.expandFullFinish.call(this);
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_FINISH);
        };
        ResourcesLeftPanel.prototype.collapseFullStart = function () {
            _super.prototype.collapseFullStart.call(this);
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_START);
        };
        ResourcesLeftPanel.prototype.collapseFullFinish = function () {
            _super.prototype.collapseFullFinish.call(this);
            this.component.publish(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH);
        };
        ResourcesLeftPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$views.height(this.$main.height());
            this.$resources.height(this.$main.height());
        };
        return ResourcesLeftPanel;
    }(LeftPanel_1.LeftPanel));
    exports.ResourcesLeftPanel = ResourcesLeftPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-default-extension/SettingsDialogue',["require", "exports", "../../modules/uv-dialogues-module/SettingsDialogue"], function (require, exports, SettingsDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsDialogue = /** @class */ (function (_super) {
        __extends(SettingsDialogue, _super);
        function SettingsDialogue($element) {
            return _super.call(this, $element) || this;
        }
        SettingsDialogue.prototype.create = function () {
            this.setConfig('settingsDialogue');
            _super.prototype.create.call(this);
        };
        return SettingsDialogue;
    }(SettingsDialogue_1.SettingsDialogue));
    exports.SettingsDialogue = SettingsDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-default-extension/ShareDialogue',["require", "exports", "../../modules/uv-dialogues-module/ShareDialogue"], function (require, exports, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShareDialogue = /** @class */ (function (_super) {
        __extends(ShareDialogue, _super);
        function ShareDialogue($element) {
            return _super.call(this, $element) || this;
        }
        ShareDialogue.prototype.create = function () {
            this.setConfig('shareDialogue');
            _super.prototype.create.call(this);
        };
        ShareDialogue.prototype.update = function () {
            _super.prototype.update.call(this);
            this.code = this.extension.getEmbedScript(this.options.embedTemplate, this.currentWidth, this.currentHeight);
            this.$code.val(this.code);
        };
        ShareDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ShareDialogue;
    }(ShareDialogue_1.ShareDialogue));
    exports.ShareDialogue = ShareDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-default-extension/Extension',["require", "exports", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-shared-module/BaseExtension", "../../modules/uv-filelinkcenterpanel-module/FileLinkCenterPanel", "../../modules/uv-shared-module/FooterPanel", "../../modules/uv-shared-module/HeaderPanel", "../../modules/uv-dialogues-module/HelpDialogue", "../../modules/uv-moreinforightpanel-module/MoreInfoRightPanel", "../../modules/uv-resourcesleftpanel-module/ResourcesLeftPanel", "./SettingsDialogue", "./ShareDialogue"], function (require, exports, BaseEvents_1, BaseExtension_1, FileLinkCenterPanel_1, FooterPanel_1, HeaderPanel_1, HelpDialogue_1, MoreInfoRightPanel_1, ResourcesLeftPanel_1, SettingsDialogue_1, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Extension = /** @class */ (function (_super) {
        __extends(Extension, _super);
        function Extension() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Extension.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            // listen for mediaelement enter/exit fullscreen events.
            $(window).bind('enterfullscreen', function () {
                _this.component.publish(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN);
            });
            $(window).bind('exitfullscreen', function () {
                _this.component.publish(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.viewCanvas(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.THUMB_SELECTED, function (canvasIndex) {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, canvasIndex);
            });
        };
        Extension.prototype.createModules = function () {
            _super.prototype.createModules.call(this);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel = new HeaderPanel_1.HeaderPanel(this.shell.$headerPanel);
            }
            else {
                this.shell.$headerPanel.hide();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel = new ResourcesLeftPanel_1.ResourcesLeftPanel(this.shell.$leftPanel);
            }
            this.centerPanel = new FileLinkCenterPanel_1.FileLinkCenterPanel(this.shell.$centerPanel);
            if (this.isRightPanelEnabled()) {
                this.rightPanel = new MoreInfoRightPanel_1.MoreInfoRightPanel(this.shell.$rightPanel);
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel = new FooterPanel_1.FooterPanel(this.shell.$footerPanel);
            }
            else {
                this.shell.$footerPanel.hide();
            }
            this.$helpDialogue = $('<div class="overlay help" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$helpDialogue);
            this.helpDialogue = new HelpDialogue_1.HelpDialogue(this.$helpDialogue);
            this.$shareDialogue = $('<div class="overlay share" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$shareDialogue);
            this.shareDialogue = new ShareDialogue_1.ShareDialogue(this.$shareDialogue);
            this.$settingsDialogue = $('<div class="overlay settings" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$settingsDialogue);
            this.settingsDialogue = new SettingsDialogue_1.SettingsDialogue(this.$settingsDialogue);
            if (this.isLeftPanelEnabled()) {
                this.leftPanel.init();
            }
            if (this.isRightPanelEnabled()) {
                this.rightPanel.init();
            }
        };
        Extension.prototype.render = function () {
            _super.prototype.render.call(this);
        };
        Extension.prototype.isLeftPanelEnabled = function () {
            return Utils.Bools.getBool(this.data.config.options.leftPanelEnabled, true)
                && ((this.helper.isMultiCanvas() || this.helper.isMultiSequence()) || this.helper.hasResources());
        };
        Extension.prototype.getEmbedScript = function (template, width, height) {
            //const configUri: string = this.data.config.uri || '';
            //const script: string = String.format(template, this.getSerializedLocales(), configUri, this.helper.iiifResourceUri, this.helper.collectionIndex, this.helper.manifestIndex, this.helper.sequenceIndex, this.helper.canvasIndex, width, height, this.data.embedScriptUri);
            var appUri = this.getAppUri();
            var iframeSrc = appUri + "#?manifest=" + this.helper.iiifResourceUri + "&c=" + this.helper.collectionIndex + "&m=" + this.helper.manifestIndex + "&s=" + this.helper.sequenceIndex + "&cv=" + this.helper.canvasIndex;
            var script = Utils.Strings.format(template, iframeSrc, width.toString(), height.toString());
            return script;
        };
        return Extension;
    }(BaseExtension_1.BaseExtension));
    exports.Extension = Extension;
});

define('modules/uv-shared-module/Bookmark',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Bookmark = /** @class */ (function () {
        function Bookmark() {
        }
        return Bookmark;
    }());
    exports.Bookmark = Bookmark;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-mediaelement-extension/DownloadDialogue',["require", "exports", "../../modules/uv-dialogues-module/DownloadDialogue"], function (require, exports, DownloadDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownloadDialogue = /** @class */ (function (_super) {
        __extends(DownloadDialogue, _super);
        function DownloadDialogue($element) {
            return _super.call(this, $element) || this;
        }
        DownloadDialogue.prototype.create = function () {
            this.setConfig('downloadDialogue');
            _super.prototype.create.call(this);
        };
        DownloadDialogue.prototype.open = function (triggerButton) {
            _super.prototype.open.call(this, triggerButton);
            this.addEntireFileDownloadOptions();
            this.updateNoneAvailable();
            this.resize();
        };
        DownloadDialogue.prototype.isDownloadOptionAvailable = function (option) {
            return _super.prototype.isDownloadOptionAvailable.call(this, option);
        };
        return DownloadDialogue;
    }(DownloadDialogue_1.DownloadDialogue));
    exports.DownloadDialogue = DownloadDialogue;
});

define('extensions/uv-mediaelement-extension/Events',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Events = /** @class */ (function () {
        function Events() {
        }
        Events.namespace = 'mediaelementExtension.';
        Events.MEDIA_ENDED = Events.namespace + 'mediaEnded';
        Events.MEDIA_PAUSED = Events.namespace + 'mediaPaused';
        Events.MEDIA_PLAYED = Events.namespace + 'mediaPlayed';
        return Events;
    }());
    exports.Events = Events;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-mediaelementcenterpanel-module/MediaElementCenterPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../../extensions/uv-mediaelement-extension/Events", "../uv-shared-module/CenterPanel", "../../Utils"], function (require, exports, BaseEvents_1, Events_1, CenterPanel_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MediaElementCenterPanel = /** @class */ (function (_super) {
        __extends(MediaElementCenterPanel, _super);
        function MediaElementCenterPanel($element) {
            return _super.call(this, $element) || this;
        }
        MediaElementCenterPanel.prototype.create = function () {
            this.setConfig('mediaelementCenterPanel');
            _super.prototype.create.call(this);
            var that = this;
            // events.
            // only full screen video
            if (this.isVideo()) {
                this.component.subscribe(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN, function () {
                    if (that.component.isFullScreen) {
                        that.player.enterFullScreen(false);
                    }
                    else {
                        that.player.exitFullScreen(false);
                    }
                });
            }
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, function (resources) {
                that.openMedia(resources);
            });
            this.$container = $('<div class="container"></div>');
            this.$content.append(this.$container);
            this.title = this.extension.helper.getLabel();
        };
        MediaElementCenterPanel.prototype.openMedia = function (resources) {
            var _this = this;
            var that = this;
            this.extension.getExternalResources(resources).then(function () {
                _this.$container.empty();
                var canvas = _this.extension.helper.getCurrentCanvas();
                _this.mediaHeight = _this.config.defaultHeight;
                _this.mediaWidth = _this.config.defaultWidth;
                _this.$container.height(_this.mediaHeight);
                _this.$container.width(_this.mediaWidth);
                var poster = _this.extension.getPosterImageUri();
                var sources = [];
                var renderings = canvas.getRenderings();
                if (renderings && renderings.length) {
                    canvas.getRenderings().forEach(function (rendering) {
                        sources.push({
                            type: rendering.getFormat().toString(),
                            src: rendering.id
                        });
                    });
                }
                else {
                    var formats = _this.extension.getMediaFormats(_this.extension.helper.getCurrentCanvas());
                    if (formats && formats.length) {
                        formats.forEach(function (format) {
                            var type = format.getFormat();
                            if (type) {
                                sources.push({
                                    type: type.toString(),
                                    src: format.id
                                });
                            }
                        });
                    }
                }
                if (_this.isVideo()) {
                    _this.$media = $('<video controls="controls" preload="none"></video>');
                    _this.$container.append(_this.$media);
                    _this.player = new MediaElementPlayer($('video')[0], {
                        //pluginPath: this.extension.data.root + 'lib/mediaelement/',
                        poster: poster,
                        features: ['playpause', 'current', 'progress', 'volume'],
                        success: function (mediaElement, originalNode) {
                            mediaElement.addEventListener('canplay', function () {
                                that.resize();
                            });
                            mediaElement.addEventListener('play', function () {
                                that.component.publish(Events_1.Events.MEDIA_PLAYED, Math.floor(mediaElement.currentTime));
                            });
                            mediaElement.addEventListener('pause', function () {
                                // mediaelement creates a pause event before the ended event. ignore this.
                                if (Math.floor(mediaElement.currentTime) != Math.floor(mediaElement.duration)) {
                                    that.component.publish(Events_1.Events.MEDIA_PAUSED, Math.floor(mediaElement.currentTime));
                                }
                            });
                            mediaElement.addEventListener('ended', function () {
                                that.component.publish(Events_1.Events.MEDIA_ENDED, Math.floor(mediaElement.duration));
                            });
                            mediaElement.setSrc(sources);
                        }
                    });
                }
                else {
                    _this.$media = $('<audio controls="controls" preload="none"></audio>');
                    _this.$container.append(_this.$media);
                    _this.player = new MediaElementPlayer($('audio')[0], {
                        poster: poster,
                        defaultAudioWidth: 'auto',
                        defaultAudioHeight: 'auto',
                        showPosterWhenPaused: true,
                        showPosterWhenEnded: true,
                        success: function (mediaElement, originalNode) {
                            var _this = this;
                            mediaElement.addEventListener('canplay', function () {
                                that.resize();
                            });
                            mediaElement.addEventListener('play', function () {
                                _this.component.publish(Events_1.Events.MEDIA_PLAYED, Math.floor(mediaElement.currentTime));
                            });
                            mediaElement.addEventListener('pause', function () {
                                // mediaelement creates a pause event before the ended event. ignore this.
                                if (Math.floor(mediaElement.currentTime) != Math.floor(mediaElement.duration)) {
                                    _this.component.publish(Events_1.Events.MEDIA_PAUSED, Math.floor(mediaElement.currentTime));
                                }
                            });
                            mediaElement.addEventListener('ended', function () {
                                _this.component.publish(Events_1.Events.MEDIA_ENDED, Math.floor(mediaElement.duration));
                            });
                            mediaElement.setSrc(sources);
                        }
                    });
                }
                _this.resize();
            });
        };
        MediaElementCenterPanel.prototype.isVideo = function () {
            return this.extension.isVideo();
        };
        MediaElementCenterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            // if in Firefox < v13 don't resize the media container.
            if (window.browserDetect.browser === 'Firefox' && window.browserDetect.version < 13) {
                this.$container.width(this.mediaWidth);
                this.$container.height(this.mediaHeight);
            }
            else {
                // fit media to available space.
                var size = Utils.Dimensions.fitRect(this.mediaWidth, this.mediaHeight, this.$content.width(), this.$content.height());
                this.$container.height(size.height);
                this.$container.width(size.width);
                if (this.player && !this.extension.isFullScreen()) {
                    this.$media.width(size.width);
                    this.$media.height(size.height);
                }
            }
            var left = Math.floor((this.$content.width() - this.$container.width()) / 2);
            var top = Math.floor((this.$content.height() - this.$container.height()) / 2);
            this.$container.css({
                'left': left,
                'top': top
            });
            if (this.title) {
                this.$title.text(Utils_1.UVUtils.sanitize(this.title));
            }
            if (this.player) {
                if (!this.isVideo() || (this.isVideo() && !this.component.isFullScreen)) {
                    this.player.setPlayerSize();
                    this.player.setControlsSize();
                    var $mejs = $('.mejs__container');
                    $mejs.css({
                        'margin-top': (this.$container.height() - $mejs.height()) / 2
                    });
                }
            }
        };
        return MediaElementCenterPanel;
    }(CenterPanel_1.CenterPanel));
    exports.MediaElementCenterPanel = MediaElementCenterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-mediaelement-extension/SettingsDialogue',["require", "exports", "../../modules/uv-dialogues-module/SettingsDialogue"], function (require, exports, SettingsDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsDialogue = /** @class */ (function (_super) {
        __extends(SettingsDialogue, _super);
        function SettingsDialogue($element) {
            return _super.call(this, $element) || this;
        }
        SettingsDialogue.prototype.create = function () {
            this.setConfig('settingsDialogue');
            _super.prototype.create.call(this);
        };
        return SettingsDialogue;
    }(SettingsDialogue_1.SettingsDialogue));
    exports.SettingsDialogue = SettingsDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-mediaelement-extension/ShareDialogue',["require", "exports", "../../modules/uv-dialogues-module/ShareDialogue"], function (require, exports, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShareDialogue = /** @class */ (function (_super) {
        __extends(ShareDialogue, _super);
        function ShareDialogue($element) {
            return _super.call(this, $element) || this;
        }
        ShareDialogue.prototype.create = function () {
            this.setConfig('shareDialogue');
            _super.prototype.create.call(this);
        };
        ShareDialogue.prototype.update = function () {
            _super.prototype.update.call(this);
            this.code = this.extension.getEmbedScript(this.options.embedTemplate, this.currentWidth, this.currentHeight);
            this.$code.val(this.code);
        };
        ShareDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ShareDialogue;
    }(ShareDialogue_1.ShareDialogue));
    exports.ShareDialogue = ShareDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-mediaelement-extension/Extension',["require", "exports", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-shared-module/BaseExtension", "../../modules/uv-shared-module/Bookmark", "./DownloadDialogue", "./Events", "../../modules/uv-shared-module/FooterPanel", "../../modules/uv-shared-module/HeaderPanel", "../../modules/uv-dialogues-module/HelpDialogue", "../../modules/uv-mediaelementcenterpanel-module/MediaElementCenterPanel", "../../modules/uv-moreinforightpanel-module/MoreInfoRightPanel", "../../modules/uv-resourcesleftpanel-module/ResourcesLeftPanel", "./SettingsDialogue", "./ShareDialogue"], function (require, exports, BaseEvents_1, BaseExtension_1, Bookmark_1, DownloadDialogue_1, Events_1, FooterPanel_1, HeaderPanel_1, HelpDialogue_1, MediaElementCenterPanel_1, MoreInfoRightPanel_1, ResourcesLeftPanel_1, SettingsDialogue_1, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Extension = /** @class */ (function (_super) {
        __extends(Extension, _super);
        function Extension() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Extension.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            // listen for mediaelement enter/exit fullscreen events.
            $(window).bind('enterfullscreen', function () {
                _this.component.publish(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN);
            });
            $(window).bind('exitfullscreen', function () {
                _this.component.publish(BaseEvents_1.BaseEvents.TOGGLE_FULLSCREEN);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.viewCanvas(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.THUMB_SELECTED, function (thumb) {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, thumb.index);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START, function () {
                _this.shell.$centerPanel.hide();
                _this.shell.$rightPanel.hide();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH, function () {
                _this.shell.$centerPanel.show();
                _this.shell.$rightPanel.show();
                _this.resize();
            });
            this.component.subscribe(Events_1.Events.MEDIA_ENDED, function () {
                _this.fire(Events_1.Events.MEDIA_ENDED);
            });
            this.component.subscribe(Events_1.Events.MEDIA_PAUSED, function () {
                _this.fire(Events_1.Events.MEDIA_PAUSED);
            });
            this.component.subscribe(Events_1.Events.MEDIA_PLAYED, function () {
                _this.fire(Events_1.Events.MEDIA_PLAYED);
            });
        };
        Extension.prototype.createModules = function () {
            _super.prototype.createModules.call(this);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel = new HeaderPanel_1.HeaderPanel(this.shell.$headerPanel);
            }
            else {
                this.shell.$headerPanel.hide();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel = new ResourcesLeftPanel_1.ResourcesLeftPanel(this.shell.$leftPanel);
            }
            this.centerPanel = new MediaElementCenterPanel_1.MediaElementCenterPanel(this.shell.$centerPanel);
            if (this.isRightPanelEnabled()) {
                this.rightPanel = new MoreInfoRightPanel_1.MoreInfoRightPanel(this.shell.$rightPanel);
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel = new FooterPanel_1.FooterPanel(this.shell.$footerPanel);
            }
            else {
                this.shell.$footerPanel.hide();
            }
            this.$helpDialogue = $('<div class="overlay help" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$helpDialogue);
            this.helpDialogue = new HelpDialogue_1.HelpDialogue(this.$helpDialogue);
            this.$downloadDialogue = $('<div class="overlay download" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$downloadDialogue);
            this.downloadDialogue = new DownloadDialogue_1.DownloadDialogue(this.$downloadDialogue);
            this.$shareDialogue = $('<div class="overlay share" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$shareDialogue);
            this.shareDialogue = new ShareDialogue_1.ShareDialogue(this.$shareDialogue);
            this.$settingsDialogue = $('<div class="overlay settings" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$settingsDialogue);
            this.settingsDialogue = new SettingsDialogue_1.SettingsDialogue(this.$settingsDialogue);
            if (this.isLeftPanelEnabled()) {
                this.leftPanel.init();
            }
            if (this.isRightPanelEnabled()) {
                this.rightPanel.init();
            }
        };
        Extension.prototype.render = function () {
            _super.prototype.render.call(this);
        };
        Extension.prototype.isLeftPanelEnabled = function () {
            return Utils.Bools.getBool(this.data.config.options.leftPanelEnabled, true)
                && ((this.helper.isMultiCanvas() || this.helper.isMultiSequence()) || this.helper.hasResources());
        };
        Extension.prototype.bookmark = function () {
            _super.prototype.bookmark.call(this);
            var canvas = this.extensions.helper.getCurrentCanvas();
            var bookmark = new Bookmark_1.Bookmark();
            bookmark.index = this.helper.canvasIndex;
            bookmark.label = Manifesto.LanguageMap.getValue(canvas.getLabel());
            bookmark.thumb = canvas.getProperty('thumbnail');
            bookmark.title = this.helper.getLabel();
            bookmark.trackingLabel = window.trackingLabel;
            if (this.isVideo()) {
                bookmark.type = manifesto.ResourceType.movingimage().toString();
            }
            else {
                bookmark.type = manifesto.ResourceType.sound().toString();
            }
            this.fire(BaseEvents_1.BaseEvents.BOOKMARK, bookmark);
        };
        Extension.prototype.getEmbedScript = function (template, width, height) {
            //const configUri: string = this.data.config.uri || '';
            //const script: string = String.format(template, this.getSerializedLocales(), configUri, this.helper.iiifResourceUri, this.helper.collectionIndex, this.helper.manifestIndex, this.helper.sequenceIndex, this.helper.canvasIndex, width, height, this.data.embedScriptUri);
            var appUri = this.getAppUri();
            var iframeSrc = appUri + "#?manifest=" + this.helper.iiifResourceUri + "&c=" + this.helper.collectionIndex + "&m=" + this.helper.manifestIndex + "&s=" + this.helper.sequenceIndex + "&cv=" + this.helper.canvasIndex;
            var script = Utils.Strings.format(template, iframeSrc, width.toString(), height.toString());
            return script;
        };
        // todo: use canvas.getThumbnail()
        Extension.prototype.getPosterImageUri = function () {
            var canvas = this.helper.getCurrentCanvas();
            var annotations = canvas.getContent();
            if (annotations && annotations.length) {
                return annotations[0].getProperty('thumbnail');
            }
            else {
                return canvas.getProperty('thumbnail');
            }
        };
        Extension.prototype.isVideoFormat = function (type) {
            var videoFormats = [manifesto.MediaType.mp4().toString(), manifesto.MediaType.webm().toString()];
            return videoFormats.indexOf(type) != -1;
        };
        Extension.prototype.isVideo = function () {
            var canvas = this.helper.getCurrentCanvas();
            var annotations = canvas.getContent();
            if (annotations && annotations.length) {
                var formats = this.getMediaFormats(canvas);
                for (var i = 0; i < formats.length; i++) {
                    var format = formats[i];
                    var type = format.getFormat();
                    if (type) {
                        if (this.isVideoFormat(type.toString())) {
                            return true;
                        }
                    }
                }
            }
            else {
                var type = canvas.getType();
                if (type) {
                    return type.toString() === manifesto.ResourceType.movingimage().toString();
                }
            }
            throw (new Error("Unable to determine media type"));
        };
        return Extension;
    }(BaseExtension_1.BaseExtension));
    exports.Extension = Extension;
});

define('modules/uv-shared-module/AnnotationResults',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AnnotationResults = /** @class */ (function () {
        function AnnotationResults() {
        }
        return AnnotationResults;
    }());
    exports.AnnotationResults = AnnotationResults;
});

define('modules/uv-shared-module/Point',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Point = /** @class */ (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        return Point;
    }());
    exports.Point = Point;
});

define('extensions/uv-seadragon-extension/CroppedImageDimensions',["require", "exports", "../../modules/uv-shared-module/Point"], function (require, exports, Point_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Size = Utils.Size;
    var CroppedImageDimensions = /** @class */ (function () {
        function CroppedImageDimensions() {
            this.region = new Size(0, 0);
            this.regionPos = new Point_1.Point(0, 0);
            this.size = new Size(0, 0);
        }
        return CroppedImageDimensions;
    }());
    exports.CroppedImageDimensions = CroppedImageDimensions;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-seadragon-extension/DownloadDialogue',["require", "exports", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-dialogues-module/DownloadDialogue", "../../modules/uv-shared-module/DownloadOption"], function (require, exports, BaseEvents_1, DownloadDialogue_1, DownloadOption_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Size = Manifesto.Size;
    var DownloadDialogue = /** @class */ (function (_super) {
        __extends(DownloadDialogue, _super);
        function DownloadDialogue($element) {
            return _super.call(this, $element) || this;
        }
        DownloadDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('downloadDialogue');
            _super.prototype.create.call(this);
            // create ui.
            this.$settingsButton = $('<a class="settings" href="#">' + this.content.editSettings + '</a>');
            this.$pagingNote = $('<div class="pagingNote">' + this.content.pagingNote + ' </div>');
            this.$pagingNote.append(this.$settingsButton);
            this.$content.append(this.$pagingNote);
            this.$imageOptionsContainer = $('<li class="group image"></li>');
            this.$downloadOptions.append(this.$imageOptionsContainer);
            this.$imageOptions = $('<ul></ul>');
            this.$imageOptionsContainer.append(this.$imageOptions);
            this.$currentViewAsJpgButton = $('<li class="option single"><input id="' + DownloadOption_1.DownloadOption.CURRENT_VIEW + '" type="radio" name="downloadOptions" tabindex="0" /><label for="' + DownloadOption_1.DownloadOption.CURRENT_VIEW + '"></label></li>');
            this.$imageOptions.append(this.$currentViewAsJpgButton);
            this.$currentViewAsJpgButton.hide();
            this.$wholeImageHighResButton = $('<li class="option single"><input id="' + DownloadOption_1.DownloadOption.WHOLE_IMAGE_HIGH_RES + '" type="radio" name="downloadOptions" tabindex="0" /><label id="' + DownloadOption_1.DownloadOption.WHOLE_IMAGE_HIGH_RES + 'label" for="' + DownloadOption_1.DownloadOption.WHOLE_IMAGE_HIGH_RES + '"></label></li>');
            this.$imageOptions.append(this.$wholeImageHighResButton);
            this.$wholeImageHighResButton.hide();
            this.$wholeImagesHighResButton = $('<li class="option multiple"><input id="' + DownloadOption_1.DownloadOption.WHOLE_IMAGES_HIGH_RES + '" type="radio" name="downloadOptions" tabindex="0" /><label id="' + DownloadOption_1.DownloadOption.WHOLE_IMAGES_HIGH_RES + 'label" for="' + DownloadOption_1.DownloadOption.WHOLE_IMAGES_HIGH_RES + '"></label></li>');
            this.$imageOptions.append(this.$wholeImagesHighResButton);
            this.$wholeImageHighResButton.hide();
            this.$wholeImageLowResAsJpgButton = $('<li class="option single"><input id="' + DownloadOption_1.DownloadOption.WHOLE_IMAGE_LOW_RES + '" type="radio" name="downloadOptions" tabindex="0" /><label for="' + DownloadOption_1.DownloadOption.WHOLE_IMAGE_LOW_RES + '">' + this.content.wholeImageLowResAsJpg + '</label></li>');
            this.$imageOptions.append(this.$wholeImageLowResAsJpgButton);
            this.$wholeImageLowResAsJpgButton.hide();
            this.$canvasOptionsContainer = $('<li class="group canvas"></li>');
            this.$downloadOptions.append(this.$canvasOptionsContainer);
            this.$canvasOptions = $('<ul></ul>');
            this.$canvasOptionsContainer.append(this.$canvasOptions);
            this.$manifestOptionsContainer = $('<li class="group manifest"></li>');
            this.$downloadOptions.append(this.$manifestOptionsContainer);
            this.$manifestOptions = $('<ul></ul>');
            this.$manifestOptionsContainer.append(this.$manifestOptions);
            this.$selectionButton = $('<li class="option"><input id="' + DownloadOption_1.DownloadOption.SELECTION + '" type="radio" name="downloadOptions" tabindex="0" /><label id="' + DownloadOption_1.DownloadOption.SELECTION + 'label" for="' + DownloadOption_1.DownloadOption.SELECTION + '"></label></li>');
            this.$manifestOptions.append(this.$selectionButton);
            this.$selectionButton.hide();
            this.$downloadButton = $('<a class="btn btn-primary" href="#" tabindex="0">' + this.content.download + '</a>');
            this.$buttons.prepend(this.$downloadButton);
            this.$explanatoryTextTemplate = $('<span class="explanatory"></span>');
            var that = this;
            // what happens on download is specific to the extension (except for renderings which need to be moved to the base download dialogue)
            // todo: we need to make everything a list of radio button options in the base class, then we can unify everything into a single render method
            this.$downloadButton.on('click', function (e) {
                e.preventDefault();
                var $selectedOption = that.getSelectedOption();
                var id = $selectedOption.attr('id');
                var label = $selectedOption.attr('title');
                var mime = $selectedOption.data('mime');
                var type = DownloadOption_1.DownloadOption.UNKNOWN;
                var canvas = _this.extension.helper.getCurrentCanvas();
                if (_this.renderingUrls[id]) {
                    if (mime) {
                        if (mime.toLowerCase().indexOf('pdf') !== -1) {
                            type = DownloadOption_1.DownloadOption.ENTIRE_DOCUMENT_AS_PDF;
                        }
                        else if (mime.toLowerCase().indexOf('txt') !== -1) {
                            type = DownloadOption_1.DownloadOption.ENTIRE_DOCUMENT_AS_TEXT;
                        }
                    }
                    if (type = DownloadOption_1.DownloadOption.ENTIRE_DOCUMENT_AS_PDF) {
                        //var printService: Manifesto.IService = this.extension.helper.manifest.getService(manifesto.ServiceProfile.printExtensions());
                        // if downloading a pdf - if there's a print service, generate an event instead of opening a new window.
                        // if (printService && this.extension.isOnHomeDomain()){
                        //     this.component.publish(Events.PRINT);
                        // } else {
                        window.open(_this.renderingUrls[id]);
                        //}
                    }
                }
                else {
                    type = id;
                    switch (type) {
                        case DownloadOption_1.DownloadOption.CURRENT_VIEW:
                            var viewer = that.extension.getViewer();
                            window.open(that.extension.getCroppedImageUri(canvas, viewer));
                            break;
                        case DownloadOption_1.DownloadOption.SELECTION:
                            Utils.Async.waitFor(function () {
                                return !_this.isActive;
                            }, function () {
                                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_MULTISELECT_DIALOGUE);
                            });
                            break;
                        case DownloadOption_1.DownloadOption.WHOLE_IMAGE_HIGH_RES:
                            window.open(_this.getCanvasHighResImageUri(_this.extension.helper.getCurrentCanvas()));
                            break;
                        case DownloadOption_1.DownloadOption.WHOLE_IMAGES_HIGH_RES:
                            var indices = _this.extension.getPagedIndices();
                            for (var i = 0; i < indices.length; i++) {
                                window.open(_this.getCanvasHighResImageUri(_this.extension.helper.getCanvasByIndex(indices[i])));
                            }
                            break;
                        case DownloadOption_1.DownloadOption.WHOLE_IMAGE_LOW_RES:
                            var imageUri = that.extension.getConfinedImageUri(canvas, that.options.confinedImageSize);
                            if (imageUri) {
                                window.open(imageUri);
                            }
                            break;
                    }
                }
                _this.component.publish(BaseEvents_1.BaseEvents.DOWNLOAD, {
                    "type": type,
                    "label": label
                });
                _this.close();
            });
            this.$settingsButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.HIDE_DOWNLOAD_DIALOGUE);
                _this.component.publish(BaseEvents_1.BaseEvents.SHOW_SETTINGS_DIALOGUE);
            });
        };
        DownloadDialogue.prototype.open = function (triggerButton) {
            _super.prototype.open.call(this, triggerButton);
            var canvas = this.extension.helper.getCurrentCanvas();
            var rotation = this.extension.getViewerRotation();
            var hasNormalDimensions = rotation % 180 == 0;
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.CURRENT_VIEW)) {
                var $input = this.$currentViewAsJpgButton.find('input');
                var $label = this.$currentViewAsJpgButton.find('label');
                var label = this.content.currentViewAsJpg;
                var viewer = this.extension.getViewer();
                var dimensions = this.extension.getCroppedImageDimensions(canvas, viewer);
                // dimensions
                if (dimensions) {
                    label = hasNormalDimensions ?
                        Utils.Strings.format(label, dimensions.size.width.toString(), dimensions.size.height.toString()) :
                        Utils.Strings.format(label, dimensions.size.height.toString(), dimensions.size.width.toString());
                    $label.text(label);
                    $input.prop('title', label);
                    this.$currentViewAsJpgButton.data('width', dimensions.size.width);
                    this.$currentViewAsJpgButton.data('height', dimensions.size.height);
                    this.$currentViewAsJpgButton.show();
                }
                else {
                    this.$currentViewAsJpgButton.hide();
                }
                // explanatory text
                if (Utils.Bools.getBool(this.options.optionsExplanatoryTextEnabled, false)) {
                    var text = this.content.currentViewAsJpgExplanation;
                    if (text) {
                        var $span = this.$explanatoryTextTemplate.clone();
                        $span.text(text);
                        $label.append($span);
                    }
                }
            }
            else {
                this.$currentViewAsJpgButton.hide();
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.WHOLE_IMAGE_HIGH_RES)) {
                var $input = this.$wholeImageHighResButton.find('input');
                var $label = this.$wholeImageHighResButton.find('label');
                var mime = this.getCanvasMimeType(this.extension.helper.getCurrentCanvas());
                if (mime) {
                    mime = Utils.Files.simplifyMimeType(mime);
                }
                else {
                    mime = '?';
                }
                // dimensions
                var size = this.getCanvasComputedDimensions(this.extension.helper.getCurrentCanvas());
                if (!size) {
                    // if there is no image service, allow the image to be downloaded directly.
                    if (canvas.externalResource && !canvas.externalResource.hasServiceDescriptor()) {
                        var label = Utils.Strings.format(this.content.wholeImageHighRes, '?', '?', mime);
                        $label.text(label);
                        $input.prop('title', label);
                        this.$wholeImageHighResButton.show();
                    }
                    else {
                        this.$wholeImageHighResButton.hide();
                    }
                }
                else {
                    var label = hasNormalDimensions ?
                        Utils.Strings.format(this.content.wholeImageHighRes, size.width.toString(), size.height.toString(), mime) :
                        Utils.Strings.format(this.content.wholeImageHighRes, size.height.toString(), size.width.toString(), mime);
                    $label.text(label);
                    $input.prop('title', label);
                    this.$wholeImageHighResButton.data('width', size.width);
                    this.$wholeImageHighResButton.data('height', size.height);
                    this.$wholeImageHighResButton.show();
                }
                // explanatory text
                if (Utils.Bools.getBool(this.options.optionsExplanatoryTextEnabled, false)) {
                    var text = this.content.wholeImageHighResExplanation;
                    if (text) {
                        var $span = this.$explanatoryTextTemplate.clone();
                        $span.text(text);
                        $label.append($span);
                    }
                }
            }
            else {
                this.$wholeImageHighResButton.hide();
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.WHOLE_IMAGES_HIGH_RES)) {
                var $input = this.$wholeImagesHighResButton.find('input');
                var $label = this.$wholeImagesHighResButton.find('label');
                var mime = this.getCanvasMimeType(this.extension.helper.getCurrentCanvas());
                if (mime) {
                    mime = Utils.Files.simplifyMimeType(mime);
                }
                else {
                    mime = '?';
                }
                var label = Utils.Strings.format(this.content.wholeImagesHighRes, mime);
                $label.text(label);
                $input.prop('title', label);
                this.$wholeImagesHighResButton.show();
                // explanatory text
                if (Utils.Bools.getBool(this.options.optionsExplanatoryTextEnabled, false)) {
                    var text = this.content.wholeImagesHighResExplanation;
                    if (text) {
                        var $span = this.$explanatoryTextTemplate.clone();
                        $span.text(text);
                        $label.append($span);
                    }
                }
            }
            else {
                this.$wholeImagesHighResButton.hide();
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.WHOLE_IMAGE_LOW_RES)) {
                var $input = this.$wholeImageLowResAsJpgButton.find('input');
                var $label = this.$wholeImageLowResAsJpgButton.find('label');
                var size = this.extension.getConfinedImageDimensions(canvas, this.options.confinedImageSize);
                var label = hasNormalDimensions ?
                    Utils.Strings.format(this.content.wholeImageLowResAsJpg, size.width.toString(), size.height.toString()) :
                    Utils.Strings.format(this.content.wholeImageLowResAsJpg, size.height.toString(), size.width.toString());
                $label.text(label);
                $input.prop('title', label);
                this.$wholeImageLowResAsJpgButton.data('width', size.width);
                this.$wholeImageLowResAsJpgButton.data('height', size.height);
                this.$wholeImageLowResAsJpgButton.show();
                // explanatory text
                if (Utils.Bools.getBool(this.options.optionsExplanatoryTextEnabled, false)) {
                    var text = this.content.wholeImageLowResAsJpgExplanation;
                    if (text) {
                        var $span = this.$explanatoryTextTemplate.clone();
                        $span.text(text);
                        $label.append($span);
                    }
                }
            }
            else {
                this.$wholeImageLowResAsJpgButton.hide();
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.SELECTION)) {
                var $input = this.$selectionButton.find('input');
                var $label = this.$selectionButton.find('label');
                $label.text(this.content.downloadSelection);
                $input.prop('title', this.content.downloadSelection);
                this.$selectionButton.show();
                // explanatory text
                if (Utils.Bools.getBool(this.options.optionsExplanatoryTextEnabled, false)) {
                    var text = this.content.selectionExplanation;
                    if (text) {
                        var $span = this.$explanatoryTextTemplate.clone();
                        $span.text(text);
                        $label.append($span);
                    }
                }
            }
            else {
                this.$selectionButton.hide();
            }
            this.resetDynamicDownloadOptions();
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.RANGE_RENDERINGS)) {
                if (canvas.ranges && canvas.ranges.length) {
                    for (var i = 0; i < canvas.ranges.length; i++) {
                        var range = canvas.ranges[i];
                        var renderingOptions = this.getDownloadOptionsForRenderings(range, this.content.entireFileAsOriginal, DownloadOption_1.DownloadOption.CANVAS_RENDERINGS);
                        this.addDownloadOptionsForRenderings(renderingOptions);
                    }
                }
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.IMAGE_RENDERINGS)) {
                var images = canvas.getImages();
                for (var i = 0; i < images.length; i++) {
                    var renderingOptions = this.getDownloadOptionsForRenderings(images[i].getResource(), this.content.entireFileAsOriginal, DownloadOption_1.DownloadOption.IMAGE_RENDERINGS);
                    this.addDownloadOptionsForRenderings(renderingOptions);
                }
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.CANVAS_RENDERINGS)) {
                var renderingOptions = this.getDownloadOptionsForRenderings(canvas, this.content.entireFileAsOriginal, DownloadOption_1.DownloadOption.CANVAS_RENDERINGS);
                this.addDownloadOptionsForRenderings(renderingOptions);
            }
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS)) {
                var renderingOptions = this.getDownloadOptionsForRenderings(this.extension.helper.getCurrentSequence(), this.content.entireDocument, DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS);
                if (!renderingOptions.length) {
                    renderingOptions = this.getDownloadOptionsForRenderings(this.extension.helper.manifest, this.content.entireDocument, DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS);
                }
                this.addDownloadOptionsForRenderings(renderingOptions);
            }
            // hide the current view option if it's equivalent to whole image.
            if (this.isDownloadOptionAvailable(DownloadOption_1.DownloadOption.CURRENT_VIEW)) {
                var currentWidth = parseInt(this.$currentViewAsJpgButton.data('width').toString());
                var currentHeight = parseInt(this.$currentViewAsJpgButton.data('height').toString());
                var wholeWidth = parseInt(this.$wholeImageHighResButton.data('width').toString());
                var wholeHeight = parseInt(this.$wholeImageHighResButton.data('height').toString());
                var percentageWidth = (currentWidth / wholeWidth) * 100;
                var percentageHeight = (currentHeight / wholeHeight) * 100;
                var disabledPercentage = this.options.currentViewDisabledPercentage;
                // if over disabledPercentage of the size of whole image
                if (percentageWidth >= disabledPercentage && percentageHeight >= disabledPercentage) {
                    this.$currentViewAsJpgButton.hide();
                }
                else {
                    this.$currentViewAsJpgButton.show();
                }
            }
            // order by image area
            var $options = this.$imageOptions.find('li.single');
            $options = $options.sort(function (a, b) {
                var aWidth = $(a).data('width');
                aWidth ? aWidth = parseInt(aWidth.toString()) : 0;
                var aHeight = $(a).data('height');
                aHeight ? aHeight = parseInt(aHeight.toString()) : 0;
                var bWidth = $(b).data('width');
                bWidth ? bWidth = parseInt(bWidth.toString()) : 0;
                var bHeight = $(b).data('height');
                bHeight ? bHeight = parseInt(bHeight.toString()) : 0;
                var aArea = aWidth * aHeight;
                var bArea = bWidth * bHeight;
                if (aArea < bArea) {
                    return -1;
                }
                if (aArea > bArea) {
                    return 1;
                }
                return 0;
            });
            $options.detach().appendTo(this.$imageOptions);
            // hide empty groups
            var $groups = this.$downloadOptions.find('li.group');
            $groups.each(function (index, group) {
                var $group = $(group);
                $group.show();
                if ($group.find('li.option:hidden').length === $group.find('li.option').length) {
                    // all options are hidden, hide group.
                    $group.hide();
                }
            });
            this.$downloadOptions.find('li.group:visible').last().addClass('lastVisible');
            if (this.extension.isPagingSettingEnabled() && (this.config.options.downloadPagingNoteEnabled)) {
                this.$pagingNote.show();
            }
            else {
                this.$pagingNote.hide();
            }
            if (!this.$downloadOptions.find('li.option:visible').length) {
                this.$noneAvailable.show();
                this.$downloadButton.hide();
            }
            else {
                // select first option.
                this.$downloadOptions.find('li.option input:visible:first').prop("checked", true);
                this.$noneAvailable.hide();
                this.$downloadButton.show();
            }
            this.resize();
        };
        DownloadDialogue.prototype.addDownloadOptionsForRenderings = function (renderingOptions) {
            var _this = this;
            renderingOptions.forEach(function (option) {
                switch (option.type) {
                    case DownloadOption_1.DownloadOption.IMAGE_RENDERINGS:
                        _this.$imageOptions.append(option.button);
                        break;
                    case DownloadOption_1.DownloadOption.CANVAS_RENDERINGS:
                        _this.$canvasOptions.append(option.button);
                        break;
                    case DownloadOption_1.DownloadOption.MANIFEST_RENDERINGS:
                        _this.$manifestOptions.append(option.button);
                        break;
                }
            });
        };
        DownloadDialogue.prototype.getCanvasImageResource = function (canvas) {
            var images = canvas.getImages();
            if (images[0]) {
                return images[0].getResource();
            }
            return null;
        };
        DownloadDialogue.prototype.getCanvasHighResImageUri = function (canvas) {
            var size = this.getCanvasComputedDimensions(canvas);
            if (size) {
                var width = size.width;
                var uri = canvas.getCanonicalImageUri(width);
                if (canvas.externalResource && canvas.externalResource.hasServiceDescriptor()) {
                    var uri_parts = uri.split('/');
                    var rotation = this.extension.getViewerRotation();
                    uri_parts[uri_parts.length - 2] = String(rotation);
                    uri = uri_parts.join('/');
                }
                return uri;
            }
            else if (canvas.externalResource && !canvas.externalResource.hasServiceDescriptor()) {
                // if there is no image service, return the dataUri.
                return canvas.externalResource.dataUri;
            }
            return '';
        };
        DownloadDialogue.prototype.getCanvasMimeType = function (canvas) {
            var resource = this.getCanvasImageResource(canvas);
            if (resource) {
                var format = resource.getFormat();
                if (format) {
                    return format.toString();
                }
            }
            return null;
        };
        DownloadDialogue.prototype.getCanvasDimensions = function (canvas) {
            // externalResource may not have loaded yet
            if (canvas.externalResource.data) {
                var width = canvas.externalResource.data.width;
                var height = canvas.externalResource.data.height;
                if (width && height) {
                    return new Size(width, height);
                }
            }
            return null;
        };
        DownloadDialogue.prototype.getCanvasComputedDimensions = function (canvas) {
            var imageSize = this.getCanvasDimensions(canvas);
            var requiredSize = canvas.getMaxDimensions();
            if (!imageSize) {
                return null;
            }
            if (!requiredSize) {
                return imageSize;
            }
            if (imageSize.width <= requiredSize.width && imageSize.height <= requiredSize.height) {
                return imageSize;
            }
            var scaleW = requiredSize.width / imageSize.width;
            var scaleH = requiredSize.height / imageSize.height;
            var scale = Math.min(scaleW, scaleH);
            return new Size(Math.floor(imageSize.width * scale), Math.floor(imageSize.height * scale));
        };
        DownloadDialogue.prototype._isLevel0 = function (profile) {
            if (!profile || !profile.length)
                return false;
            return manifesto.Utils.isLevel0ImageProfile(profile[0]);
        };
        DownloadDialogue.prototype.isDownloadOptionAvailable = function (option) {
            if (!this.extension.resources) {
                return false;
            }
            var canvas = this.extension.helper.getCurrentCanvas();
            // if the external resource doesn't have a service descriptor or is level 0
            // only allow wholeImageHighRes
            if (!canvas.externalResource.hasServiceDescriptor() || this._isLevel0(canvas.externalResource.data.profile)) {
                if (option === DownloadOption_1.DownloadOption.WHOLE_IMAGE_HIGH_RES) {
                    // if in one-up mode, or in two-up mode with a single page being shown
                    if (!this.extension.isPagingSettingEnabled() ||
                        this.extension.isPagingSettingEnabled() && this.extension.resources && this.extension.resources.length === 1) {
                        return true;
                    }
                }
                return false;
            }
            switch (option) {
                case DownloadOption_1.DownloadOption.CURRENT_VIEW:
                case DownloadOption_1.DownloadOption.CANVAS_RENDERINGS:
                case DownloadOption_1.DownloadOption.IMAGE_RENDERINGS:
                case DownloadOption_1.DownloadOption.WHOLE_IMAGE_HIGH_RES:
                    // if in one-up mode, or in two-up mode with a single page being shown
                    if (!this.extension.isPagingSettingEnabled() ||
                        this.extension.isPagingSettingEnabled() && this.extension.resources && this.extension.resources.length === 1) {
                        var maxDimensions = canvas.getMaxDimensions();
                        if (maxDimensions) {
                            if (maxDimensions.width <= this.options.maxImageWidth) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                case DownloadOption_1.DownloadOption.WHOLE_IMAGES_HIGH_RES:
                    if (this.extension.isPagingSettingEnabled() && this.extension.resources && this.extension.resources.length > 1) {
                        return true;
                    }
                    return false;
                case DownloadOption_1.DownloadOption.WHOLE_IMAGE_LOW_RES:
                    // hide low-res option if hi-res width is smaller than constraint
                    var size = this.getCanvasComputedDimensions(canvas);
                    if (!size) {
                        return false;
                    }
                    return (!this.extension.isPagingSettingEnabled() && (size.width > this.options.confinedImageSize));
                case DownloadOption_1.DownloadOption.SELECTION:
                    return this.options.selectionEnabled;
                case DownloadOption_1.DownloadOption.RANGE_RENDERINGS:
                    if (canvas.ranges && canvas.ranges.length) {
                        var range = canvas.ranges[0];
                        return range.getRenderings().length > 0;
                    }
                    return false;
                default:
                    return _super.prototype.isDownloadOptionAvailable.call(this, option);
            }
        };
        return DownloadDialogue;
    }(DownloadDialogue_1.DownloadDialogue));
    exports.DownloadDialogue = DownloadDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/ExternalContentDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue"], function (require, exports, BaseEvents_1, Dialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExternalContentDialogue = /** @class */ (function (_super) {
        __extends(ExternalContentDialogue, _super);
        function ExternalContentDialogue($element) {
            return _super.call(this, $element) || this;
        }
        ExternalContentDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('externalContentDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_EXTERNALCONTENT_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_EXTERNALCONTENT_DIALOGUE;
            this.component.subscribe(this.openCommand, function (params) {
                _this.open();
                _this.$iframe.prop('src', params.uri);
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.$iframe = $('<iframe></iframe>');
            this.$content.append(this.$iframe);
            this.$element.hide();
        };
        ExternalContentDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$iframe.width(this.$content.width());
            this.$iframe.height(this.$content.height());
        };
        return ExternalContentDialogue;
    }(Dialogue_1.Dialogue));
    exports.ExternalContentDialogue = ExternalContentDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-osdmobilefooterpanel-module/MobileFooter',["require", "exports", "../uv-shared-module/FooterPanel", "../../extensions/uv-seadragon-extension/Events"], function (require, exports, FooterPanel_1, Events_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FooterPanel = /** @class */ (function (_super) {
        __extends(FooterPanel, _super);
        function FooterPanel($element) {
            return _super.call(this, $element) || this;
        }
        FooterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('mobileFooterPanel');
            _super.prototype.create.call(this);
            this.$spacer = $('<div class="spacer"></div>');
            this.$options.prepend(this.$spacer);
            this.$rotateButton = $("\n            <button class=\"btn imageBtn rotate\" title=\"" + this.content.rotateRight + "\">\n                <i class=\"uv-icon-rotate\" aria-hidden=\"true\"></i>" + this.content.rotateRight + "\n            </button>\n        ");
            this.$options.prepend(this.$rotateButton);
            this.$zoomOutButton = $("\n            <button class=\"btn imageBtn zoomOut\" title=\"" + this.content.zoomOut + "\">\n                <i class=\"uv-icon-zoom-out\" aria-hidden=\"true\"></i>" + this.content.zoomOut + "\n            </button>\n        ");
            this.$options.prepend(this.$zoomOutButton);
            this.$zoomInButton = $("\n            <button class=\"btn imageBtn zoomIn\" title=\"" + this.content.zoomIn + "\">\n                <i class=\"uv-icon-zoom-in\" aria-hidden=\"true\"></i>" + this.content.zoomIn + "\n            </button>\n        ");
            this.$options.prepend(this.$zoomInButton);
            this.$zoomInButton.onPressed(function () {
                _this.component.publish(Events_1.Events.ZOOM_IN);
            });
            this.$zoomOutButton.onPressed(function () {
                _this.component.publish(Events_1.Events.ZOOM_OUT);
            });
            this.$rotateButton.onPressed(function () {
                _this.component.publish(Events_1.Events.ROTATE);
            });
        };
        FooterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this.$options.css('left', Math.floor((this.$element.width() / 2) - (this.$options.width() / 2)));
        };
        return FooterPanel;
    }(FooterPanel_1.FooterPanel));
    exports.FooterPanel = FooterPanel;
});

define('modules/uv-shared-module/AutoComplete',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AutoComplete = /** @class */ (function () {
        function AutoComplete(element, autoCompleteFunc, parseResultsFunc, onSelect, delay, minChars, positionAbove, allowWords) {
            if (delay === void 0) { delay = 300; }
            if (minChars === void 0) { minChars = 2; }
            if (positionAbove === void 0) { positionAbove = false; }
            if (allowWords === void 0) { allowWords = false; }
            var _this = this;
            this._$element = element;
            this._autoCompleteFunc = autoCompleteFunc;
            this._delay = delay;
            this._minChars = minChars;
            this._onSelect = onSelect;
            this._parseResultsFunc = parseResultsFunc;
            this._positionAbove = positionAbove;
            this._allowWords = allowWords;
            // create ui.
            this._$searchResultsList = $('<ul class="autocomplete"></ul>');
            if (this._positionAbove) {
                this._$element.parent().prepend(this._$searchResultsList);
            }
            else {
                this._$element.parent().append(this._$searchResultsList);
            }
            this._$searchResultTemplate = $('<li class="result"><a href="#" tabindex="-1"></a></li>');
            // init ui.
            // callback after set period.
            var typewatch = (function () {
                var timer = 0;
                return function (cb, ms) {
                    clearTimeout(timer);
                    timer = setTimeout(cb, ms);
                };
            })();
            var that = this;
            this._$element.on("keydown", function (e) {
                var originalEvent = e.originalEvent;
                //that._lastKeyDownWasNavigation = that._isNavigationKeyDown(originalEvent);
                var charCode = Utils.Keyboard.getCharCode(originalEvent);
                var cancelEvent = false;
                if (charCode === KeyCodes.KeyDown.LeftArrow) {
                    cancelEvent = true;
                }
                else if (charCode === KeyCodes.KeyDown.RightArrow) {
                    cancelEvent = true;
                }
                if (cancelEvent) {
                    originalEvent.cancelBubble = true;
                    if (originalEvent.stopPropagation)
                        originalEvent.stopPropagation();
                }
            });
            // auto complete
            this._$element.on("keyup", function (e) {
                // if pressing enter without a list item selected
                if (!that._getSelectedListItem().length && e.keyCode === KeyCodes.KeyDown.Enter) {
                    that._onSelect(that._getTerms());
                    return;
                }
                // If there are search results
                if (that._$searchResultsList.is(':visible') && that._results.length) {
                    if (e.keyCode === KeyCodes.KeyDown.Enter) {
                        that._searchForItem(that._getSelectedListItem());
                    }
                    else if (e.keyCode === KeyCodes.KeyDown.DownArrow) {
                        that._setSelectedResultIndex(1);
                        return;
                    }
                    else if (e.keyCode === KeyCodes.KeyDown.UpArrow) {
                        that._setSelectedResultIndex(-1);
                        return;
                    }
                }
                if (e.keyCode !== KeyCodes.KeyDown.Enter) {
                    // after a delay, show autocomplete list.
                    typewatch(function () {
                        var val = that._getTerms();
                        // if there are more than x chars
                        // update the autocomplete list.
                        if (val && val.length > that._minChars && that._searchForWords(val)) {
                            that._search(val);
                        }
                        else {
                            // otherwise, hide the autocomplete list.
                            that._clearResults();
                            that._hideResults();
                        }
                    }, that._delay);
                }
            });
            // hide results if clicked outside.
            $(document).on('mouseup', function (e) {
                if (_this._$searchResultsList.parent().has($(e.target)[0]).length === 0) {
                    _this._clearResults();
                    _this._hideResults();
                }
            });
            this._hideResults();
        }
        AutoComplete.prototype._searchForWords = function (search) {
            if (this._allowWords || !search.includes(' ')) {
                return true;
            }
            else {
                return false;
            }
        };
        AutoComplete.prototype._getTerms = function () {
            return this._$element.val().trim();
        };
        AutoComplete.prototype._setSelectedResultIndex = function (direction) {
            var nextIndex;
            if (direction === 1) {
                nextIndex = this._selectedResultIndex + 1;
            }
            else {
                nextIndex = this._selectedResultIndex - 1;
            }
            var $items = this._$searchResultsList.find('li');
            if (nextIndex < 0) {
                nextIndex = $items.length - 1;
            }
            else if (nextIndex > $items.length - 1) {
                nextIndex = 0;
            }
            this._selectedResultIndex = nextIndex;
            $items.removeClass('selected');
            var $selectedItem = $items.eq(this._selectedResultIndex);
            $selectedItem.addClass('selected');
            var top = $selectedItem.outerHeight(true) * this._selectedResultIndex;
            this._$searchResultsList.scrollTop(top);
        };
        AutoComplete.prototype._search = function (term) {
            this._results = [];
            this._clearResults();
            this._showResults();
            this._$searchResultsList.append('<li class="loading"></li>');
            this._updateListPosition();
            var that = this;
            this._autoCompleteFunc(term, function (results) {
                that._listResults(results);
            });
        };
        AutoComplete.prototype._clearResults = function () {
            this._$searchResultsList.empty();
        };
        AutoComplete.prototype._hideResults = function () {
            this._$searchResultsList.hide();
        };
        AutoComplete.prototype._showResults = function () {
            this._selectedResultIndex = -1;
            this._$searchResultsList.show();
        };
        AutoComplete.prototype._updateListPosition = function () {
            if (this._positionAbove) {
                this._$searchResultsList.css({
                    'top': this._$searchResultsList.outerHeight(true) * -1
                });
            }
            else {
                this._$searchResultsList.css({
                    'top': this._$element.outerHeight(true)
                });
            }
        };
        AutoComplete.prototype._listResults = function (results) {
            // get an array of strings
            this._results = this._parseResultsFunc(results);
            this._clearResults();
            if (!this._results.length) {
                // don't do this, because there still may be results for the PHRASE but not the word.
                // they won't know until they do the search.
                //this.searchResultsList.append('<li>no results</li>');
                this._hideResults();
                return;
            }
            for (var i = 0; i < this._results.length; i++) {
                var result = this._results[i];
                var $resultItem = this._$searchResultTemplate.clone();
                var $a = $resultItem.find('a');
                $a.text(result);
                this._$searchResultsList.append($resultItem);
            }
            this._updateListPosition();
            var that = this;
            this._$searchResultsList.find('li').on('click', function (e) {
                e.preventDefault();
                that._searchForItem($(this));
            });
        };
        AutoComplete.prototype._searchForItem = function ($item) {
            var term = $item.find('a').text();
            this._$element.val(term);
            this._hideResults();
            this._onSelect(term);
            this._clearResults();
            this._hideResults();
        };
        AutoComplete.prototype._getSelectedListItem = function () {
            return this._$searchResultsList.find('li.selected');
        };
        return AutoComplete;
    }());
    exports.AutoComplete = AutoComplete;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-searchfooterpanel-module/FooterPanel',["require", "exports", "../uv-shared-module/AutoComplete", "../uv-shared-module/BaseEvents", "../../extensions/uv-seadragon-extension/Events", "../uv-shared-module/FooterPanel", "../../extensions/uv-seadragon-extension/Mode", "../../Utils"], function (require, exports, AutoComplete_1, BaseEvents_1, Events_1, FooterPanel_1, Mode_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FooterPanel = /** @class */ (function (_super) {
        __extends(FooterPanel, _super);
        function FooterPanel($element) {
            var _this = _super.call(this, $element) || this;
            _this.placemarkerTouched = false;
            return _this;
        }
        FooterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('searchFooterPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function () {
                _this.canvasIndexChanged();
                _this.setCurrentSearchResultPlacemarker();
                _this.updatePrevButton();
                _this.updateNextButton();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLEAR_ANNOTATIONS, function () {
                _this.clearSearchResults();
            });
            // todo: this should be a setting
            this.component.subscribe(Events_1.Events.MODE_CHANGED, function () {
                _this.settingsChanged();
            });
            this.component.subscribe(Events_1.Events.SEARCH, function (terms) {
                _this.terms = terms;
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS, function (annotationResults) {
                _this.displaySearchResults(annotationResults.annotations, annotationResults.terms);
                _this.setCurrentSearchResultPlacemarker();
                _this.updatePrevButton();
                _this.updateNextButton();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS_EMPTY, function () {
                _this.hideSearchSpinner();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATION_CHANGED, function () {
                _this.updatePrevButton();
                _this.updateNextButton();
            });
            this.$printButton = $("\n          <button class=\"print btn imageBtn\" title=\"" + this.content.print + "\" tabindex=\"0\">\n            <i class=\"uv-icon uv-icon-print\" aria-hidden=\"true\"></i>" + this.content.print + "\n          </button>\n        ");
            this.$options.prepend(this.$printButton);
            // search input.
            this.$searchContainer = $('<div class="search"></div>');
            this.$element.prepend(this.$searchContainer);
            this.$searchOptions = $('<div class="searchOptions"></div>');
            this.$searchContainer.append(this.$searchOptions);
            this.$searchLabel = $('<span class="label">' + this.content.searchWithin + '</span>');
            this.$searchOptions.append(this.$searchLabel);
            this.$searchTextContainer = $('<div class="searchTextContainer"></div>');
            this.$searchOptions.append(this.$searchTextContainer);
            this.$searchText = $('<input class="searchText" type="text" maxlength="100" value="' + this.content.enterKeyword + '" aria-label="' + this.content.searchWithin + '"/>');
            this.$searchTextContainer.append(this.$searchText);
            this.$searchButton = $('<a class="imageButton searchButton" tabindex="0"></a>');
            this.$searchTextContainer.append(this.$searchButton);
            // search results.
            this.$searchPagerContainer = $('<div class="searchPager"></div>');
            this.$element.prepend(this.$searchPagerContainer);
            this.$searchPagerControls = $('<div class="controls"></div>');
            this.$searchPagerContainer.prepend(this.$searchPagerControls);
            this.$previousResultButton = $('<a class="previousResult" title="' + this.content.previousResult + '">' + this.content.previousResult + '</a>');
            this.$searchPagerControls.append(this.$previousResultButton);
            this.$searchResultsInfo = $('<div class="searchResultsInfo"><span class="info"><span class="number">x</span> <span class="foundFor"></span> \'<span class="terms">y</span>\'<?span></div>');
            this.$searchPagerControls.append(this.$searchResultsInfo);
            this.$clearSearchResultsButton = $('<a class="clearSearch" title="' + this.content.clearSearch + '">' + this.content.clearSearch + '</a>');
            this.$searchResultsInfo.append(this.$clearSearchResultsButton);
            this.$nextResultButton = $('<a class="nextResult" title="' + this.content.nextResult + '">' + this.content.nextResult + '</a>');
            this.$searchPagerControls.append(this.$nextResultButton);
            // placemarker line.
            this.$searchResultsContainer = $('<div class="searchResults"></div>');
            this.$element.prepend(this.$searchResultsContainer);
            this.$line = $('<div class="line"></div>');
            this.$searchResultsContainer.append(this.$line);
            this.$pagePositionMarker = $('<div class="positionPlacemarker"></div>');
            this.$searchResultsContainer.append(this.$pagePositionMarker);
            this.$pagePositionLabel = $('<div class="label"></div>');
            this.$searchResultsContainer.append(this.$pagePositionLabel);
            this.$placemarkerDetails = $('<div class="placeMarkerDetails"></div>');
            this.$searchResultsContainer.append(this.$placemarkerDetails);
            this.$placemarkerDetailsTop = $('<h1></h1>');
            this.$placemarkerDetails.append(this.$placemarkerDetailsTop);
            this.$placemarkerDetailsBottom = $('<p></p>');
            this.$placemarkerDetails.append(this.$placemarkerDetailsBottom);
            // initialise ui.
            this.$searchPagerContainer.hide();
            this.$placemarkerDetails.hide();
            // ui event handlers.
            var that = this;
            this.$searchButton.on('click', function (e) {
                e.preventDefault();
                _this.search(_this.$searchText.val());
            });
            this.$searchText.on('focus', function () {
                // clear initial text.
                if (_this.$searchText.val() === _this.content.enterKeyword)
                    _this.$searchText.val('');
            });
            this.$placemarkerDetails.on('mouseover', function () {
                that.component.publish(Events_1.Events.SEARCH_PREVIEW_START, _this.currentPlacemarkerIndex);
            });
            this.$placemarkerDetails.on('mouseleave', function () {
                $(this).hide();
                that.component.publish(Events_1.Events.SEARCH_PREVIEW_FINISH);
                // reset all placemarkers.
                var placemarkers = that.getSearchResultPlacemarkers();
                placemarkers.removeClass('hover');
            });
            this.$placemarkerDetails.on('click', function () {
                that.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.currentPlacemarkerIndex);
            });
            this.$previousResultButton.on('click', function (e) {
                e.preventDefault();
                if (_this.isPreviousButtonEnabled()) {
                    that.component.publish(Events_1.Events.PREV_SEARCH_RESULT);
                }
            });
            this.$nextResultButton.on('click', function (e) {
                e.preventDefault();
                if (_this.isNextButtonEnabled()) {
                    that.component.publish(Events_1.Events.NEXT_SEARCH_RESULT);
                }
            });
            this.$clearSearchResultsButton.on('click', function (e) {
                e.preventDefault();
                that.component.publish(BaseEvents_1.BaseEvents.CLEAR_ANNOTATIONS);
            });
            // hide search options if not enabled/supported.
            if (!this.isSearchEnabled()) {
                this.$searchContainer.hide();
                this.$searchPagerContainer.hide();
                this.$searchResultsContainer.hide();
                this.$element.addClass('min');
            }
            if (this.extension.helper.getTotalCanvases() === 1) {
                this.$searchResultsContainer.hide();
            }
            var autocompleteService = this.extension.getAutoCompleteUri();
            if (autocompleteService) {
                new AutoComplete_1.AutoComplete(this.$searchText, function (terms, cb) {
                    $.getJSON(Utils.Strings.format(autocompleteService, terms), function (results) {
                        cb(results);
                    });
                }, function (results) {
                    return $.map(results.terms, function (result) {
                        return result.match;
                    });
                }, function (terms) {
                    _this.search(terms);
                }, 300, 2, true, Utils.Bools.getBool(this.options.autocompleteAllowWords, false));
            }
            else {
                this.$searchText.on("keyup", function (e) {
                    if (e.keyCode === KeyCodes.KeyDown.Enter) {
                        that.search(that.$searchText.val());
                    }
                });
            }
            this.$printButton.onPressed(function () {
                that.component.publish(Events_1.Events.PRINT);
            });
            this.updatePrintButton();
            var positionMarkerEnabled = Utils.Bools.getBool(this.config.options.positionMarkerEnabled, true);
            if (!positionMarkerEnabled) {
                this.$pagePositionMarker.hide();
                this.$pagePositionLabel.hide();
            }
        };
        FooterPanel.prototype.isSearchEnabled = function () {
            return this.extension.isSearchEnabled();
        };
        FooterPanel.prototype.isZoomToSearchResultEnabled = function () {
            return Utils.Bools.getBool(this.extension.data.config.options.zoomToSearchResultEnabled, true);
        };
        FooterPanel.prototype.isPreviousButtonEnabled = function () {
            var currentCanvasIndex = this.extension.helper.canvasIndex;
            var firstSearchResultCanvasIndex = this.getFirstSearchResultCanvasIndex();
            var currentSearchResultRectIndex = this.getCurrentSearchResultRectIndex();
            // if zoom to search result is enabled and there is a highlighted search result.
            if (this.isZoomToSearchResultEnabled() && this.extension.currentAnnotationRect) {
                if (currentCanvasIndex < firstSearchResultCanvasIndex) {
                    return false;
                }
                else if (currentCanvasIndex === firstSearchResultCanvasIndex) {
                    if (currentSearchResultRectIndex === 0) {
                        return false;
                    }
                }
                return true;
            }
            return (currentCanvasIndex > firstSearchResultCanvasIndex);
        };
        FooterPanel.prototype.isNextButtonEnabled = function () {
            var currentCanvasIndex = this.extension.helper.canvasIndex;
            var lastSearchResultCanvasIndex = this.getLastSearchResultCanvasIndex();
            var currentSearchResultRectIndex = this.getCurrentSearchResultRectIndex();
            // if zoom to search result is enabled and there is a highlighted search result.
            if (this.isZoomToSearchResultEnabled() && this.extension.currentAnnotationRect) {
                if (currentCanvasIndex > lastSearchResultCanvasIndex) {
                    return false;
                }
                else if (currentCanvasIndex === lastSearchResultCanvasIndex) {
                    if (currentSearchResultRectIndex === this.getLastSearchResultRectIndex()) {
                        return false;
                    }
                }
                return true;
            }
            return (currentCanvasIndex < lastSearchResultCanvasIndex);
        };
        FooterPanel.prototype.getSearchResults = function () {
            return this.extension.annotations;
        };
        FooterPanel.prototype.getCurrentSearchResultRectIndex = function () {
            return this.extension.getCurrentAnnotationRectIndex();
        };
        FooterPanel.prototype.getFirstSearchResultCanvasIndex = function () {
            var searchResults = this.getSearchResults();
            if (!searchResults)
                return -1;
            var firstSearchResultCanvasIndex = searchResults[0].canvasIndex;
            return firstSearchResultCanvasIndex;
        };
        FooterPanel.prototype.getLastSearchResultCanvasIndex = function () {
            var searchResults = this.getSearchResults();
            if (!searchResults)
                return -1;
            var lastSearchResultCanvasIndex = searchResults[searchResults.length - 1].canvasIndex;
            return lastSearchResultCanvasIndex;
        };
        FooterPanel.prototype.getLastSearchResultRectIndex = function () {
            return this.extension.getLastAnnotationRectIndex();
        };
        FooterPanel.prototype.updateNextButton = function () {
            var searchResults = this.getSearchResults();
            if (searchResults && searchResults.length) {
                if (this.isNextButtonEnabled()) {
                    this.$nextResultButton.removeClass('disabled');
                }
                else {
                    this.$nextResultButton.addClass('disabled');
                }
            }
        };
        FooterPanel.prototype.updatePrevButton = function () {
            var searchResults = this.getSearchResults();
            if (searchResults && searchResults.length) {
                if (this.isPreviousButtonEnabled()) {
                    this.$previousResultButton.removeClass('disabled');
                }
                else {
                    this.$previousResultButton.addClass('disabled');
                }
            }
        };
        FooterPanel.prototype.updatePrintButton = function () {
            var configEnabled = Utils.Bools.getBool(this.options.printEnabled, false);
            //var printService: Manifesto.IService = this.extension.helper.manifest.getService(manifesto.ServiceProfile.printExtensions());
            //if (configEnabled && printService && this.extension.isOnHomeDomain()){
            if (configEnabled) {
                this.$printButton.show();
            }
            else {
                this.$printButton.hide();
            }
        };
        FooterPanel.prototype.search = function (terms) {
            this.terms = terms;
            if (this.terms === '' || this.terms === this.content.enterKeyword) {
                this.extension.showMessage(this.config.modules.genericDialogue.content.emptyValue, function () {
                    this.$searchText.focus();
                });
                return;
            }
            // blur search field
            this.$searchText.blur();
            this.showSearchSpinner();
            this.component.publish(Events_1.Events.SEARCH, this.terms);
        };
        FooterPanel.prototype.getSearchResultPlacemarkers = function () {
            return this.$searchResultsContainer.find('.searchResultPlacemarker');
        };
        FooterPanel.prototype.setCurrentSearchResultPlacemarker = function () {
            var placemarkers = this.getSearchResultPlacemarkers();
            placemarkers.parent().find('.current').removeClass('current');
            var $current = $('.searchResultPlacemarker[data-index="' + this.extension.helper.canvasIndex + '"]');
            $current.addClass('current');
        };
        FooterPanel.prototype.positionSearchResultPlacemarkers = function () {
            var searchResults = this.getSearchResults();
            if (!searchResults || !searchResults.length)
                return;
            // clear all existing placemarkers
            var placemarkers = this.getSearchResultPlacemarkers();
            placemarkers.remove();
            var pageWidth = this.getPageLineRatio();
            var lineTop = this.$line.position().top;
            var lineLeft = this.$line.position().left;
            var that = this;
            // for each page with a result, place a marker along the line.
            for (var i = 0; i < searchResults.length; i++) {
                var result = searchResults[i];
                var distance = result.canvasIndex * pageWidth;
                var $placemarker = $('<div class="searchResultPlacemarker" data-index="' + result.canvasIndex + '"></div>');
                $placemarker[0].ontouchstart = function (e) { that.onPlacemarkerTouchStart.call(this, that); };
                $placemarker.click(function (e) { that.onPlacemarkerClick.call(this, that); });
                $placemarker.mouseenter(function (e) { that.onPlacemarkerMouseEnter.call(this, that); });
                $placemarker.mouseleave(function (e) { that.onPlacemarkerMouseLeave.call(this, e, that); });
                this.$searchResultsContainer.append($placemarker);
                var top_1 = lineTop - $placemarker.height();
                var left = lineLeft + distance - ($placemarker.width() / 2);
                $placemarker.css({
                    top: top_1,
                    left: left
                });
            }
        };
        FooterPanel.prototype.onPlacemarkerTouchStart = function (that) {
            that.placemarkerTouched = true;
            //const $placemarker: JQuery = $(this);
            //const index: number = parseInt($placemarker.attr('data-index'));
            //this.component.publish(Events.VIEW_PAGE, [index]);
        };
        FooterPanel.prototype.onPlacemarkerClick = function (that) {
            if (that.placemarkerTouched)
                return;
            that.placemarkerTouched = false;
            //const $placemarker: JQuery = $(this);
            //const index: number = parseInt($placemarker.attr('data-index'));
            //this.component.publish(Events.VIEW_PAGE, [index]);
        };
        FooterPanel.prototype.onPlacemarkerMouseEnter = function (that) {
            if (that.placemarkerTouched)
                return;
            var $placemarker = $(this);
            $placemarker.addClass('hover');
            var canvasIndex = parseInt($placemarker.attr('data-index'));
            that.component.publish(Events_1.Events.SEARCH_PREVIEW_START, canvasIndex);
            var $placemarkers = that.getSearchResultPlacemarkers();
            var elemIndex = $placemarkers.index($placemarker[0]);
            that.currentPlacemarkerIndex = canvasIndex;
            that.$placemarkerDetails.show();
            var title = "{0} {1}";
            if (that.isPageModeEnabled()) {
                var canvas = that.extension.helper.getCanvasByIndex(canvasIndex);
                var label = Manifesto.LanguageMap.getValue(canvas.getLabel());
                if (!label) {
                    label = this.extension.helper.manifest.options.defaultLabel;
                }
                title = Utils.Strings.format(title, that.content.pageCaps, label);
            }
            else {
                title = Utils.Strings.format(title, that.content.imageCaps, String(canvasIndex + 1));
            }
            that.$placemarkerDetailsTop.html(title);
            var searchResults = that.getSearchResults();
            if (searchResults) {
                var result = searchResults[elemIndex];
                var terms = "";
                if (that.terms) {
                    terms = Utils.Strings.ellipsis(that.terms, that.options.elideDetailsTermsCount);
                }
                var instanceFoundText = that.content.instanceFound;
                var instancesFoundText = that.content.instancesFound;
                var text = '';
                if (result.rects.length === 1) {
                    text = Utils.Strings.format(instanceFoundText, terms);
                    that.$placemarkerDetailsBottom.html(text);
                }
                else {
                    text = Utils.Strings.format(instancesFoundText, String(result.rects.length), terms);
                    that.$placemarkerDetailsBottom.html(text);
                }
            }
            var pos = $placemarker.position();
            var top = pos.top - that.$placemarkerDetails.height();
            var left = pos.left;
            if (left < that.$placemarkerDetails.width() / 2) {
                left = 0 - ($placemarker.width() / 2);
            }
            else if (left > that.$line.width() - (that.$placemarkerDetails.width() / 2)) {
                left = that.$line.width() - that.$placemarkerDetails.width() + ($placemarker.width() / 2);
            }
            else {
                left -= (that.$placemarkerDetails.width() / 2);
            }
            that.$placemarkerDetails.css({
                top: top,
                left: left
            });
        };
        FooterPanel.prototype.onPlacemarkerMouseLeave = function (e, that) {
            that.component.publish(Events_1.Events.SEARCH_PREVIEW_FINISH);
            var $placemarker = $(this);
            var newElement = e.toElement || e.relatedTarget;
            var isChild = $(newElement).closest(that.$placemarkerDetails).length;
            if (newElement != that.$placemarkerDetails.get(0) && isChild === 0) {
                that.$placemarkerDetails.hide();
                $placemarker.removeClass('hover');
            }
        };
        FooterPanel.prototype.setPageMarkerPosition = function () {
            if (this.extension.helper.canvasIndex === null)
                return;
            // position placemarker showing current page.
            var pageLineRatio = this.getPageLineRatio();
            var lineTop = this.$line.position().top;
            var lineLeft = this.$line.position().left;
            var position = this.extension.helper.canvasIndex * pageLineRatio;
            var top = lineTop;
            var left = lineLeft + position;
            this.$pagePositionMarker.css({
                top: top,
                left: left
            });
            // if the remaining distance to the right is less than the width of the label
            // shift it to the left.
            var lineWidth = this.$line.width();
            if (left + this.$pagePositionLabel.outerWidth(true) > lineWidth) {
                left -= this.$pagePositionLabel.outerWidth(true);
                this.$pagePositionLabel.removeClass('right');
                this.$pagePositionLabel.addClass('left');
            }
            else {
                this.$pagePositionLabel.removeClass('left');
                this.$pagePositionLabel.addClass('right');
            }
            this.$pagePositionLabel.css({
                top: top,
                left: left
            });
        };
        FooterPanel.prototype.clearSearchResults = function () {
            if (!this.isSearchEnabled()) {
                return;
            }
            // clear all existing placemarkers
            var $placemarkers = this.getSearchResultPlacemarkers();
            $placemarkers.remove();
            // clear search input field.
            this.$searchText.val(this.content.enterKeyword);
            // hide pager.
            this.$searchContainer.show();
            this.$searchPagerContainer.hide();
            // set focus to search box.
            this.$searchText.focus();
        };
        FooterPanel.prototype.getPageLineRatio = function () {
            var lineWidth = this.$line.width();
            // find page/width ratio by dividing the line width by the number of pages in the book.
            if (this.extension.helper.getTotalCanvases() === 1)
                return 0;
            return lineWidth / (this.extension.helper.getTotalCanvases() - 1);
        };
        FooterPanel.prototype.canvasIndexChanged = function () {
            this.setPageMarkerPosition();
            this.setPlacemarkerLabel();
        };
        FooterPanel.prototype.settingsChanged = function () {
            this.setPlacemarkerLabel();
        };
        FooterPanel.prototype.setPlacemarkerLabel = function () {
            var displaying = this.content.displaying;
            var index = this.extension.helper.canvasIndex;
            if (this.isPageModeEnabled()) {
                var canvas = this.extension.helper.getCanvasByIndex(index);
                var label = Manifesto.LanguageMap.getValue(canvas.getLabel());
                if (!label) {
                    label = this.content.defaultLabel;
                }
                var lastCanvasOrderLabel = this.extension.helper.getLastCanvasLabel(true);
                if (lastCanvasOrderLabel) {
                    this.$pagePositionLabel.html(Utils.Strings.format(displaying, this.content.page, Utils_1.UVUtils.sanitize(label), Utils_1.UVUtils.sanitize(lastCanvasOrderLabel)));
                }
            }
            else {
                this.$pagePositionLabel.html(Utils.Strings.format(displaying, this.content.image, String(index + 1), this.extension.helper.getTotalCanvases().toString()));
            }
        };
        FooterPanel.prototype.isPageModeEnabled = function () {
            return this.config.options.pageModeEnabled && this.extension.getMode().toString() === Mode_1.Mode.page.toString() && !Utils.Bools.getBool(this.config.options.forceImageMode, false);
        };
        FooterPanel.prototype.showSearchSpinner = function () {
            this.$searchText.addClass('searching');
        };
        FooterPanel.prototype.hideSearchSpinner = function () {
            this.$searchText.removeClass('searching');
        };
        FooterPanel.prototype.displaySearchResults = function (results, terms) {
            if (!this.isSearchEnabled()) {
                return;
            }
            this.hideSearchSpinner();
            this.positionSearchResultPlacemarkers();
            // show pager.
            this.$searchContainer.hide();
            this.$searchPagerControls.css({
                'left': 0
            });
            var $info = this.$searchResultsInfo.find('.info');
            var $number = $info.find('.number');
            var $foundFor = $info.find('.foundFor');
            var $terms = $info.find('.terms');
            if (terms) {
                $info.show();
                $number.text(this.extension.getTotalAnnotationRects());
                if (results.length === 1) {
                    $foundFor.html(this.content.resultFoundFor);
                }
                else {
                    $foundFor.html(this.content.resultsFoundFor);
                }
                $terms.html(Utils.Strings.ellipsis(terms, this.options.elideResultsTermsCount));
                $terms.prop('title', terms);
            }
            else {
                $info.hide();
            }
            this.$searchPagerContainer.show();
            this.resize();
        };
        FooterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            var searchResults = this.getSearchResults();
            if (searchResults && searchResults.length) {
                this.positionSearchResultPlacemarkers();
            }
            this.setPageMarkerPosition();
            this.$searchPagerContainer.width(this.$element.width());
            var center = this.$element.width() / 2;
            // position search pager controls.
            this.$searchPagerControls.css({
                'left': center - (this.$searchPagerControls.width() / 2)
            });
            // position search input.
            this.$searchOptions.css({
                'left': center - (this.$searchOptions.outerWidth() / 2)
            });
        };
        return FooterPanel;
    }(FooterPanel_1.FooterPanel));
    exports.FooterPanel = FooterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-dialogues-module/MoreInfoDialogue',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/Dialogue", "../../Utils"], function (require, exports, BaseEvents_1, Dialogue_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MoreInfoDialogue = /** @class */ (function (_super) {
        __extends(MoreInfoDialogue, _super);
        function MoreInfoDialogue($element) {
            return _super.call(this, $element) || this;
        }
        MoreInfoDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('moreInfoDialogue');
            _super.prototype.create.call(this);
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_MOREINFO_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_MOREINFO_DIALOGUE;
            this.component.subscribe(this.openCommand, function (triggerButton) {
                _this.open(triggerButton);
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
            });
            this.config.content = this.extension.data.config.modules.moreInfoRightPanel.content;
            this.config.options = this.extension.data.config.modules.moreInfoRightPanel.options;
            // create ui
            this.$title = $('<h1>' + this.config.content.title + '</h1>');
            this.$content.append(this.$title);
            this.$metadata = $('<div class="iiif-metadata-component"></div>');
            this.$content.append(this.$metadata);
            this.metadataComponent = new IIIFComponents.MetadataComponent({
                target: this.$metadata[0]
            });
            // hide
            this.$element.hide();
        };
        MoreInfoDialogue.prototype.open = function (triggerButton) {
            _super.prototype.open.call(this, triggerButton);
            this.metadataComponent.set(this._getData());
        };
        MoreInfoDialogue.prototype._getData = function () {
            return {
                canvasDisplayOrder: this.config.options.canvasDisplayOrder,
                canvases: this.extension.getCurrentCanvases(),
                canvasExclude: this.config.options.canvasExclude,
                canvasLabels: this.extension.getCanvasLabels(this.content.page),
                content: this.config.content,
                copiedMessageDuration: 2000,
                copyToClipboardEnabled: Utils.Bools.getBool(this.config.options.copyToClipboardEnabled, false),
                helper: this.extension.helper,
                licenseFormatter: null,
                limit: this.config.options.textLimit || 4,
                limitType: IIIFComponents.LimitType.LINES,
                manifestDisplayOrder: this.config.options.manifestDisplayOrder,
                manifestExclude: this.config.options.manifestExclude,
                range: this.extension.getCurrentCanvasRange(),
                rtlLanguageCodes: this.config.options.rtlLanguageCodes,
                sanitizer: function (html) {
                    return Utils_1.UVUtils.sanitize(html);
                },
                showAllLanguages: this.config.options.showAllLanguages
            };
        };
        MoreInfoDialogue.prototype.close = function () {
            _super.prototype.close.call(this);
        };
        MoreInfoDialogue.prototype.resize = function () {
            this.setDockedPosition();
        };
        return MoreInfoDialogue;
    }(Dialogue_1.Dialogue));
    exports.MoreInfoDialogue = MoreInfoDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-multiselectdialogue-module/MultiSelectDialogue',["require", "exports", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-shared-module/Dialogue", "../../extensions/uv-seadragon-extension/Mode"], function (require, exports, BaseEvents_1, Dialogue_1, Mode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSelectDialogue = /** @class */ (function (_super) {
        __extends(MultiSelectDialogue, _super);
        function MultiSelectDialogue($element) {
            return _super.call(this, $element) || this;
        }
        MultiSelectDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('multiSelectDialogue');
            _super.prototype.create.call(this);
            var that = this;
            this.openCommand = BaseEvents_1.BaseEvents.SHOW_MULTISELECT_DIALOGUE;
            this.closeCommand = BaseEvents_1.BaseEvents.HIDE_MULTISELECT_DIALOGUE;
            this.component.subscribe(this.openCommand, function () {
                _this.open();
                var multiSelectState = _this.extension.helper.getMultiSelectState();
                multiSelectState.setEnabled(true);
                _this.galleryComponent.set(_this.data);
            });
            this.component.subscribe(this.closeCommand, function () {
                _this.close();
                var multiSelectState = _this.extension.helper.getMultiSelectState();
                multiSelectState.setEnabled(false);
            });
            this.$title = $('<h1></h1>');
            this.$content.append(this.$title);
            this.$title.text(this.content.title);
            this.$gallery = $('<div class="iiif-gallery-component"></div>');
            this.$content.append(this.$gallery);
            this.data = {
                helper: this.extension.helper,
                chunkedResizingThreshold: this.config.options.galleryThumbChunkedResizingThreshold,
                content: this.config.content,
                debug: false,
                imageFadeInDuration: 300,
                initialZoom: 4,
                minLabelWidth: 20,
                pageModeEnabled: this.isPageModeEnabled(),
                searchResults: [],
                scrollStopDuration: 100,
                sizingEnabled: true,
                thumbHeight: this.config.options.galleryThumbHeight,
                thumbLoadPadding: this.config.options.galleryThumbLoadPadding,
                thumbWidth: this.config.options.galleryThumbWidth,
                viewingDirection: this.extension.helper.getViewingDirection()
            };
            this.galleryComponent = new IIIFComponents.GalleryComponent({
                target: this.$gallery[0]
            });
            var $selectButton = this.$gallery.find('a.select');
            $selectButton.addClass('btn btn-primary');
            this.galleryComponent.on('multiSelectionMade', function (ids) {
                _this.component.publish(BaseEvents_1.BaseEvents.MULTISELECTION_MADE, ids);
                that.close();
            }, false);
            this.$element.hide();
        };
        MultiSelectDialogue.prototype.isPageModeEnabled = function () {
            return Utils.Bools.getBool(this.config.options.pageModeEnabled, true) && this.extension.getMode().toString() === Mode_1.Mode.page.toString();
        };
        MultiSelectDialogue.prototype.open = function () {
            _super.prototype.open.call(this);
        };
        MultiSelectDialogue.prototype.close = function () {
            _super.prototype.close.call(this);
        };
        MultiSelectDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
            var $main = this.$gallery.find('.main');
            var $header = this.$gallery.find('.header');
            $main.height(this.$content.height() - this.$title.outerHeight() - this.$title.verticalMargins() - $header.height());
        };
        return MultiSelectDialogue;
    }(Dialogue_1.Dialogue));
    exports.MultiSelectDialogue = MultiSelectDialogue;
});

define('extensions/uv-seadragon-extension/MultiSelectionArgs',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSelectionArgs = /** @class */ (function () {
        function MultiSelectionArgs() {
        }
        return MultiSelectionArgs;
    }());
    exports.MultiSelectionArgs = MultiSelectionArgs;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-pagingheaderpanel-module/PagingHeaderPanel',["require", "exports", "../uv-shared-module/AutoComplete", "../uv-shared-module/BaseEvents", "../../extensions/uv-seadragon-extension/Events", "../uv-shared-module/HeaderPanel", "../../extensions/uv-seadragon-extension/Mode", "../../Utils"], function (require, exports, AutoComplete_1, BaseEvents_1, Events_1, HeaderPanel_1, Mode_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PagingHeaderPanel = /** @class */ (function (_super) {
        __extends(PagingHeaderPanel, _super);
        function PagingHeaderPanel($element) {
            var _this = _super.call(this, $element) || this;
            _this.firstButtonEnabled = false;
            _this.lastButtonEnabled = false;
            _this.nextButtonEnabled = false;
            _this.prevButtonEnabled = false;
            return _this;
        }
        PagingHeaderPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('pagingHeaderPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.canvasIndexChanged(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, function () {
                _this.modeChanged();
                _this.updatePagingToggle();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED, function () {
                _this.setSearchFieldValue(_this.extension.helper.canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START, function () {
                _this.openGallery();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_START, function () {
                _this.closeGallery();
            });
            this.$prevOptions = $('<div class="prevOptions"></div>');
            this.$centerOptions.append(this.$prevOptions);
            this.$firstButton = $("\n          <button class=\"btn imageBtn first\" tabindex=\"0\" title=\"" + this.content.first + "\">\n            <i class=\"uv-icon-first\" aria-hidden=\"true\"></i><span>" + this.content.first + "</span>\n          </button>\n        ");
            this.$prevOptions.append(this.$firstButton);
            this.$prevButton = $("\n          <button class=\"btn imageBtn prev\" tabindex=\"0\" title=\"" + this.content.previous + "\">\n            <i class=\"uv-icon-prev\" aria-hidden=\"true\"></i><span>" + this.content.previous + "</span>\n          </button>\n        ");
            this.$prevOptions.append(this.$prevButton);
            this.$modeOptions = $('<div class="mode"></div>');
            this.$centerOptions.append(this.$modeOptions);
            this.$imageModeLabel = $('<label for="image">' + this.content.image + '</label>');
            this.$modeOptions.append(this.$imageModeLabel);
            this.$imageModeOption = $('<input type="radio" id="image" name="mode" tabindex="0"/>');
            this.$modeOptions.append(this.$imageModeOption);
            this.$pageModeLabel = $('<label for="page"></label>');
            this.$modeOptions.append(this.$pageModeLabel);
            this.$pageModeOption = $('<input type="radio" id="page" name="mode" tabindex="0"/>');
            this.$modeOptions.append(this.$pageModeOption);
            this.$search = $('<div class="search"></div>');
            this.$centerOptions.append(this.$search);
            this.$searchText = $('<input class="searchText" maxlength="50" type="text" tabindex="0" aria-label="' + this.content.pageSearchLabel + '"/>');
            this.$search.append(this.$searchText);
            if (Utils.Bools.getBool(this.options.autoCompleteBoxEnabled, true)) {
                this.$searchText.hide();
                this.$autoCompleteBox = $('<input class="autocompleteText" type="text" maxlength="100" aria-label="' + this.content.pageSearchLabel + '"/>');
                this.$search.append(this.$autoCompleteBox);
                new AutoComplete_1.AutoComplete(this.$autoCompleteBox, function (term, cb) {
                    var results = [];
                    var canvases = _this.extension.helper.getCanvases();
                    // if in page mode, get canvases by label.
                    if (_this.isPageModeEnabled()) {
                        for (var i = 0; i < canvases.length; i++) {
                            var canvas = canvases[i];
                            var label = Manifesto.LanguageMap.getValue(canvas.getLabel());
                            if (label && label.startsWith(term)) {
                                results.push(label);
                            }
                        }
                    }
                    else {
                        // get canvas by index
                        for (var i = 0; i < canvases.length; i++) {
                            var canvas = canvases[i];
                            if (canvas.index.toString().startsWith(term)) {
                                results.push(canvas.index.toString());
                            }
                        }
                    }
                    cb(results);
                }, function (results) {
                    return results;
                }, function (terms) {
                    _this.search(terms);
                }, 300, 0, Utils.Bools.getBool(this.options.autocompleteAllowWords, false));
            }
            else if (Utils.Bools.getBool(this.options.imageSelectionBoxEnabled, true)) {
                this.$selectionBoxOptions = $('<div class="image-selectionbox-options"></div>');
                this.$centerOptions.append(this.$selectionBoxOptions);
                this.$imageSelectionBox = $('<select class="image-selectionbox" name="image-select" tabindex="0" ></select>');
                this.$selectionBoxOptions.append(this.$imageSelectionBox);
                for (var imageIndex = 0; imageIndex < this.extension.helper.getTotalCanvases(); imageIndex++) {
                    var canvas = this.extension.helper.getCanvasByIndex(imageIndex);
                    var label = Utils_1.UVUtils.sanitize(Manifesto.LanguageMap.getValue(canvas.getLabel(), this.extension.helper.options.locale));
                    this.$imageSelectionBox.append('<option value=' + (imageIndex) + '>' + label + '</option>');
                }
                this.$imageSelectionBox.change(function () {
                    var imageIndex = parseInt(_this.$imageSelectionBox.val());
                    _this.component.publish(Events_1.Events.IMAGE_SEARCH, imageIndex);
                });
            }
            this.$total = $('<span class="total"></span>');
            this.$search.append(this.$total);
            this.$searchButton = $("<a class=\"go btn btn-primary\" title=\"" + this.content.go + "\" tabindex=\"0\">" + this.content.go + "</a>");
            this.$search.append(this.$searchButton);
            this.$nextOptions = $('<div class="nextOptions"></div>');
            this.$centerOptions.append(this.$nextOptions);
            this.$nextButton = $("\n          <button class=\"btn imageBtn next\" tabindex=\"0\" title=\"" + this.content.next + "\">\n            <i class=\"uv-icon-next\" aria-hidden=\"true\"></i><span>" + this.content.next + "</span>\n          </button>\n        ");
            this.$nextOptions.append(this.$nextButton);
            this.$lastButton = $("\n          <button class=\"btn imageBtn last\" tabindex=\"0\" title=\"" + this.content.last + "\">\n            <i class=\"uv-icon-last\" aria-hidden=\"true\"></i><span>" + this.content.last + "</span>\n          </button>\n        ");
            this.$nextOptions.append(this.$lastButton);
            if (this.isPageModeEnabled()) {
                this.$pageModeOption.attr('checked', 'checked');
                this.$pageModeOption.removeAttr('disabled');
                this.$pageModeLabel.removeClass('disabled');
            }
            else {
                this.$imageModeOption.attr('checked', 'checked');
                // disable page mode option.
                this.$pageModeOption.attr('disabled', 'disabled');
                this.$pageModeLabel.addClass('disabled');
            }
            if (this.extension.helper.getManifestType().toString() === manifesto.ManifestType.manuscript().toString()) {
                this.$pageModeLabel.text(this.content.folio);
            }
            else {
                this.$pageModeLabel.text(this.content.page);
            }
            this.$galleryButton = $("\n          <button class=\"btn imageBtn gallery\" title=\"" + this.content.gallery + "\" tabindex=\"0\">\n            <i class=\"uv-icon-gallery\" aria-hidden=\"true\"></i>" + this.content.gallery + "\n          </button>\n        ");
            this.$rightOptions.prepend(this.$galleryButton);
            this.$pagingToggleButtons = $('<div class="pagingToggleButtons"></div>');
            this.$rightOptions.prepend(this.$pagingToggleButtons);
            this.$oneUpButton = $("\n          <button class=\"btn imageBtn one-up\" title=\"" + this.content.oneUp + "\" tabindex=\"0\">\n            <i class=\"uv-icon-one-up\" aria-hidden=\"true\"></i>" + this.content.oneUp + "\n          </button>");
            this.$pagingToggleButtons.append(this.$oneUpButton);
            this.$twoUpButton = $("\n          <button class=\"btn imageBtn two-up\" title=\"" + this.content.twoUp + "\" tabindex=\"0\">\n            <i class=\"uv-icon-two-up\" aria-hidden=\"true\"></i>" + this.content.twoUp + "\n          </button>\n        ");
            this.$pagingToggleButtons.append(this.$twoUpButton);
            this.updatePagingToggle();
            this.updateGalleryButton();
            this.$oneUpButton.onPressed(function () {
                var enabled = false;
                _this.updateSettings({ pagingEnabled: enabled });
                _this.component.publish(Events_1.Events.PAGING_TOGGLED, enabled);
            });
            this.$twoUpButton.onPressed(function () {
                var enabled = true;
                _this.updateSettings({ pagingEnabled: enabled });
                _this.component.publish(Events_1.Events.PAGING_TOGGLED, enabled);
            });
            this.$galleryButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.TOGGLE_EXPAND_LEFT_PANEL);
            });
            this.setNavigationTitles();
            this.setTotal();
            var viewingDirection = this.extension.helper.getViewingDirection() || manifesto.ViewingDirection.leftToRight();
            // check if the book has more than one page, otherwise hide prev/next options.
            if (this.extension.helper.getTotalCanvases() === 1) {
                this.$centerOptions.hide();
            }
            // ui event handlers.
            this.$firstButton.onPressed(function () {
                switch (viewingDirection.toString()) {
                    case manifesto.ViewingDirection.leftToRight().toString():
                    case manifesto.ViewingDirection.topToBottom().toString():
                    case manifesto.ViewingDirection.bottomToTop().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.FIRST);
                        break;
                    case manifesto.ViewingDirection.rightToLeft().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.LAST);
                        break;
                }
            });
            this.$prevButton.onPressed(function () {
                switch (viewingDirection.toString()) {
                    case manifesto.ViewingDirection.leftToRight().toString():
                    case manifesto.ViewingDirection.bottomToTop().toString():
                    case manifesto.ViewingDirection.topToBottom().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.PREV);
                        break;
                    case manifesto.ViewingDirection.rightToLeft().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.NEXT);
                        break;
                }
            });
            this.$nextButton.onPressed(function () {
                switch (viewingDirection.toString()) {
                    case manifesto.ViewingDirection.leftToRight().toString():
                    case manifesto.ViewingDirection.bottomToTop().toString():
                    case manifesto.ViewingDirection.topToBottom().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.NEXT);
                        break;
                    case manifesto.ViewingDirection.rightToLeft().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.PREV);
                        break;
                }
            });
            this.$lastButton.onPressed(function () {
                switch (viewingDirection.toString()) {
                    case manifesto.ViewingDirection.leftToRight().toString():
                    case manifesto.ViewingDirection.topToBottom().toString():
                    case manifesto.ViewingDirection.bottomToTop().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.LAST);
                        break;
                    case manifesto.ViewingDirection.rightToLeft().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.FIRST);
                        break;
                }
            });
            // If page mode is disabled, we don't need to show radio buttons since
            // there is only one option:
            if (!this.config.options.pageModeEnabled) {
                this.$imageModeOption.hide();
                this.$pageModeLabel.hide();
                this.$pageModeOption.hide();
            }
            else {
                // Only activate click actions for mode buttons when controls are
                // visible, since otherwise, clicking on the "Image" label can
                // trigger unexpected/undesired side effects.
                this.$imageModeOption.on('click', function (e) {
                    _this.component.publish(Events_1.Events.MODE_CHANGED, Mode_1.Mode.image.toString());
                });
                this.$pageModeOption.on('click', function (e) {
                    _this.component.publish(Events_1.Events.MODE_CHANGED, Mode_1.Mode.page.toString());
                });
            }
            this.$searchText.onEnter(function () {
                _this.$searchText.blur();
                _this.search(_this.$searchText.val());
            });
            this.$searchText.click(function () {
                $(this).select();
            });
            this.$searchButton.onPressed(function () {
                if (_this.options.autoCompleteBoxEnabled) {
                    _this.search(_this.$autoCompleteBox.val());
                }
                else {
                    _this.search(_this.$searchText.val());
                }
            });
            if (this.options.modeOptionsEnabled === false) {
                this.$modeOptions.hide();
                this.$centerOptions.addClass('modeOptionsDisabled');
            }
            // Search is shown as default
            if (this.options.imageSelectionBoxEnabled === true && this.options.autoCompleteBoxEnabled !== true) {
                this.$search.hide();
            }
            if (this.options.helpEnabled === false) {
                this.$helpButton.hide();
            }
            // todo: discuss on community call
            // Get visible element in centerOptions with greatest tabIndex
            // var $elementWithGreatestTabIndex: JQuery = this.$centerOptions.getVisibleElementWithGreatestTabIndex();
            // // cycle focus back to start.
            // if ($elementWithGreatestTabIndex) {
            //     $elementWithGreatestTabIndex.blur(() => {
            //         if (this.extension.tabbing && !this.extension.shifted) {
            //             this.$nextButton.focus();
            //         }
            //     });
            // }
            // this.$nextButton.blur(() => {
            //     if (this.extension.tabbing && this.extension.shifted) {
            //         setTimeout(() => {
            //             $elementWithGreatestTabIndex.focus();
            //         }, 100);
            //     }
            // });
            if (!Utils.Bools.getBool(this.options.pagingToggleEnabled, true)) {
                this.$pagingToggleButtons.hide();
            }
        };
        PagingHeaderPanel.prototype.openGallery = function () {
            this.$oneUpButton.removeClass('on');
            this.$twoUpButton.removeClass('on');
            this.$galleryButton.addClass('on');
        };
        PagingHeaderPanel.prototype.closeGallery = function () {
            this.updatePagingToggle();
            this.$galleryButton.removeClass('on');
        };
        PagingHeaderPanel.prototype.isPageModeEnabled = function () {
            return this.config.options.pageModeEnabled && this.extension.getMode().toString() === Mode_1.Mode.page.toString();
        };
        PagingHeaderPanel.prototype.setNavigationTitles = function () {
            if (this.isPageModeEnabled()) {
                if (this.extension.helper.isRightToLeft()) {
                    this.$firstButton.prop('title', this.content.lastPage);
                    this.$firstButton.find('span').text(this.content.lastPage);
                    this.$prevButton.prop('title', this.content.nextPage);
                    this.$prevButton.find('span').text(this.content.nextPage);
                    this.$nextButton.prop('title', this.content.previousPage);
                    this.$nextButton.find('span').text(this.content.previousPage);
                    this.$lastButton.prop('title', this.content.firstPage);
                    this.$lastButton.find('span').text(this.content.firstPage);
                }
                else {
                    this.$firstButton.prop('title', this.content.firstPage);
                    this.$firstButton.find('span').text(this.content.firstPage);
                    this.$prevButton.prop('title', this.content.previousPage);
                    this.$prevButton.find('span').text(this.content.previousPage);
                    this.$nextButton.prop('title', this.content.nextPage);
                    this.$nextButton.find('span').text(this.content.nextPage);
                    this.$lastButton.prop('title', this.content.lastPage);
                    this.$lastButton.find('span').text(this.content.lastPage);
                }
            }
            else {
                if (this.extension.helper.isRightToLeft()) {
                    this.$firstButton.prop('title', this.content.lastImage);
                    this.$firstButton.find('span').text(this.content.lastPage);
                    this.$prevButton.prop('title', this.content.nextImage);
                    this.$prevButton.find('span').text(this.content.nextImage);
                    this.$nextButton.prop('title', this.content.previousImage);
                    this.$nextButton.find('span').text(this.content.previousImage);
                    this.$lastButton.prop('title', this.content.firstImage);
                    this.$lastButton.find('span').text(this.content.firstImage);
                }
                else {
                    this.$firstButton.prop('title', this.content.firstImage);
                    this.$firstButton.find('span').text(this.content.firstImage);
                    this.$prevButton.prop('title', this.content.previousImage);
                    this.$prevButton.find('span').text(this.content.previousImage);
                    this.$nextButton.prop('title', this.content.nextImage);
                    this.$nextButton.find('span').text(this.content.nextImage);
                    this.$lastButton.prop('title', this.content.lastImage);
                    this.$lastButton.find('span').text(this.content.lastImage);
                }
            }
        };
        PagingHeaderPanel.prototype.updatePagingToggle = function () {
            if (!this.pagingToggleIsVisible()) {
                this.$pagingToggleButtons.hide();
                return;
            }
            if (this.extension.isPagingSettingEnabled()) {
                this.$oneUpButton.removeClass('on');
                this.$twoUpButton.addClass('on');
            }
            else {
                this.$twoUpButton.removeClass('on');
                this.$oneUpButton.addClass('on');
            }
        };
        PagingHeaderPanel.prototype.pagingToggleIsVisible = function () {
            return Utils.Bools.getBool(this.options.pagingToggleEnabled, true) && this.extension.helper.isPagingAvailable();
        };
        PagingHeaderPanel.prototype.updateGalleryButton = function () {
            if (!this.galleryIsVisible()) {
                this.$galleryButton.hide();
            }
        };
        PagingHeaderPanel.prototype.galleryIsVisible = function () {
            return Utils.Bools.getBool(this.options.galleryButtonEnabled, true) && this.extension.isLeftPanelEnabled();
        };
        PagingHeaderPanel.prototype.setTotal = function () {
            var of = this.content.of;
            if (this.isPageModeEnabled()) {
                this.$total.html(Utils.Strings.format(of, this.extension.helper.getLastCanvasLabel(true)));
            }
            else {
                this.$total.html(Utils.Strings.format(of, this.extension.helper.getTotalCanvases().toString()));
            }
        };
        PagingHeaderPanel.prototype.setSearchFieldValue = function (index) {
            var canvas = this.extension.helper.getCanvasByIndex(index);
            var value = null;
            if (this.isPageModeEnabled()) {
                var orderLabel = Manifesto.LanguageMap.getValue(canvas.getLabel());
                if (orderLabel === "-") {
                    value = "";
                }
                else {
                    value = orderLabel;
                }
            }
            else {
                index += 1;
                value = index.toString();
            }
            if (this.options.autoCompleteBoxEnabled) {
                this.$autoCompleteBox.val(value);
            }
            else {
                this.$searchText.val(value);
            }
        };
        PagingHeaderPanel.prototype.search = function (value) {
            if (!value) {
                this.extension.showMessage(this.content.emptyValue);
                this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED);
                return;
            }
            if (this.isPageModeEnabled()) {
                this.component.publish(Events_1.Events.PAGE_SEARCH, value);
            }
            else {
                var index = void 0;
                if (this.options.autoCompleteBoxEnabled) {
                    index = parseInt(this.$autoCompleteBox.val(), 10);
                }
                else {
                    index = parseInt(this.$searchText.val(), 10);
                }
                index -= 1;
                if (isNaN(index)) {
                    this.extension.showMessage(this.extension.data.config.modules.genericDialogue.content.invalidNumber);
                    this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED);
                    return;
                }
                var asset = this.extension.helper.getCanvasByIndex(index);
                if (!asset) {
                    this.extension.showMessage(this.extension.data.config.modules.genericDialogue.content.pageNotFound);
                    this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED);
                    return;
                }
                this.component.publish(Events_1.Events.IMAGE_SEARCH, index);
            }
        };
        PagingHeaderPanel.prototype.canvasIndexChanged = function (index) {
            this.setSearchFieldValue(index);
            if (this.options.imageSelectionBoxEnabled === true && this.options.autoCompleteBoxEnabled !== true) {
                this.$imageSelectionBox.val(index);
            }
            var viewingDirection = this.extension.helper.getViewingDirection() || manifesto.ViewingDirection.leftToRight();
            if (viewingDirection.toString() === manifesto.ViewingDirection.rightToLeft().toString()) {
                if (this.extension.helper.isFirstCanvas()) {
                    this.disableLastButton();
                    this.disableNextButton();
                }
                else {
                    this.enableLastButton();
                    this.enableNextButton();
                }
                if (this.extension.helper.isLastCanvas()) {
                    this.disableFirstButton();
                    this.disablePrevButton();
                }
                else {
                    this.enableFirstButton();
                    this.enablePrevButton();
                }
            }
            else {
                if (this.extension.helper.isFirstCanvas()) {
                    this.disableFirstButton();
                    this.disablePrevButton();
                }
                else {
                    this.enableFirstButton();
                    this.enablePrevButton();
                }
                if (this.extension.helper.isLastCanvas()) {
                    this.disableLastButton();
                    this.disableNextButton();
                }
                else {
                    this.enableLastButton();
                    this.enableNextButton();
                }
            }
        };
        PagingHeaderPanel.prototype.disableFirstButton = function () {
            this.firstButtonEnabled = false;
            this.$firstButton.disable();
        };
        PagingHeaderPanel.prototype.enableFirstButton = function () {
            this.firstButtonEnabled = true;
            this.$firstButton.enable();
        };
        PagingHeaderPanel.prototype.disableLastButton = function () {
            this.lastButtonEnabled = false;
            this.$lastButton.disable();
        };
        PagingHeaderPanel.prototype.enableLastButton = function () {
            this.lastButtonEnabled = true;
            this.$lastButton.enable();
        };
        PagingHeaderPanel.prototype.disablePrevButton = function () {
            this.prevButtonEnabled = false;
            this.$prevButton.disable();
        };
        PagingHeaderPanel.prototype.enablePrevButton = function () {
            this.prevButtonEnabled = true;
            this.$prevButton.enable();
        };
        PagingHeaderPanel.prototype.disableNextButton = function () {
            this.nextButtonEnabled = false;
            this.$nextButton.disable();
        };
        PagingHeaderPanel.prototype.enableNextButton = function () {
            this.nextButtonEnabled = true;
            this.$nextButton.enable();
        };
        PagingHeaderPanel.prototype.modeChanged = function () {
            this.setSearchFieldValue(this.extension.helper.canvasIndex);
            this.setNavigationTitles();
            this.setTotal();
        };
        PagingHeaderPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            // hide toggle buttons below minimum width
            if (this.extension.width() < this.extension.data.config.options.minWidthBreakPoint) {
                if (this.pagingToggleIsVisible())
                    this.$pagingToggleButtons.hide();
                if (this.galleryIsVisible())
                    this.$galleryButton.hide();
            }
            else {
                if (this.pagingToggleIsVisible())
                    this.$pagingToggleButtons.show();
                if (this.galleryIsVisible())
                    this.$galleryButton.show();
            }
        };
        return PagingHeaderPanel;
    }(HeaderPanel_1.HeaderPanel));
    exports.PagingHeaderPanel = PagingHeaderPanel;
});

define('extensions/uv-seadragon-extension/Bounds',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Bounds = /** @class */ (function () {
        function Bounds(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        Bounds.prototype.toString = function () {
            return this.x + "," + this.y + "," + this.w + "," + this.h;
        };
        Bounds.fromString = function (bounds) {
            var boundsArr = bounds.split(',');
            return new Bounds(Number(boundsArr[0]), Number(boundsArr[1]), Number(boundsArr[2]), Number(boundsArr[3]));
        };
        return Bounds;
    }());
    exports.Bounds = Bounds;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-seadragoncenterpanel-module/SeadragonCenterPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../../extensions/uv-seadragon-extension/Bounds", "../uv-shared-module/CenterPanel", "../../extensions/uv-seadragon-extension/Events", "../../Utils"], function (require, exports, BaseEvents_1, Bounds_1, CenterPanel_1, Events_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SeadragonCenterPanel = /** @class */ (function (_super) {
        __extends(SeadragonCenterPanel, _super);
        function SeadragonCenterPanel($element) {
            var _this = _super.call(this, $element) || this;
            _this.controlsVisible = false;
            _this.isCreated = false;
            _this.isFirstLoad = true;
            _this.navigatedFromSearch = false;
            _this.nextButtonEnabled = false;
            _this.prevButtonEnabled = false;
            return _this;
        }
        SeadragonCenterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('seadragonCenterPanel');
            _super.prototype.create.call(this);
            this.viewerId = "osd" + new Date().getTime();
            this.$viewer = $('<div id="' + this.viewerId + '" class="viewer"></div>');
            this.$content.prepend(this.$viewer);
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS, function (args) {
                _this.overlayAnnotations();
                _this.zoomToInitialAnnotation();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, function (args) {
                _this.viewer.gestureSettingsMouse.clickToZoom = args.clickToZoomEnabled;
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, function (resources) {
                _this.whenResized(function () {
                    if (!_this.isCreated)
                        _this.createUI();
                    _this.openMedia(resources);
                });
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLEAR_ANNOTATIONS, function () {
                _this.whenCreated(function () {
                    _this.extension.currentAnnotationRect = null;
                    _this.clearAnnotations();
                });
            });
            this.component.subscribe(Events_1.Events.NEXT_SEARCH_RESULT, function () {
                _this.whenCreated(function () {
                    _this.nextAnnotation();
                });
            });
            this.component.subscribe(Events_1.Events.PREV_SEARCH_RESULT, function () {
                _this.whenCreated(function () {
                    _this.prevAnnotation();
                });
            });
            this.component.subscribe(Events_1.Events.ZOOM_IN, function () {
                _this.whenCreated(function () {
                    _this.zoomIn();
                });
            });
            this.component.subscribe(Events_1.Events.ZOOM_OUT, function () {
                _this.whenCreated(function () {
                    _this.zoomOut();
                });
            });
            this.component.subscribe(Events_1.Events.ROTATE, function () {
                _this.whenCreated(function () {
                    _this.rotateRight();
                });
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.METRIC_CHANGED, function () {
                _this.whenCreated(function () {
                    _this.updateResponsiveView();
                });
            });
        };
        SeadragonCenterPanel.prototype.whenCreated = function (cb) {
            var _this = this;
            Utils.Async.waitFor(function () {
                return _this.isCreated;
            }, cb);
        };
        SeadragonCenterPanel.prototype.zoomIn = function () {
            this.viewer.viewport.zoomTo(this.viewer.viewport.getZoom(true) * 2);
        };
        SeadragonCenterPanel.prototype.zoomOut = function () {
            this.viewer.viewport.zoomTo(this.viewer.viewport.getZoom(true) * 0.5);
        };
        SeadragonCenterPanel.prototype.rotateRight = function () {
            this.viewer.viewport.setRotation(this.viewer.viewport.getRotation() + 90);
        };
        SeadragonCenterPanel.prototype.updateResponsiveView = function () {
            this.setNavigatorVisible();
            if (!this.extension.isDesktopMetric()) {
                this.viewer.autoHideControls = false;
                this.$viewportNavButtons.hide();
            }
            else {
                this.viewer.autoHideControls = true;
                this.$viewportNavButtons.show();
            }
        };
        SeadragonCenterPanel.prototype.createUI = function () {
            var _this = this;
            this.$spinner = $('<div class="spinner"></div>');
            this.$content.append(this.$spinner);
            // add to window object for testing automation purposes.
            //window.openSeadragonViewer
            // removed as causing issues for multiple UVs on page
            this.viewer = OpenSeadragon({
                id: this.viewerId,
                ajaxWithCredentials: false,
                showNavigationControl: true,
                showNavigator: true,
                showRotationControl: true,
                showHomeControl: Utils.Bools.getBool(this.config.options.showHomeControl, false),
                showFullPageControl: false,
                defaultZoomLevel: this.config.options.defaultZoomLevel || 0,
                maxZoomPixelRatio: this.config.options.maxZoomPixelRatio || 2,
                controlsFadeDelay: this.config.options.controlsFadeDelay || 250,
                controlsFadeLength: this.config.options.controlsFadeLength || 250,
                navigatorPosition: this.config.options.navigatorPosition || "BOTTOM_RIGHT",
                animationTime: this.config.options.animationTime || 1.2,
                visibilityRatio: this.config.options.visibilityRatio || 0.5,
                constrainDuringPan: Utils.Bools.getBool(this.config.options.constrainDuringPan, false),
                immediateRender: Utils.Bools.getBool(this.config.options.immediateRender, false),
                blendTime: this.config.options.blendTime || 0,
                autoHideControls: Utils.Bools.getBool(this.config.options.autoHideControls, true),
                prefixUrl: this.extension.data.root + '/img/',
                gestureSettingsMouse: {
                    clickToZoom: Utils.Bools.getBool(this.extension.data.config.options.clickToZoomEnabled, true)
                },
                navImages: {
                    zoomIn: {
                        REST: 'pixel.gif',
                        GROUP: 'pixel.gif',
                        HOVER: 'pixel.gif',
                        DOWN: 'pixel.gif'
                    },
                    zoomOut: {
                        REST: 'pixel.gif',
                        GROUP: 'pixel.gif',
                        HOVER: 'pixel.gif',
                        DOWN: 'pixel.gif'
                    },
                    home: {
                        REST: 'pixel.gif',
                        GROUP: 'pixel.gif',
                        HOVER: 'pixel.gif',
                        DOWN: 'pixel.gif'
                    },
                    rotateright: {
                        REST: 'pixel.gif',
                        GROUP: 'pixel.gif',
                        HOVER: 'pixel.gif',
                        DOWN: 'pixel.gif'
                    },
                    rotateleft: {
                        REST: 'pixel.gif',
                        GROUP: 'pixel.gif',
                        HOVER: 'pixel.gif',
                        DOWN: 'pixel.gif'
                    },
                    next: {
                        REST: 'pixel.gif',
                        GROUP: 'pixel.gif',
                        HOVER: 'pixel.gif',
                        DOWN: 'pixel.gif'
                    },
                    previous: {
                        REST: 'pixel.gif',
                        GROUP: 'pixel.gif',
                        HOVER: 'pixel.gif',
                        DOWN: 'pixel.gif'
                    }
                }
            });
            this.$zoomInButton = this.$viewer.find('div[title="Zoom in"]');
            this.$zoomInButton.attr('tabindex', 0);
            this.$zoomInButton.prop('title', this.content.zoomIn);
            this.$zoomInButton.addClass('zoomIn viewportNavButton');
            this.$zoomOutButton = this.$viewer.find('div[title="Zoom out"]');
            this.$zoomOutButton.attr('tabindex', 0);
            this.$zoomOutButton.prop('title', this.content.zoomOut);
            this.$zoomOutButton.addClass('zoomOut viewportNavButton');
            this.$goHomeButton = this.$viewer.find('div[title="Go home"]');
            this.$goHomeButton.attr('tabindex', 0);
            this.$goHomeButton.prop('title', this.content.goHome);
            this.$goHomeButton.addClass('goHome viewportNavButton');
            this.$rotateButton = this.$viewer.find('div[title="Rotate right"]');
            this.$rotateButton.attr('tabindex', 0);
            this.$rotateButton.prop('title', this.content.rotateRight);
            this.$rotateButton.addClass('rotate viewportNavButton');
            this.$viewportNavButtonsContainer = this.$viewer.find('.openseadragon-container > div:not(.openseadragon-canvas):first');
            this.$viewportNavButtons = this.$viewportNavButtonsContainer.find('.viewportNavButton');
            this.$canvas = $(this.viewer.canvas);
            // disable right click on canvas
            this.$canvas.on('contextmenu', function () { return false; });
            this.$navigator = this.$viewer.find(".navigator");
            this.setNavigatorVisible();
            // events
            this.$element.on('mousemove', function () {
                if (_this.controlsVisible)
                    return;
                _this.controlsVisible = true;
                _this.viewer.setControlsEnabled(true);
            });
            this.$element.on('mouseleave', function () {
                if (!_this.controlsVisible)
                    return;
                _this.controlsVisible = false;
                _this.viewer.setControlsEnabled(false);
            });
            // when mouse move stopped
            this.$element.on('mousemove', function () {
                // if over element, hide controls.
                // When over prev/next buttons keep controls enabled
                if (_this.$prevButton.ismouseover()) {
                    return;
                }
                if (_this.$nextButton.ismouseover()) {
                    return;
                }
                if (!_this.$viewer.find('.navigator').ismouseover()) {
                    if (!_this.controlsVisible)
                        return;
                    _this.controlsVisible = false;
                    _this.viewer.setControlsEnabled(false);
                }
            }, this.config.options.controlsFadeAfterInactive);
            this.viewer.addHandler('tile-drawn', function () {
                _this.$spinner.hide();
            });
            //this.viewer.addHandler("open-failed", () => {
            //});
            this.viewer.addHandler('resize', function (viewer) {
                _this.component.publish(Events_1.Events.SEADRAGON_RESIZE, viewer);
                _this.viewerResize(viewer);
            });
            this.viewer.addHandler('animation-start', function (viewer) {
                _this.component.publish(Events_1.Events.SEADRAGON_ANIMATION_START, viewer);
            });
            this.viewer.addHandler('animation', function (viewer) {
                _this.component.publish(Events_1.Events.SEADRAGON_ANIMATION, viewer);
            });
            this.viewer.addHandler('animation-finish', function (viewer) {
                _this.currentBounds = _this.getViewportBounds();
                _this.updateVisibleAnnotationRects();
                _this.component.publish(Events_1.Events.SEADRAGON_ANIMATION_FINISH, viewer);
            });
            this.viewer.addHandler('rotate', function (args) {
                _this.component.publish(Events_1.Events.SEADRAGON_ROTATION, args.degrees);
            });
            this.title = this.extension.helper.getLabel();
            this.createNavigationButtons();
            this.hidePrevButton();
            this.hideNextButton();
            this.isCreated = true;
            this.resize();
        };
        SeadragonCenterPanel.prototype.createNavigationButtons = function () {
            var _this = this;
            var viewingDirection = this.extension.helper.getViewingDirection() || manifesto.ViewingDirection.leftToRight();
            this.$prevButton = $('<div class="paging btn prev" tabindex="0"></div>');
            if (this.extension.helper.isRightToLeft()) {
                this.$prevButton.prop('title', this.content.next);
            }
            else {
                this.$prevButton.prop('title', this.content.previous);
            }
            this.$nextButton = $('<div class="paging btn next" tabindex="0"></div>');
            if (this.extension.helper.isRightToLeft()) {
                this.$nextButton.prop('title', this.content.previous);
            }
            else {
                this.$nextButton.prop('title', this.content.next);
            }
            this.viewer.addControl(this.$prevButton[0], { anchor: OpenSeadragon.ControlAnchor.TOP_LEFT });
            this.viewer.addControl(this.$nextButton[0], { anchor: OpenSeadragon.ControlAnchor.TOP_RIGHT });
            switch (viewingDirection.toString()) {
                case manifesto.ViewingDirection.bottomToTop().toString():
                case manifesto.ViewingDirection.topToBottom().toString():
                    this.$prevButton.addClass('vertical');
                    this.$nextButton.addClass('vertical');
                    ;
                    break;
            }
            var that = this;
            this.$prevButton.onPressed(function (e) {
                e.preventDefault();
                OpenSeadragon.cancelEvent(e);
                if (!that.prevButtonEnabled)
                    return;
                switch (viewingDirection.toString()) {
                    case manifesto.ViewingDirection.leftToRight().toString():
                    case manifesto.ViewingDirection.bottomToTop().toString():
                    case manifesto.ViewingDirection.topToBottom().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.PREV);
                        break;
                    case manifesto.ViewingDirection.rightToLeft().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.NEXT);
                        break;
                }
            });
            this.$nextButton.onPressed(function (e) {
                e.preventDefault();
                OpenSeadragon.cancelEvent(e);
                if (!that.nextButtonEnabled)
                    return;
                switch (viewingDirection.toString()) {
                    case manifesto.ViewingDirection.leftToRight().toString():
                    case manifesto.ViewingDirection.bottomToTop().toString():
                    case manifesto.ViewingDirection.topToBottom().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.NEXT);
                        break;
                    case manifesto.ViewingDirection.rightToLeft().toString():
                        _this.component.publish(BaseEvents_1.BaseEvents.PREV);
                        break;
                }
            });
            // When Prev/Next buttons are focused, make sure the controls are enabled
            this.$prevButton.on('focus', function () {
                if (_this.controlsVisible)
                    return;
                _this.controlsVisible = true;
                _this.viewer.setControlsEnabled(true);
            });
            this.$nextButton.on('focus', function () {
                if (_this.controlsVisible)
                    return;
                _this.controlsVisible = true;
                _this.viewer.setControlsEnabled(true);
            });
        };
        SeadragonCenterPanel.prototype.openMedia = function (resources) {
            var _this = this;
            this.$spinner.show();
            this.items = [];
            this.extension.getExternalResources(resources).then(function (resources) {
                _this.viewer.close();
                resources = _this.getPagePositions(resources);
                for (var i = 0; i < resources.length; i++) {
                    var data = resources[i];
                    var tileSource = void 0;
                    if (data.hasServiceDescriptor) {
                        tileSource = data;
                    }
                    else {
                        tileSource = {
                            type: 'image',
                            url: data.id,
                            buildPyramid: false
                        };
                    }
                    _this.viewer.addTiledImage({
                        tileSource: tileSource,
                        x: data.x,
                        y: data.y,
                        width: data.width,
                        success: function (item) {
                            _this.items.push(item);
                            if (_this.items.length === resources.length) {
                                _this.openPagesHandler();
                            }
                            _this.resize();
                        }
                    });
                }
            });
        };
        SeadragonCenterPanel.prototype.getPagePositions = function (resources) {
            var leftPage;
            var rightPage;
            var topPage;
            var bottomPage;
            var page;
            var nextPage;
            // if there's more than one image, determine alignment strategy
            if (resources.length > 1) {
                if (resources.length === 2) {
                    // recto verso
                    if (this.extension.helper.isVerticallyAligned()) {
                        // vertical alignment
                        topPage = resources[0];
                        topPage.y = 0;
                        bottomPage = resources[1];
                        bottomPage.y = topPage.height + this.config.options.pageGap;
                    }
                    else {
                        // horizontal alignment
                        leftPage = resources[0];
                        leftPage.x = 0;
                        rightPage = resources[1];
                        rightPage.x = leftPage.width + this.config.options.pageGap;
                    }
                }
                else {
                    // scroll
                    if (this.extension.helper.isVerticallyAligned()) {
                        // vertical alignment
                        if (this.extension.helper.isTopToBottom()) {
                            // top to bottom
                            for (var i = 0; i < resources.length - 1; i++) {
                                page = resources[i];
                                nextPage = resources[i + 1];
                                nextPage.y = (page.y || 0) + page.height;
                                ;
                            }
                        }
                        else {
                            // bottom to top
                            for (var i = resources.length; i > 0; i--) {
                                page = resources[i];
                                nextPage = resources[i - 1];
                                nextPage.y = (page.y || 0) - page.height;
                            }
                        }
                    }
                    else {
                        // horizontal alignment
                        if (this.extension.helper.isLeftToRight()) {
                            // left to right
                            for (var i = 0; i < resources.length - 1; i++) {
                                page = resources[i];
                                nextPage = resources[i + 1];
                                nextPage.x = (page.x || 0) + page.width;
                            }
                        }
                        else {
                            // right to left
                            for (var i = resources.length - 1; i > 0; i--) {
                                page = resources[i];
                                nextPage = resources[i - 1];
                                nextPage.x = (page.x || 0) - page.width;
                            }
                        }
                    }
                }
            }
            return resources;
        };
        SeadragonCenterPanel.prototype.openPagesHandler = function () {
            this.component.publish(Events_1.Events.SEADRAGON_OPEN);
            if (this.extension.helper.isMultiCanvas() && !this.extension.helper.isContinuous()) {
                this.showPrevButton();
                this.showNextButton();
                $('.navigator').addClass('extraMargin');
                var viewingDirection = this.extension.helper.getViewingDirection() || manifesto.ViewingDirection.leftToRight();
                if (viewingDirection.toString() === manifesto.ViewingDirection.rightToLeft().toString()) {
                    if (this.extension.helper.isFirstCanvas()) {
                        this.disableNextButton();
                    }
                    else {
                        this.enableNextButton();
                    }
                    if (this.extension.helper.isLastCanvas()) {
                        this.disablePrevButton();
                    }
                    else {
                        this.enablePrevButton();
                    }
                }
                else {
                    if (this.extension.helper.isFirstCanvas()) {
                        this.disablePrevButton();
                    }
                    else {
                        this.enablePrevButton();
                    }
                    if (this.extension.helper.isLastCanvas()) {
                        this.disableNextButton();
                    }
                    else {
                        this.enableNextButton();
                    }
                }
            }
            this.setNavigatorVisible();
            this.overlayAnnotations();
            this.updateBounds();
            // this only happens if prev/next search result were clicked and caused a reload
            if (this.navigatedFromSearch) {
                this.navigatedFromSearch = false;
                this.zoomToInitialAnnotation();
            }
            this.isFirstLoad = false;
        };
        SeadragonCenterPanel.prototype.zoomToInitialAnnotation = function () {
            var annotationRect = this.getInitialAnnotationRect();
            this.extension.previousAnnotationRect = null;
            this.extension.currentAnnotationRect = null;
            if (annotationRect && this.isZoomToSearchResultEnabled()) {
                this.zoomToAnnotation(annotationRect);
            }
        };
        SeadragonCenterPanel.prototype.overlayAnnotations = function () {
            var annotations = this.getAnnotationsForCurrentImages();
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                var overlayRects = this.getAnnotationOverlayRects(annotation);
                for (var k = 0; k < overlayRects.length; k++) {
                    var overlayRect = overlayRects[k];
                    var div = document.createElement('div');
                    div.id = 'searchResult-' + overlayRect.canvasIndex + '-' + overlayRect.resultIndex;
                    div.className = 'searchOverlay';
                    div.title = Utils_1.UVUtils.sanitize(overlayRect.chars);
                    this.viewer.addOverlay(div, overlayRect);
                }
            }
        };
        SeadragonCenterPanel.prototype.updateBounds = function () {
            var settings = this.extension.getSettings();
            // if this is the first load and there are initial bounds, fit to those.
            if (this.isFirstLoad) {
                this.initialRotation = this.extension.data.rotation;
                if (this.initialRotation) {
                    this.viewer.viewport.setRotation(parseInt(this.initialRotation));
                }
                this.initialBounds = this.extension.data.xywh;
                if (this.initialBounds) {
                    this.initialBounds = Bounds_1.Bounds.fromString(this.initialBounds);
                    this.currentBounds = this.initialBounds;
                    this.fitToBounds(this.currentBounds);
                }
            }
            else if (settings.preserveViewport) {
                this.fitToBounds(this.currentBounds);
            }
            else {
                this.goHome();
            }
        };
        SeadragonCenterPanel.prototype.goHome = function () {
            this.viewer.viewport.goHome(true);
        };
        SeadragonCenterPanel.prototype.disablePrevButton = function () {
            this.prevButtonEnabled = false;
            this.$prevButton.addClass('disabled');
        };
        SeadragonCenterPanel.prototype.enablePrevButton = function () {
            this.prevButtonEnabled = true;
            this.$prevButton.removeClass('disabled');
        };
        SeadragonCenterPanel.prototype.hidePrevButton = function () {
            this.disablePrevButton();
            this.$prevButton.hide();
        };
        SeadragonCenterPanel.prototype.showPrevButton = function () {
            this.enablePrevButton();
            this.$prevButton.show();
        };
        SeadragonCenterPanel.prototype.disableNextButton = function () {
            this.nextButtonEnabled = false;
            this.$nextButton.addClass('disabled');
        };
        SeadragonCenterPanel.prototype.enableNextButton = function () {
            this.nextButtonEnabled = true;
            this.$nextButton.removeClass('disabled');
        };
        SeadragonCenterPanel.prototype.hideNextButton = function () {
            this.disableNextButton();
            this.$nextButton.hide();
        };
        SeadragonCenterPanel.prototype.showNextButton = function () {
            this.enableNextButton();
            this.$nextButton.show();
        };
        SeadragonCenterPanel.prototype.fitToBounds = function (bounds, immediate) {
            if (immediate === void 0) { immediate = true; }
            var rect = new OpenSeadragon.Rect();
            rect.x = Number(bounds.x);
            rect.y = Number(bounds.y);
            rect.width = Number(bounds.w);
            rect.height = Number(bounds.h);
            this.viewer.viewport.fitBoundsWithConstraints(rect, immediate);
        };
        SeadragonCenterPanel.prototype.getCroppedImageBounds = function () {
            if (!this.viewer || !this.viewer.viewport)
                return null;
            var canvas = this.extension.helper.getCurrentCanvas();
            var dimensions = this.extension.getCroppedImageDimensions(canvas, this.viewer);
            if (dimensions) {
                var bounds = new Bounds_1.Bounds(dimensions.regionPos.x, dimensions.regionPos.y, dimensions.region.width, dimensions.region.height);
                return bounds.toString();
            }
            return null;
        };
        SeadragonCenterPanel.prototype.getViewportBounds = function () {
            if (!this.viewer || !this.viewer.viewport)
                return null;
            var b = this.viewer.viewport.getBounds(true);
            var bounds = new Bounds_1.Bounds(Math.floor(b.x), Math.floor(b.y), Math.floor(b.width), Math.floor(b.height));
            return bounds;
        };
        SeadragonCenterPanel.prototype.viewerResize = function (viewer) {
            if (!viewer.viewport)
                return;
            var center = viewer.viewport.getCenter(true);
            if (!center)
                return;
            // postpone pan for a millisecond - fixes iPad image stretching/squashing issue.
            setTimeout(function () {
                viewer.viewport.panTo(center, true);
            }, 1);
        };
        SeadragonCenterPanel.prototype.clearAnnotations = function () {
            this.$canvas.find('.searchOverlay').hide();
        };
        SeadragonCenterPanel.prototype.getAnnotationsForCurrentImages = function () {
            var annotationsForCurrentImages = [];
            var annotations = this.extension.annotations;
            if (!annotations || !annotations.length)
                return annotationsForCurrentImages;
            var indices = this.extension.getPagedIndices();
            for (var i = 0; i < indices.length; i++) {
                var canvasIndex = indices[i];
                for (var j = 0; j < annotations.length; j++) {
                    if (annotations[j].canvasIndex === canvasIndex) {
                        annotationsForCurrentImages.push(annotations[j]);
                        break;
                    }
                }
            }
            return annotationsForCurrentImages;
        };
        SeadragonCenterPanel.prototype.getAnnotationRectsForCurrentImages = function () {
            var annotations = this.getAnnotationsForCurrentImages();
            return annotations.en().selectMany(function (x) { return x.rects; }).toArray();
        };
        SeadragonCenterPanel.prototype.updateVisibleAnnotationRects = function () {
            // after animating, loop through all search result rects and flag their visibility based on whether they are inside the current viewport.
            var annotationRects = this.getAnnotationRectsForCurrentImages();
            for (var i = 0; i < annotationRects.length; i++) {
                var rect = annotationRects[i];
                var viewportBounds = this.viewer.viewport.getBounds();
                rect.isVisible = Utils.Dimensions.hitRect(viewportBounds.x, viewportBounds.y, viewportBounds.width, viewportBounds.height, rect.viewportX, rect.viewportY);
            }
        };
        SeadragonCenterPanel.prototype.getAnnotationRectIndex = function (annotationRect) {
            var annotationRects = this.getAnnotationRectsForCurrentImages();
            return annotationRects.indexOf(annotationRect);
        };
        SeadragonCenterPanel.prototype.isZoomToSearchResultEnabled = function () {
            return Utils.Bools.getBool(this.extension.data.config.options.zoomToSearchResultEnabled, true);
        };
        SeadragonCenterPanel.prototype.prevAnnotation = function () {
            var annotationRects = this.getAnnotationRectsForCurrentImages();
            var currentAnnotationRect = this.extension.currentAnnotationRect;
            var currentAnnotationRectIndex = currentAnnotationRect ? this.getAnnotationRectIndex(currentAnnotationRect) : annotationRects.length;
            //const currentAnnotationRectIndex: number = this.getAnnotationRectIndex(<AnnotationRect>currentAnnotationRect);
            var foundRect = null;
            // if there's no currentAnnotationRect selected, index is the total available annotation rects for the current images.
            // minusing 1 makes the index the last of the available rects for the current images.
            for (var i = currentAnnotationRectIndex - 1; i >= 0; i--) {
                var rect = annotationRects[i];
                // this was removed as users found it confusing.
                // find the prev visible or non-visible rect.
                //if (rect.isVisible) {
                //    continue;
                //} else {
                foundRect = rect;
                break;
                //}
            }
            if (foundRect && this.isZoomToSearchResultEnabled()) {
                // if the rect's canvasIndex is less than the current canvasIndex
                if (foundRect.canvasIndex < this.extension.helper.canvasIndex) {
                    this.extension.currentAnnotationRect = foundRect;
                    this.navigatedFromSearch = true;
                    this.component.publish(BaseEvents_1.BaseEvents.ANNOTATION_CANVAS_CHANGED, foundRect);
                }
                else {
                    this.zoomToAnnotation(foundRect);
                }
            }
            else {
                this.navigatedFromSearch = true;
                this.component.publish(Events_1.Events.PREV_IMAGES_SEARCH_RESULT_UNAVAILABLE);
            }
        };
        SeadragonCenterPanel.prototype.nextAnnotation = function () {
            var annotationRects = this.getAnnotationRectsForCurrentImages();
            var currentAnnotationRect = this.extension.currentAnnotationRect;
            var currentAnnotationRectIndex = currentAnnotationRect ? this.getAnnotationRectIndex(currentAnnotationRect) : -1;
            var foundRect = null;
            // if there's no currentAnnotationRect selected, index is -1.
            // adding 1 makes the index 0 of available rects for the current images.
            for (var i = currentAnnotationRectIndex + 1; i < annotationRects.length; i++) {
                var rect = annotationRects[i];
                // this was removed as users found it confusing.
                // find the next visible or non-visible rect.
                //if (rect.isVisible) {
                //    continue;
                //} else {
                foundRect = rect;
                break;
                //}
            }
            if (foundRect && this.isZoomToSearchResultEnabled()) {
                // if the rect's canvasIndex is greater than the current canvasIndex
                if (foundRect.canvasIndex > this.extension.helper.canvasIndex) {
                    this.extension.currentAnnotationRect = foundRect;
                    this.navigatedFromSearch = true;
                    this.component.publish(BaseEvents_1.BaseEvents.ANNOTATION_CANVAS_CHANGED, [foundRect]);
                }
                else {
                    this.zoomToAnnotation(foundRect);
                }
            }
            else {
                this.navigatedFromSearch = true;
                this.component.publish(Events_1.Events.NEXT_IMAGES_SEARCH_RESULT_UNAVAILABLE);
            }
        };
        SeadragonCenterPanel.prototype.getAnnotationRectByIndex = function (index) {
            var annotationRects = this.getAnnotationRectsForCurrentImages();
            if (!annotationRects.length)
                return null;
            return annotationRects[index];
        };
        SeadragonCenterPanel.prototype.getInitialAnnotationRect = function () {
            var _this = this;
            var annotationRects = this.getAnnotationRectsForCurrentImages();
            if (!annotationRects.length)
                return null;
            // if we've got this far it means that a reload has happened
            // check if the lastCanvasIndex is greater or less than the current canvasIndex
            // if greater than, select the last annotation on the current page
            // if less than, select the first annotation on the current page
            // otherwise default to the first annotation
            var previousAnnotationRect = this.extension.previousAnnotationRect;
            if (!previousAnnotationRect) {
                if (this.extension.lastCanvasIndex > this.extension.helper.canvasIndex) {
                    return annotationRects.en().where(function (x) { return x.canvasIndex === _this.extension.helper.canvasIndex; }).last();
                }
            }
            return annotationRects.en().where(function (x) { return x.canvasIndex === _this.extension.helper.canvasIndex; }).first();
        };
        SeadragonCenterPanel.prototype.zoomToAnnotation = function (annotationRect) {
            this.extension.previousAnnotationRect = this.extension.currentAnnotationRect || annotationRect;
            this.extension.currentAnnotationRect = annotationRect;
            // if zoomToBoundsEnabled, zoom to the annotation's bounds.
            // otherwise, pan into view preserving the current zoom level.
            if (Utils.Bools.getBool(this.extension.data.config.options.zoomToBoundsEnabled, false)) {
                this.fitToBounds(new Bounds_1.Bounds(annotationRect.viewportX, annotationRect.viewportY, annotationRect.width, annotationRect.height), false);
            }
            else {
                var x = annotationRect.viewportX - ((this.currentBounds.w * 0.5) - annotationRect.width * 0.5);
                var y = annotationRect.viewportY - ((this.currentBounds.h * 0.5) - annotationRect.height * 0.5);
                var w = this.currentBounds.w;
                var h = this.currentBounds.h;
                var bounds = new Bounds_1.Bounds(x, y, w, h);
                this.fitToBounds(bounds);
            }
            this.highlightAnnotationRect(annotationRect);
            this.component.publish(BaseEvents_1.BaseEvents.ANNOTATION_CHANGED);
        };
        SeadragonCenterPanel.prototype.highlightAnnotationRect = function (annotationRect) {
            var $rect = $('#searchResult-' + annotationRect.canvasIndex + '-' + annotationRect.index);
            $rect.addClass('current');
            $('.searchOverlay').not($rect).removeClass('current');
        };
        SeadragonCenterPanel.prototype.getAnnotationOverlayRects = function (annotationGroup) {
            var newRects = [];
            if (!this.extension.resources) {
                return newRects;
            }
            var resource = this.extension.resources.en().where(function (x) { return x.index === annotationGroup.canvasIndex; }).first();
            var index = this.extension.resources.indexOf(resource);
            var offsetX = 0;
            if (index > 0) {
                offsetX = this.extension.resources[index - 1].width;
            }
            for (var i = 0; i < annotationGroup.rects.length; i++) {
                var searchRect = annotationGroup.rects[i];
                var x = (searchRect.x + offsetX) + ((index > 0) ? this.config.options.pageGap : 0);
                var y = searchRect.y;
                var w = searchRect.width;
                var h = searchRect.height;
                var rect = new OpenSeadragon.Rect(x, y, w, h);
                searchRect.viewportX = x;
                searchRect.viewportY = y;
                rect.canvasIndex = searchRect.canvasIndex;
                rect.resultIndex = searchRect.index;
                rect.chars = searchRect.chars;
                newRects.push(rect);
            }
            return newRects;
        };
        SeadragonCenterPanel.prototype.resize = function () {
            var _this = this;
            _super.prototype.resize.call(this);
            this.$viewer.height(this.$content.height() - this.$viewer.verticalMargins());
            this.$viewer.width(this.$content.width() - this.$viewer.horizontalMargins());
            if (!this.isCreated)
                return;
            if (this.title) {
                this.$title.text(Utils_1.UVUtils.sanitize(this.title));
            }
            this.$spinner.css('top', (this.$content.height() / 2) - (this.$spinner.height() / 2));
            this.$spinner.css('left', (this.$content.width() / 2) - (this.$spinner.width() / 2));
            var viewingDirection = this.extension.helper.getViewingDirection() || manifesto.ViewingDirection.leftToRight();
            ;
            if (this.extension.helper.isMultiCanvas() && this.$prevButton && this.$nextButton) {
                var verticalButtonPos = Math.floor(this.$content.width() / 2);
                switch (viewingDirection.toString()) {
                    case manifesto.ViewingDirection.bottomToTop().toString():
                        this.$prevButton.addClass('down');
                        this.$nextButton.addClass('up');
                        this.$prevButton.css('left', verticalButtonPos - (this.$prevButton.outerWidth() / 2));
                        this.$prevButton.css('top', (this.$content.height() - this.$prevButton.height()));
                        this.$nextButton.css('left', (verticalButtonPos * -1) - (this.$nextButton.outerWidth() / 2));
                        break;
                    case manifesto.ViewingDirection.topToBottom().toString():
                        this.$prevButton.css('left', verticalButtonPos - (this.$prevButton.outerWidth() / 2));
                        this.$nextButton.css('left', (verticalButtonPos * -1) - (this.$nextButton.outerWidth() / 2));
                        this.$nextButton.css('top', (this.$content.height() - this.$nextButton.height()));
                        break;
                    default:
                        this.$prevButton.css('top', (this.$content.height() - this.$prevButton.height()) / 2);
                        this.$nextButton.css('top', (this.$content.height() - this.$nextButton.height()) / 2);
                        break;
                }
            }
            // stretch navigator, allowing time for OSD to resize
            setTimeout(function () {
                if (_this.extension.helper.isContinuous()) {
                    if (_this.extension.helper.isHorizontallyAligned()) {
                        var width = _this.$viewer.width() - _this.$viewer.rightMargin();
                        _this.$navigator.width(width);
                    }
                    else {
                        _this.$navigator.height(_this.$viewer.height());
                    }
                }
            }, 100);
        };
        SeadragonCenterPanel.prototype.setFocus = function () {
            if (!this.$canvas.is(":focus")) {
                if (this.extension.data.config.options.allowStealFocus) {
                    this.$canvas.focus();
                }
            }
        };
        SeadragonCenterPanel.prototype.setNavigatorVisible = function () {
            var navigatorEnabled = Utils.Bools.getBool(this.extension.getSettings().navigatorEnabled, true) && this.extension.isDesktopMetric();
            this.viewer.navigator.setVisible(navigatorEnabled);
            if (navigatorEnabled) {
                this.$navigator.show();
            }
            else {
                this.$navigator.hide();
            }
        };
        return SeadragonCenterPanel;
    }(CenterPanel_1.CenterPanel));
    exports.SeadragonCenterPanel = SeadragonCenterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-seadragon-extension/SettingsDialogue',["require", "exports", "../../modules/uv-dialogues-module/SettingsDialogue"], function (require, exports, SettingsDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsDialogue = /** @class */ (function (_super) {
        __extends(SettingsDialogue, _super);
        function SettingsDialogue($element) {
            return _super.call(this, $element) || this;
        }
        SettingsDialogue.prototype.create = function () {
            var _this = this;
            this.setConfig('settingsDialogue');
            _super.prototype.create.call(this);
            this.$navigatorEnabled = $('<div class="setting navigatorEnabled"></div>');
            this.$scroll.append(this.$navigatorEnabled);
            // todo: use .checkboxButton jquery extension
            this.$navigatorEnabledCheckbox = $('<input id="navigatorEnabled" type="checkbox" tabindex="0" />');
            this.$navigatorEnabled.append(this.$navigatorEnabledCheckbox);
            this.$navigatorEnabledLabel = $('<label for="navigatorEnabled">' + this.content.navigatorEnabled + '</label>');
            this.$navigatorEnabled.append(this.$navigatorEnabledLabel);
            this.$pagingEnabled = $('<div class="setting pagingEnabled"></div>');
            this.$scroll.append(this.$pagingEnabled);
            this.$pagingEnabledCheckbox = $('<input id="pagingEnabled" type="checkbox" tabindex="0" />');
            this.$pagingEnabled.append(this.$pagingEnabledCheckbox);
            this.$pagingEnabledLabel = $('<label for="pagingEnabled">' + this.content.pagingEnabled + '</label>');
            this.$pagingEnabled.append(this.$pagingEnabledLabel);
            this.$clickToZoomEnabled = $('<div class="setting clickToZoom"></div>');
            this.$scroll.append(this.$clickToZoomEnabled);
            this.$clickToZoomEnabledCheckbox = $('<input id="clickToZoomEnabled" type="checkbox" />');
            this.$clickToZoomEnabled.append(this.$clickToZoomEnabledCheckbox);
            this.$clickToZoomEnabledLabel = $('<label for="clickToZoomEnabled">' + this.content.clickToZoomEnabled + '</label>');
            this.$clickToZoomEnabled.append(this.$clickToZoomEnabledLabel);
            this.$preserveViewport = $('<div class="setting preserveViewport"></div>');
            this.$scroll.append(this.$preserveViewport);
            this.$preserveViewportCheckbox = $('<input id="preserveViewport" type="checkbox" tabindex="0" />');
            this.$preserveViewport.append(this.$preserveViewportCheckbox);
            this.$preserveViewportLabel = $('<label for="preserveViewport">' + this.content.preserveViewport + '</label>');
            this.$preserveViewport.append(this.$preserveViewportLabel);
            this.$navigatorEnabledCheckbox.change(function () {
                var settings = {};
                if (_this.$navigatorEnabledCheckbox.is(":checked")) {
                    settings.navigatorEnabled = true;
                }
                else {
                    settings.navigatorEnabled = false;
                }
                _this.updateSettings(settings);
            });
            this.$clickToZoomEnabledCheckbox.change(function () {
                var settings = {};
                if (_this.$clickToZoomEnabledCheckbox.is(":checked")) {
                    settings.clickToZoomEnabled = true;
                }
                else {
                    settings.clickToZoomEnabled = false;
                }
                _this.updateSettings(settings);
            });
            this.$pagingEnabledCheckbox.change(function () {
                var settings = {};
                if (_this.$pagingEnabledCheckbox.is(":checked")) {
                    settings.pagingEnabled = true;
                }
                else {
                    settings.pagingEnabled = false;
                }
                _this.updateSettings(settings);
            });
            this.$preserveViewportCheckbox.change(function () {
                var settings = {};
                if (_this.$preserveViewportCheckbox.is(":checked")) {
                    settings.preserveViewport = true;
                }
                else {
                    settings.preserveViewport = false;
                }
                _this.updateSettings(settings);
            });
        };
        SettingsDialogue.prototype.open = function () {
            _super.prototype.open.call(this);
            var settings = this.getSettings();
            if (settings.navigatorEnabled) {
                this.$navigatorEnabledCheckbox.prop("checked", true);
            }
            else {
                this.$navigatorEnabledCheckbox.removeAttr("checked");
            }
            if (settings.clickToZoomEnabled) {
                this.$clickToZoomEnabledCheckbox.prop("checked", true);
            }
            else {
                this.$clickToZoomEnabledCheckbox.removeAttr("checked");
            }
            if (!this.extension.helper.isPagingAvailable()) {
                this.$pagingEnabled.hide();
            }
            else {
                if (settings.pagingEnabled) {
                    this.$pagingEnabledCheckbox.prop("checked", true);
                }
                else {
                    this.$pagingEnabledCheckbox.removeAttr("checked");
                }
            }
            if (settings.preserveViewport) {
                this.$preserveViewportCheckbox.prop("checked", true);
            }
            else {
                this.$preserveViewportCheckbox.removeAttr("checked");
            }
        };
        return SettingsDialogue;
    }(SettingsDialogue_1.SettingsDialogue));
    exports.SettingsDialogue = SettingsDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-seadragon-extension/ShareDialogue',["require", "exports", "./Events", "../../modules/uv-dialogues-module/ShareDialogue"], function (require, exports, Events_1, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShareDialogue = /** @class */ (function (_super) {
        __extends(ShareDialogue, _super);
        function ShareDialogue($element) {
            var _this = _super.call(this, $element) || this;
            _this.component.subscribe(Events_1.Events.SEADRAGON_OPEN, function () {
                _this.update();
            });
            _this.component.subscribe(Events_1.Events.SEADRAGON_ANIMATION_FINISH, function () {
                _this.update();
            });
            return _this;
        }
        ShareDialogue.prototype.create = function () {
            this.setConfig('shareDialogue');
            _super.prototype.create.call(this);
        };
        ShareDialogue.prototype.update = function () {
            _super.prototype.update.call(this);
            var xywh = this.extension.getViewportBounds();
            var rotation = this.extension.getViewerRotation();
            this.code = this.extension.getEmbedScript(this.options.embedTemplate, this.currentWidth, this.currentHeight, xywh, rotation);
            this.$code.val(this.code);
        };
        ShareDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ShareDialogue;
    }(ShareDialogue_1.ShareDialogue));
    exports.ShareDialogue = ShareDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-seadragon-extension/Extension',["require", "exports", "../../modules/uv-shared-module/AnnotationResults", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-shared-module/BaseExtension", "../../modules/uv-shared-module/Bookmark", "../../modules/uv-contentleftpanel-module/ContentLeftPanel", "./CroppedImageDimensions", "./DownloadDialogue", "./Events", "../../modules/uv-dialogues-module/ExternalContentDialogue", "../../modules/uv-osdmobilefooterpanel-module/MobileFooter", "../../modules/uv-searchfooterpanel-module/FooterPanel", "../../modules/uv-dialogues-module/HelpDialogue", "./Mode", "../../modules/uv-dialogues-module/MoreInfoDialogue", "../../modules/uv-moreinforightpanel-module/MoreInfoRightPanel", "../../modules/uv-multiselectdialogue-module/MultiSelectDialogue", "./MultiSelectionArgs", "../../modules/uv-pagingheaderpanel-module/PagingHeaderPanel", "../../modules/uv-shared-module/Point", "../../modules/uv-seadragoncenterpanel-module/SeadragonCenterPanel", "./SettingsDialogue", "./ShareDialogue"], function (require, exports, AnnotationResults_1, BaseEvents_1, BaseExtension_1, Bookmark_1, ContentLeftPanel_1, CroppedImageDimensions_1, DownloadDialogue_1, Events_1, ExternalContentDialogue_1, MobileFooter_1, FooterPanel_1, HelpDialogue_1, Mode_1, MoreInfoDialogue_1, MoreInfoRightPanel_1, MultiSelectDialogue_1, MultiSelectionArgs_1, PagingHeaderPanel_1, Point_1, SeadragonCenterPanel_1, SettingsDialogue_1, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AnnotationGroup = Manifold.AnnotationGroup;
    var Extension = /** @class */ (function (_super) {
        __extends(Extension, _super);
        function Extension() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.annotations = [];
            _this.currentRotation = 0;
            _this.isAnnotating = false;
            return _this;
        }
        Extension.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.METRIC_CHANGED, function () {
                if (!_this.isDesktopMetric()) {
                    var settings = {};
                    settings.pagingEnabled = false;
                    _this.updateSettings(settings);
                    _this.component.publish(BaseEvents_1.BaseEvents.UPDATE_SETTINGS);
                    _this.shell.$rightPanel.hide();
                }
                else {
                    _this.shell.$rightPanel.show();
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.previousAnnotationRect = null;
                _this.currentAnnotationRect = null;
                _this.viewPage(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CLEAR_ANNOTATIONS, function () {
                _this.clearAnnotations();
                _this.component.publish(BaseEvents_1.BaseEvents.ANNOTATIONS_CLEARED);
                _this.fire(BaseEvents_1.BaseEvents.CLEAR_ANNOTATIONS);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.DOWN_ARROW, function () {
                if (!_this.useArrowKeysToNavigate()) {
                    _this.centerPanel.setFocus();
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.END, function () {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.helper.getLastPageIndex());
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.FIRST, function () {
                _this.fire(BaseEvents_1.BaseEvents.FIRST);
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.helper.getFirstPageIndex());
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.GALLERY_DECREASE_SIZE, function () {
                _this.fire(BaseEvents_1.BaseEvents.GALLERY_DECREASE_SIZE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.GALLERY_INCREASE_SIZE, function () {
                _this.fire(BaseEvents_1.BaseEvents.GALLERY_INCREASE_SIZE);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.GALLERY_THUMB_SELECTED, function () {
                _this.fire(BaseEvents_1.BaseEvents.GALLERY_THUMB_SELECTED);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HOME, function () {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.helper.getFirstPageIndex());
            });
            this.component.subscribe(Events_1.Events.IMAGE_SEARCH, function (index) {
                _this.fire(Events_1.Events.IMAGE_SEARCH, index);
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, index);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LAST, function () {
                _this.fire(BaseEvents_1.BaseEvents.LAST);
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.helper.getLastPageIndex());
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFT_ARROW, function () {
                if (_this.useArrowKeysToNavigate()) {
                    _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.getPrevPageIndex());
                }
                else {
                    _this.centerPanel.setFocus();
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_START, function () {
                if (_this.isDesktopMetric()) {
                    _this.shell.$rightPanel.show();
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH, function () {
                _this.shell.$centerPanel.show();
                _this.resize();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START, function () {
                _this.shell.$centerPanel.hide();
                _this.shell.$rightPanel.hide();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.MINUS, function () {
                _this.centerPanel.setFocus();
            });
            this.component.subscribe(Events_1.Events.MODE_CHANGED, function (mode) {
                _this.fire(Events_1.Events.MODE_CHANGED, mode);
                _this.mode = new Mode_1.Mode(mode);
                var settings = _this.getSettings();
                _this.component.publish(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, settings);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.MULTISELECTION_MADE, function (ids) {
                var args = new MultiSelectionArgs_1.MultiSelectionArgs();
                args.manifestUri = _this.helper.iiifResourceUri;
                args.allCanvases = ids.length === _this.helper.getCanvases().length;
                args.canvases = ids;
                args.format = _this.data.config.options.multiSelectionMimeType;
                args.sequence = _this.helper.getCurrentSequence().id;
                _this.fire(BaseEvents_1.BaseEvents.MULTISELECTION_MADE, args);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.NEXT, function () {
                _this.fire(BaseEvents_1.BaseEvents.NEXT);
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.getNextPageIndex());
            });
            this.component.subscribe(Events_1.Events.NEXT_SEARCH_RESULT, function () {
                _this.fire(Events_1.Events.NEXT_SEARCH_RESULT);
            });
            this.component.subscribe(Events_1.Events.NEXT_IMAGES_SEARCH_RESULT_UNAVAILABLE, function () {
                _this.fire(Events_1.Events.NEXT_IMAGES_SEARCH_RESULT_UNAVAILABLE);
                _this.nextSearchResult();
            });
            this.component.subscribe(Events_1.Events.PREV_IMAGES_SEARCH_RESULT_UNAVAILABLE, function () {
                _this.fire(Events_1.Events.PREV_IMAGES_SEARCH_RESULT_UNAVAILABLE);
                _this.prevSearchResult();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_THUMBS_VIEW, function () {
                _this.fire(BaseEvents_1.BaseEvents.OPEN_THUMBS_VIEW);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_TREE_VIEW, function () {
                _this.fire(BaseEvents_1.BaseEvents.OPEN_TREE_VIEW);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.PAGE_DOWN, function () {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.getNextPageIndex());
            });
            this.component.subscribe(Events_1.Events.PAGE_SEARCH, function (value) {
                _this.fire(Events_1.Events.PAGE_SEARCH, value);
                _this.viewLabel(value);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.PAGE_UP, function () {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.getPrevPageIndex());
            });
            this.component.subscribe(Events_1.Events.PAGING_TOGGLED, function (obj) {
                _this.fire(Events_1.Events.PAGING_TOGGLED, obj);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.PLUS, function () {
                _this.centerPanel.setFocus();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.PREV, function () {
                _this.fire(BaseEvents_1.BaseEvents.PREV);
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.getPrevPageIndex());
            });
            this.component.subscribe(Events_1.Events.PREV_SEARCH_RESULT, function () {
                _this.fire(Events_1.Events.PREV_SEARCH_RESULT);
            });
            this.component.subscribe(Events_1.Events.PRINT, function () {
                _this.print();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RELOAD, function () {
                _this.component.publish(BaseEvents_1.BaseEvents.CLEAR_ANNOTATIONS);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.RIGHT_ARROW, function () {
                if (_this.useArrowKeysToNavigate()) {
                    _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.getNextPageIndex());
                }
                else {
                    _this.centerPanel.setFocus();
                }
            });
            this.component.subscribe(Events_1.Events.SEADRAGON_ANIMATION, function () {
                _this.fire(Events_1.Events.SEADRAGON_ANIMATION);
            });
            this.component.subscribe(Events_1.Events.SEADRAGON_ANIMATION_FINISH, function (viewer) {
                var bounds = _this.centerPanel.getViewportBounds();
                if (_this.centerPanel && bounds) {
                    _this.component.publish(Events_1.Events.XYWH_CHANGED, bounds.toString());
                    _this.data.xywh = bounds.toString();
                    _this.fire(Events_1.Events.XYWH_CHANGED, _this.data.xywh);
                }
                var canvas = _this.helper.getCurrentCanvas();
                _this.fire(Events_1.Events.CURRENT_VIEW_URI, {
                    cropUri: _this.getCroppedImageUri(canvas, _this.getViewer()),
                    fullUri: _this.getConfinedImageUri(canvas, canvas.getWidth())
                });
            });
            this.component.subscribe(Events_1.Events.SEADRAGON_ANIMATION_START, function () {
                _this.fire(Events_1.Events.SEADRAGON_ANIMATION_START);
            });
            this.component.subscribe(Events_1.Events.SEADRAGON_OPEN, function () {
                if (!_this.useArrowKeysToNavigate()) {
                    _this.centerPanel.setFocus();
                }
                _this.fire(Events_1.Events.SEADRAGON_OPEN);
            });
            this.component.subscribe(Events_1.Events.SEADRAGON_RESIZE, function () {
                _this.fire(Events_1.Events.SEADRAGON_RESIZE);
            });
            this.component.subscribe(Events_1.Events.SEADRAGON_ROTATION, function (rotation) {
                _this.data.rotation = rotation;
                _this.fire(Events_1.Events.SEADRAGON_ROTATION, _this.data.rotation);
                _this.currentRotation = rotation;
            });
            this.component.subscribe(Events_1.Events.SEARCH, function (terms) {
                _this.fire(Events_1.Events.SEARCH, terms);
                _this.search(terms);
            });
            this.component.subscribe(Events_1.Events.SEARCH_PREVIEW_FINISH, function () {
                _this.fire(Events_1.Events.SEARCH_PREVIEW_FINISH);
            });
            this.component.subscribe(Events_1.Events.SEARCH_PREVIEW_START, function () {
                _this.fire(Events_1.Events.SEARCH_PREVIEW_START);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS, function (obj) {
                _this.fire(BaseEvents_1.BaseEvents.ANNOTATIONS, obj);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATION_CANVAS_CHANGED, function (rect) {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, rect.canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.ANNOTATIONS_EMPTY, function () {
                _this.fire(BaseEvents_1.BaseEvents.ANNOTATIONS_EMPTY);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.THUMB_SELECTED, function (thumb) {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, thumb.index);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.TREE_NODE_SELECTED, function (node) {
                _this.fire(BaseEvents_1.BaseEvents.TREE_NODE_SELECTED, node.data.path);
                _this.treeNodeSelected(node);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.UP_ARROW, function () {
                if (!_this.useArrowKeysToNavigate()) {
                    _this.centerPanel.setFocus();
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.UPDATE_SETTINGS, function () {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, _this.helper.canvasIndex);
                var settings = _this.getSettings();
                _this.component.publish(BaseEvents_1.BaseEvents.SETTINGS_CHANGED, settings);
            });
            // this.component.subscribe(Events.VIEW_PAGE, (e: any, index: number) => {
            //     this.fire(Events.VIEW_PAGE, index);
            //     this.component.publish(BaseEvents.CANVAS_INDEX_CHANGED, [index]);
            // });
        };
        Extension.prototype.createModules = function () {
            _super.prototype.createModules.call(this);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel = new PagingHeaderPanel_1.PagingHeaderPanel(this.shell.$headerPanel);
            }
            else {
                this.shell.$headerPanel.hide();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel = new ContentLeftPanel_1.ContentLeftPanel(this.shell.$leftPanel);
            }
            else {
                this.shell.$leftPanel.hide();
            }
            this.centerPanel = new SeadragonCenterPanel_1.SeadragonCenterPanel(this.shell.$centerPanel);
            if (this.isRightPanelEnabled()) {
                this.rightPanel = new MoreInfoRightPanel_1.MoreInfoRightPanel(this.shell.$rightPanel);
            }
            else {
                this.shell.$rightPanel.hide();
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel = new FooterPanel_1.FooterPanel(this.shell.$footerPanel);
                this.mobileFooterPanel = new MobileFooter_1.FooterPanel(this.shell.$mobileFooterPanel);
            }
            else {
                this.shell.$footerPanel.hide();
            }
            this.$helpDialogue = $('<div class="overlay help" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$helpDialogue);
            this.helpDialogue = new HelpDialogue_1.HelpDialogue(this.$helpDialogue);
            this.$moreInfoDialogue = $('<div class="overlay moreInfo" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$moreInfoDialogue);
            this.moreInfoDialogue = new MoreInfoDialogue_1.MoreInfoDialogue(this.$moreInfoDialogue);
            this.$multiSelectDialogue = $('<div class="overlay multiSelect" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$multiSelectDialogue);
            this.multiSelectDialogue = new MultiSelectDialogue_1.MultiSelectDialogue(this.$multiSelectDialogue);
            this.$shareDialogue = $('<div class="overlay share" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$shareDialogue);
            this.shareDialogue = new ShareDialogue_1.ShareDialogue(this.$shareDialogue);
            this.$downloadDialogue = $('<div class="overlay download" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$downloadDialogue);
            this.downloadDialogue = new DownloadDialogue_1.DownloadDialogue(this.$downloadDialogue);
            this.$settingsDialogue = $('<div class="overlay settings" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$settingsDialogue);
            this.settingsDialogue = new SettingsDialogue_1.SettingsDialogue(this.$settingsDialogue);
            this.$externalContentDialogue = $('<div class="overlay externalContent" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$externalContentDialogue);
            this.externalContentDialogue = new ExternalContentDialogue_1.ExternalContentDialogue(this.$externalContentDialogue);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel.init();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel.init();
            }
            if (this.isRightPanelEnabled()) {
                this.rightPanel.init();
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel.init();
            }
        };
        Extension.prototype.render = function () {
            _super.prototype.render.call(this);
            //Utils.Async.waitFor(() => {
            //    return this.centerPanel && this.centerPanel.isCreated;
            //}, () => {
            this.checkForAnnotations();
            this.checkForSearchParam();
            this.checkForRotationParam();
            //});
        };
        Extension.prototype.checkForAnnotations = function () {
            if (this.data.annotations) {
                var annotations = this.parseAnnotationList(this.data.annotations);
                this.component.publish(BaseEvents_1.BaseEvents.CLEAR_ANNOTATIONS);
                this.annotate(annotations);
            }
        };
        Extension.prototype.annotate = function (annotations, terms) {
            this.annotations = annotations;
            // sort the annotations by canvasIndex
            this.annotations = annotations.sort(function (a, b) {
                return a.canvasIndex - b.canvasIndex;
            });
            var annotationResults = new AnnotationResults_1.AnnotationResults();
            annotationResults.terms = terms;
            annotationResults.annotations = this.annotations;
            this.component.publish(BaseEvents_1.BaseEvents.ANNOTATIONS, annotationResults);
            // reload current index as it may contain annotations.
            //this.component.publish(BaseEvents.CANVAS_INDEX_CHANGED, [this.helper.canvasIndex]);
        };
        Extension.prototype.checkForSearchParam = function () {
            // if a highlight param is set, use it to search.
            var highlight = this.data.highlight;
            if (highlight) {
                highlight.replace(/\+/g, " ").replace(/"/g, "");
                this.component.publish(Events_1.Events.SEARCH, highlight);
            }
        };
        Extension.prototype.checkForRotationParam = function () {
            // if a rotation value is passed, set rotation
            var rotation = this.data.rotation;
            if (rotation) {
                this.component.publish(Events_1.Events.SEADRAGON_ROTATION, rotation);
            }
        };
        Extension.prototype.viewPage = function (canvasIndex) {
            // if it's an invalid canvas index.
            if (canvasIndex === -1)
                return;
            var isReload = false;
            if (canvasIndex === this.helper.canvasIndex) {
                isReload = true;
            }
            if (this.helper.isCanvasIndexOutOfRange(canvasIndex)) {
                this.showMessage(this.data.config.content.canvasIndexOutOfRange);
                canvasIndex = 0;
            }
            if (this.isPagingSettingEnabled() && !isReload) {
                var indices = this.getPagedIndices(canvasIndex);
                // if the page is already displayed, only advance canvasIndex.
                if (indices.includes(this.helper.canvasIndex)) {
                    this.viewCanvas(canvasIndex);
                    return;
                }
            }
            this.viewCanvas(canvasIndex);
        };
        Extension.prototype.getViewer = function () {
            return this.centerPanel.viewer;
        };
        Extension.prototype.getMode = function () {
            if (this.mode)
                return this.mode;
            switch (this.helper.getManifestType().toString()) {
                case manifesto.ManifestType.monograph().toString():
                    return Mode_1.Mode.page;
                case manifesto.ManifestType.manuscript().toString():
                    return Mode_1.Mode.page;
                default:
                    return Mode_1.Mode.image;
            }
        };
        Extension.prototype.getViewportBounds = function () {
            if (!this.centerPanel)
                return null;
            var bounds = this.centerPanel.getViewportBounds();
            if (bounds) {
                return bounds.toString();
            }
            return null;
        };
        Extension.prototype.getViewerRotation = function () {
            if (!this.centerPanel)
                return null;
            return this.currentRotation;
        };
        Extension.prototype.viewRange = function (path) {
            //this.currentRangePath = path;
            var range = this.helper.getRangeByPath(path);
            if (!range)
                return;
            var canvasId = range.getCanvasIds()[0];
            var index = this.helper.getCanvasIndexById(canvasId);
            this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, index);
        };
        Extension.prototype.viewLabel = function (label) {
            if (!label) {
                this.showMessage(this.data.config.modules.genericDialogue.content.emptyValue);
                this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED);
                return;
            }
            var index = this.helper.getCanvasIndexByLabel(label);
            if (index != -1) {
                this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, index);
            }
            else {
                this.showMessage(this.data.config.modules.genericDialogue.content.pageNotFound);
                this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGE_FAILED);
            }
        };
        Extension.prototype.treeNodeSelected = function (node) {
            var data = node.data;
            if (!data.type)
                return;
            switch (data.type) {
                case manifesto.IIIFResourceType.manifest().toString():
                    this.viewManifest(data);
                    break;
                case manifesto.IIIFResourceType.collection().toString():
                    // note: this won't get called as the tree component now has branchNodesSelectable = false
                    // useful to keep around for reference
                    this.viewCollection(data);
                    break;
                default:
                    this.viewRange(data.path);
                    break;
            }
        };
        Extension.prototype.clearAnnotations = function () {
            this.annotations = null;
            // reload current index as it may contain results.
            this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, this.helper.canvasIndex);
        };
        Extension.prototype.prevSearchResult = function () {
            var foundResult;
            if (!this.annotations)
                return;
            // get the first result with a canvasIndex less than the current index.
            for (var i = this.annotations.length - 1; i >= 0; i--) {
                var result = this.annotations[i];
                if (result.canvasIndex <= this.getPrevPageIndex()) {
                    foundResult = result;
                    this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, foundResult.canvasIndex);
                    break;
                }
            }
        };
        Extension.prototype.nextSearchResult = function () {
            if (!this.annotations)
                return;
            // get the first result with an index greater than the current index.
            for (var i = 0; i < this.annotations.length; i++) {
                var result = this.annotations[i];
                if (result && result.canvasIndex >= this.getNextPageIndex()) {
                    this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, result.canvasIndex);
                    break;
                }
            }
        };
        Extension.prototype.bookmark = function () {
            _super.prototype.bookmark.call(this);
            var canvas = this.helper.getCurrentCanvas();
            var bookmark = new Bookmark_1.Bookmark();
            bookmark.index = this.helper.canvasIndex;
            bookmark.label = Manifesto.LanguageMap.getValue(canvas.getLabel());
            bookmark.path = this.getCroppedImageUri(canvas, this.getViewer());
            bookmark.thumb = canvas.getCanonicalImageUri(this.data.config.options.bookmarkThumbWidth);
            bookmark.title = this.helper.getLabel();
            bookmark.trackingLabel = window.trackingLabel;
            bookmark.type = manifesto.ResourceType.image().toString();
            this.fire(BaseEvents_1.BaseEvents.BOOKMARK, bookmark);
        };
        Extension.prototype.print = function () {
            // var args: MultiSelectionArgs = new MultiSelectionArgs();
            // args.manifestUri = this.helper.iiifResourceUri;
            // args.allCanvases = true;
            // args.format = this.data.config.options.printMimeType;
            // args.sequence = this.helper.getCurrentSequence().id;
            window.print();
            this.fire(Events_1.Events.PRINT);
        };
        Extension.prototype.getCroppedImageDimensions = function (canvas, viewer) {
            if (!viewer)
                return null;
            if (!viewer.viewport)
                return null;
            if (!canvas.getHeight() || !canvas.getWidth()) {
                return null;
            }
            var bounds = viewer.viewport.getBounds(true);
            var dimensions = new CroppedImageDimensions_1.CroppedImageDimensions();
            var width = Math.floor(bounds.width);
            var height = Math.floor(bounds.height);
            var x = Math.floor(bounds.x);
            var y = Math.floor(bounds.y);
            // constrain to image bounds
            if (x + width > canvas.getWidth()) {
                width = canvas.getWidth() - x;
            }
            else if (x < 0) {
                width = width + x;
            }
            if (x < 0) {
                x = 0;
            }
            if (y + height > canvas.getHeight()) {
                height = canvas.getHeight() - y;
            }
            else if (y < 0) {
                height = height + y;
            }
            if (y < 0) {
                y = 0;
            }
            width = Math.min(width, canvas.getWidth());
            height = Math.min(height, canvas.getHeight());
            var regionWidth = width;
            var regionHeight = height;
            var maxDimensions = canvas.getMaxDimensions();
            if (maxDimensions) {
                if (width > maxDimensions.width) {
                    var newWidth = maxDimensions.width;
                    height = Math.round(newWidth * (height / width));
                    width = newWidth;
                }
                if (height > maxDimensions.height) {
                    var newHeight = maxDimensions.height;
                    width = Math.round((width / height) * newHeight);
                    height = newHeight;
                }
            }
            dimensions.region = new manifesto.Size(regionWidth, regionHeight);
            dimensions.regionPos = new Point_1.Point(x, y);
            dimensions.size = new manifesto.Size(width, height);
            return dimensions;
        };
        // keep this around for reference
        // getOnScreenCroppedImageDimensions(canvas: Manifesto.ICanvas, viewer: any): CroppedImageDimensions {
        //     if (!viewer) return null;
        //     if (!viewer.viewport) return null;
        //     if (!canvas.getHeight() || !canvas.getWidth()){
        //         return null;
        //     }
        //     var bounds = viewer.viewport.getBounds(true);
        //     var containerSize = viewer.viewport.getContainerSize();
        //     var zoom = viewer.viewport.getZoom(true);
        //     var top = Math.max(0, bounds.y);
        //     var left = Math.max(0, bounds.x);
        //     // change top to be normalised value proportional to height of image, not width (as per OSD).
        //     top = 1 / (canvas.getHeight() / parseInt(String(canvas.getWidth() * top)));
        //     // get on-screen pixel sizes.
        //     var viewportWidthPx = containerSize.x;
        //     var viewportHeightPx = containerSize.y;
        //     var imageWidthPx = parseInt(String(viewportWidthPx * zoom));
        //     var ratio = canvas.getWidth() / imageWidthPx;
        //     var imageHeightPx = parseInt(String(canvas.getHeight() / ratio));
        //     var viewportLeftPx = parseInt(String(left * imageWidthPx));
        //     var viewportTopPx = parseInt(String(top * imageHeightPx));
        //     var rect1Left = 0;
        //     var rect1Right = imageWidthPx;
        //     var rect1Top = 0;
        //     var rect1Bottom = imageHeightPx;
        //     var rect2Left = viewportLeftPx;
        //     var rect2Right = viewportLeftPx + viewportWidthPx;
        //     var rect2Top = viewportTopPx;
        //     var rect2Bottom = viewportTopPx + viewportHeightPx;
        //     var sizeWidth = Math.max(0, Math.min(rect1Right, rect2Right) - Math.max(rect1Left, rect2Left));
        //     var sizeHeight = Math.max(0, Math.min(rect1Bottom, rect2Bottom) - Math.max(rect1Top, rect2Top));
        //     // get original image pixel sizes.
        //     var ratio2 = canvas.getWidth() / imageWidthPx;
        //     var regionWidth = parseInt(String(sizeWidth * ratio2));
        //     var regionHeight = parseInt(String(sizeHeight * ratio2));
        //     var regionTop = parseInt(String(canvas.getHeight() * top));
        //     var regionLeft = parseInt(String(canvas.getWidth() * left));
        //     if (regionTop < 0) regionTop = 0;
        //     if (regionLeft < 0) regionLeft = 0;
        //     var dimensions: CroppedImageDimensions = new CroppedImageDimensions();
        //     dimensions.region = new manifesto.Size(regionWidth, regionHeight);
        //     dimensions.regionPos = new Point(regionLeft, regionTop);
        //     dimensions.size = new manifesto.Size(sizeWidth, sizeHeight);
        //     return dimensions;
        // }
        Extension.prototype.getCroppedImageUri = function (canvas, viewer) {
            if (!viewer)
                return null;
            if (!viewer.viewport)
                return null;
            var dimensions = this.getCroppedImageDimensions(canvas, viewer);
            if (!dimensions) {
                return null;
            }
            // construct uri
            // {baseuri}/{id}/{region}/{size}/{rotation}/{quality}.jpg
            var baseUri = this.getImageBaseUri(canvas);
            var id = this.getImageId(canvas);
            if (!id) {
                return null;
            }
            var region = dimensions.regionPos.x + "," + dimensions.regionPos.y + "," + dimensions.region.width + "," + dimensions.region.height;
            var size = dimensions.size.width + ',' + dimensions.size.height;
            var rotation = this.getViewerRotation();
            var quality = 'default';
            return baseUri + "/" + id + "/" + region + "/" + size + "/" + rotation + "/" + quality + ".jpg";
        };
        Extension.prototype.getConfinedImageDimensions = function (canvas, width) {
            var dimensions = new manifesto.Size(0, 0);
            dimensions.width = width;
            var normWidth = Utils.Maths.normalise(width, 0, canvas.getWidth());
            dimensions.height = Math.floor(canvas.getHeight() * normWidth);
            return dimensions;
        };
        Extension.prototype.getConfinedImageUri = function (canvas, width) {
            var baseUri = this.getImageBaseUri(canvas);
            // {baseuri}/{id}/{region}/{size}/{rotation}/{quality}.jpg
            var id = this.getImageId(canvas);
            if (!id) {
                return null;
            }
            var region = 'full';
            var dimensions = this.getConfinedImageDimensions(canvas, width);
            var size = dimensions.width + ',' + dimensions.height;
            var rotation = this.getViewerRotation();
            var quality = 'default';
            return baseUri + "/" + id + "/" + region + "/" + size + "/" + rotation + "/" + quality + ".jpg";
        };
        Extension.prototype.getImageId = function (canvas) {
            if (canvas.externalResource) {
                var id = canvas.externalResource.data['@id'];
                if (id) {
                    return id.substr(id.lastIndexOf("/") + 1);
                }
            }
            return null;
        };
        Extension.prototype.getImageBaseUri = function (canvas) {
            var uri = this.getInfoUri(canvas);
            // First trim off info.json, then trim off ID....
            uri = uri.substr(0, uri.lastIndexOf("/"));
            return uri.substr(0, uri.lastIndexOf("/"));
        };
        Extension.prototype.getInfoUri = function (canvas) {
            var infoUri = null;
            var images = canvas.getImages();
            if (images && images.length) {
                var firstImage = images[0];
                var resource = firstImage.getResource();
                var services = resource.getServices();
                for (var i = 0; i < services.length; i++) {
                    var service = services[i];
                    var id = service.id;
                    if (!id.endsWith('/')) {
                        id += '/';
                    }
                    if (manifesto.Utils.isImageProfile(service.getProfile())) {
                        infoUri = id + 'info.json';
                    }
                }
            }
            if (!infoUri) {
                // todo: use compiler flag (when available)
                infoUri = 'lib/imageunavailable.json';
            }
            return infoUri;
        };
        Extension.prototype.getEmbedScript = function (template, width, height, zoom, rotation) {
            var config = this.data.config.uri || '';
            var locales = this.getSerializedLocales();
            var appUri = this.getAppUri();
            var iframeSrc = appUri + "#?manifest=" + this.helper.iiifResourceUri + "&c=" + this.helper.collectionIndex + "&m=" + this.helper.manifestIndex + "&s=" + this.helper.sequenceIndex + "&cv=" + this.helper.canvasIndex + "&config=" + config + "&locales=" + locales + "&xywh=" + zoom + "&r=" + rotation;
            var script = Utils.Strings.format(template, iframeSrc, width.toString(), height.toString());
            return script;
        };
        Extension.prototype.getPrevPageIndex = function (canvasIndex) {
            if (canvasIndex === void 0) { canvasIndex = this.helper.canvasIndex; }
            var index;
            if (this.isPagingSettingEnabled()) {
                var indices = this.getPagedIndices(canvasIndex);
                if (this.helper.isRightToLeft()) {
                    index = indices[indices.length - 1] - 1;
                }
                else {
                    index = indices[0] - 1;
                }
            }
            else {
                index = canvasIndex - 1;
            }
            return index;
        };
        Extension.prototype.isSearchEnabled = function () {
            if (!Utils.Bools.getBool(this.data.config.options.searchWithinEnabled, false)) {
                return false;
            }
            if (!this.helper.getSearchService()) {
                return false;
            }
            return true;
        };
        Extension.prototype.isPagingSettingEnabled = function () {
            if (this.helper.isPagingAvailable()) {
                return this.getSettings().pagingEnabled;
            }
            return false;
        };
        Extension.prototype.getNextPageIndex = function (canvasIndex) {
            if (canvasIndex === void 0) { canvasIndex = this.helper.canvasIndex; }
            var index;
            if (this.isPagingSettingEnabled()) {
                var indices = this.getPagedIndices(canvasIndex);
                if (this.helper.isRightToLeft()) {
                    index = indices[0] + 1;
                }
                else {
                    index = indices[indices.length - 1] + 1;
                }
            }
            else {
                index = canvasIndex + 1;
            }
            if (index > this.helper.getTotalCanvases() - 1) {
                return -1;
            }
            return index;
        };
        Extension.prototype.getAutoCompleteService = function () {
            var service = this.helper.getSearchService();
            if (!service)
                return null;
            return service.getService(manifesto.ServiceProfile.autoComplete());
        };
        Extension.prototype.getAutoCompleteUri = function () {
            var service = this.getAutoCompleteService();
            if (!service)
                return null;
            return service.id + '?q={0}';
        };
        Extension.prototype.getSearchServiceUri = function () {
            var service = this.helper.getSearchService();
            if (!service)
                return null;
            var uri = service.id;
            uri = uri + "?q={0}";
            return uri;
        };
        Extension.prototype.search = function (terms) {
            var _this = this;
            if (this.isAnnotating)
                return;
            this.isAnnotating = true;
            // clear search results
            this.annotations = [];
            var that = this;
            // searching
            var searchUri = this.getSearchServiceUri();
            if (!searchUri)
                return;
            searchUri = Utils.Strings.format(searchUri, encodeURIComponent(terms));
            this.getSearchResults(searchUri, terms, this.annotations, function (annotations) {
                that.isAnnotating = false;
                if (annotations.length) {
                    that.annotate(annotations, terms);
                }
                else {
                    that.showMessage(that.data.config.modules.genericDialogue.content.noMatches, function () {
                        _this.component.publish(BaseEvents_1.BaseEvents.ANNOTATIONS_EMPTY);
                    });
                }
            });
        };
        Extension.prototype.getSearchResults = function (searchUri, terms, searchResults, cb) {
            var _this = this;
            $.getJSON(searchUri, function (results) {
                if (results.resources && results.resources.length) {
                    searchResults = searchResults.concat(_this.parseAnnotationList(results));
                }
                if (results.next) {
                    _this.getSearchResults(results.next, terms, searchResults, cb);
                }
                else {
                    cb(searchResults);
                }
            });
        };
        Extension.prototype.parseAnnotationList = function (annotations) {
            var parsed = [];
            var _loop_1 = function (i) {
                var resource = annotations.resources[i];
                var canvasIndex = this_1.helper.getCanvasIndexById(resource.on.match(/(.*)#/)[1]);
                var annotationGroup = new AnnotationGroup(resource, canvasIndex);
                var match = parsed.en().where(function (x) { return x.canvasIndex === annotationGroup.canvasIndex; }).first();
                // if there's already an annotation for the canvas index, add a rect to it, otherwise create a new AnnotationGroup
                if (match) {
                    match.addRect(resource);
                }
                else {
                    parsed.push(annotationGroup);
                }
            };
            var this_1 = this;
            for (var i = 0; i < annotations.resources.length; i++) {
                _loop_1(i);
            }
            // sort by canvasIndex
            parsed.sort(function (a, b) {
                return a.canvasIndex - b.canvasIndex;
            });
            return parsed;
        };
        Extension.prototype.getAnnotationRects = function () {
            if (this.annotations) {
                return this.annotations.en().selectMany(function (x) { return x.rects; }).toArray();
            }
            return [];
        };
        Extension.prototype.getCurrentAnnotationRectIndex = function () {
            var annotationRects = this.getAnnotationRects();
            if (this.currentAnnotationRect) {
                return annotationRects.indexOf(this.currentAnnotationRect);
            }
            return -1;
        };
        Extension.prototype.getTotalAnnotationRects = function () {
            var annotationRects = this.getAnnotationRects();
            return annotationRects.length;
        };
        Extension.prototype.isFirstAnnotationRect = function () {
            return this.getCurrentAnnotationRectIndex() === 0;
        };
        Extension.prototype.getLastAnnotationRectIndex = function () {
            return this.getTotalAnnotationRects() - 1;
        };
        Extension.prototype.getPagedIndices = function (canvasIndex) {
            if (canvasIndex === void 0) { canvasIndex = this.helper.canvasIndex; }
            var indices = [];
            // if it's a continuous manifest, get all resources.
            if (this.helper.isContinuous()) {
                indices = $.map(this.helper.getCanvases(), function (c, index) {
                    return index;
                });
            }
            else {
                if (!this.isPagingSettingEnabled()) {
                    indices.push(this.helper.canvasIndex);
                }
                else {
                    if (this.helper.isFirstCanvas(canvasIndex) || (this.helper.isLastCanvas(canvasIndex) && this.helper.isTotalCanvasesEven())) {
                        indices = [canvasIndex];
                    }
                    else if (canvasIndex % 2) {
                        indices = [canvasIndex, canvasIndex + 1];
                    }
                    else {
                        indices = [canvasIndex - 1, canvasIndex];
                    }
                    if (this.helper.isRightToLeft()) {
                        indices = indices.reverse();
                    }
                }
            }
            return indices;
        };
        return Extension;
    }(BaseExtension_1.BaseExtension));
    exports.Extension = Extension;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-pdf-extension/DownloadDialogue',["require", "exports", "../../modules/uv-dialogues-module/DownloadDialogue"], function (require, exports, DownloadDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownloadDialogue = /** @class */ (function (_super) {
        __extends(DownloadDialogue, _super);
        function DownloadDialogue($element) {
            return _super.call(this, $element) || this;
        }
        DownloadDialogue.prototype.create = function () {
            this.setConfig('downloadDialogue');
            _super.prototype.create.call(this);
        };
        DownloadDialogue.prototype.open = function (triggerButton) {
            _super.prototype.open.call(this, triggerButton);
            this.addEntireFileDownloadOptions();
            if (!this.$downloadOptions.find('li:visible').length) {
                this.$noneAvailable.show();
            }
            else {
                // select first option.
                this.$noneAvailable.hide();
            }
            this.resize();
        };
        DownloadDialogue.prototype.isDownloadOptionAvailable = function (option) {
            return _super.prototype.isDownloadOptionAvailable.call(this, option);
        };
        return DownloadDialogue;
    }(DownloadDialogue_1.DownloadDialogue));
    exports.DownloadDialogue = DownloadDialogue;
});

define('extensions/uv-pdf-extension/Events',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Events = /** @class */ (function () {
        function Events() {
        }
        Events.namespace = 'pdfExtension.';
        Events.PDF_LOADED = Events.namespace + 'pdfLoaded';
        Events.PAGE_INDEX_CHANGED = Events.namespace + 'pageIndexChanged';
        Events.SEARCH = Events.namespace + 'search';
        return Events;
    }());
    exports.Events = Events;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-pdfcenterpanel-module/PDFCenterPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/CenterPanel", "../../extensions/uv-pdf-extension/Events"], function (require, exports, BaseEvents_1, CenterPanel_1, Events_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PDFCenterPanel = /** @class */ (function (_super) {
        __extends(PDFCenterPanel, _super);
        function PDFCenterPanel($element) {
            var _this = _super.call(this, $element) || this;
            _this._maxScale = 5;
            _this._minScale = 0.7;
            _this._nextButtonEnabled = false;
            _this._pageIndex = 1;
            _this._pageIndexPending = null;
            _this._pageRendering = false;
            _this._pdfDoc = null;
            _this._prevButtonEnabled = false;
            _this._scale = 0.7;
            return _this;
        }
        PDFCenterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('pdfCenterPanel');
            _super.prototype.create.call(this);
            this._$pdfContainer = $('<div class="pdfContainer"></div>');
            this._$canvas = $('<canvas></canvas>');
            this._$spinner = $('<div class="spinner"></div>');
            this._canvas = this._$canvas[0];
            this._ctx = this._canvas.getContext('2d');
            this.$content.append(this._$spinner);
            this._$prevButton = $('<div class="btn prev" tabindex="0"></div>');
            this.$content.append(this._$prevButton);
            this._$nextButton = $('<div class="btn next" tabindex="0"></div>');
            this.$content.append(this._$nextButton);
            this._$zoomInButton = $('<div class="btn zoomIn" tabindex="0"></div>');
            this.$content.append(this._$zoomInButton);
            this._$zoomOutButton = $('<div class="btn zoomOut" tabindex="0"></div>');
            this.$content.append(this._$zoomOutButton);
            this._$pdfContainer.append(this._$canvas);
            this.$content.prepend(this._$pdfContainer);
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, function (resources) {
                _this.openMedia(resources);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.FIRST, function () {
                if (!_this._pdfDoc) {
                    return;
                }
                _this._pageIndex = 1;
                _this._queueRenderPage(_this._pageIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.PREV, function () {
                if (!_this._pdfDoc) {
                    return;
                }
                if (_this._pageIndex <= 1) {
                    return;
                }
                _this._pageIndex--;
                _this._queueRenderPage(_this._pageIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.NEXT, function () {
                if (!_this._pdfDoc) {
                    return;
                }
                if (_this._pageIndex >= _this._pdfDoc.numPages) {
                    return;
                }
                _this._pageIndex++;
                _this._queueRenderPage(_this._pageIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LAST, function () {
                if (!_this._pdfDoc) {
                    return;
                }
                _this._pageIndex = _this._pdfDoc.numPages;
                _this._queueRenderPage(_this._pageIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function () {
                if (!_this._pdfDoc) {
                    return;
                }
                _this._pageIndex = 1;
                _this._queueRenderPage(_this._pageIndex);
            });
            this.component.subscribe(Events_1.Events.SEARCH, function (pageIndex) {
                if (!_this._pdfDoc) {
                    return;
                }
                if (pageIndex < 1 || pageIndex > _this._pdfDoc.numPages) {
                    return;
                }
                _this._pageIndex = pageIndex;
                _this._queueRenderPage(_this._pageIndex);
            });
            this._$prevButton.onPressed(function (e) {
                e.preventDefault();
                if (!_this._prevButtonEnabled)
                    return;
                _this.component.publish(BaseEvents_1.BaseEvents.PREV);
            });
            this.disablePrevButton();
            this._$nextButton.onPressed(function (e) {
                e.preventDefault();
                if (!_this._nextButtonEnabled)
                    return;
                _this.component.publish(BaseEvents_1.BaseEvents.NEXT);
            });
            this.disableNextButton();
            this._$zoomInButton.onPressed(function (e) {
                e.preventDefault();
                var newScale = _this._scale + 0.5;
                if (newScale < _this._maxScale) {
                    _this._scale = newScale;
                }
                else {
                    _this._scale = _this._maxScale;
                }
                _this._render(_this._pageIndex);
            });
            this._$zoomOutButton.onPressed(function (e) {
                e.preventDefault();
                var newScale = _this._scale - 0.5;
                if (newScale > _this._minScale) {
                    _this._scale = newScale;
                }
                else {
                    _this._scale = _this._minScale;
                }
                _this._render(_this._pageIndex);
            });
        };
        PDFCenterPanel.prototype.disablePrevButton = function () {
            this._prevButtonEnabled = false;
            this._$prevButton.addClass('disabled');
        };
        PDFCenterPanel.prototype.enablePrevButton = function () {
            this._prevButtonEnabled = true;
            this._$prevButton.removeClass('disabled');
        };
        PDFCenterPanel.prototype.hidePrevButton = function () {
            this.disablePrevButton();
            this._$prevButton.hide();
        };
        PDFCenterPanel.prototype.showPrevButton = function () {
            this.enablePrevButton();
            this._$prevButton.show();
        };
        PDFCenterPanel.prototype.disableNextButton = function () {
            this._nextButtonEnabled = false;
            this._$nextButton.addClass('disabled');
        };
        PDFCenterPanel.prototype.enableNextButton = function () {
            this._nextButtonEnabled = true;
            this._$nextButton.removeClass('disabled');
        };
        PDFCenterPanel.prototype.hideNextButton = function () {
            this.disableNextButton();
            this._$nextButton.hide();
        };
        PDFCenterPanel.prototype.showNextButton = function () {
            this.enableNextButton();
            this._$nextButton.show();
        };
        PDFCenterPanel.prototype.openMedia = function (resources) {
            var _this = this;
            this._$spinner.show();
            this.extension.getExternalResources(resources).then(function () {
                var mediaUri = null;
                var canvas = _this.extension.helper.getCurrentCanvas();
                var formats = _this.extension.getMediaFormats(canvas);
                var pdfUri = canvas.id;
                if (formats && formats.length) {
                    mediaUri = formats[0].id;
                }
                else {
                    mediaUri = canvas.id;
                }
                if (!Utils.Bools.getBool(_this.extension.data.config.options.usePdfJs, false)) {
                    window.PDFObject.embed(pdfUri, '#content', { id: "PDF" });
                }
                else {
                    PDFJS.disableWorker = true;
                    PDFJS.getDocument(mediaUri).then(function (pdfDoc) {
                        _this._pdfDoc = pdfDoc;
                        _this._render(_this._pageIndex);
                        _this.component.publish(Events_1.Events.PDF_LOADED, pdfDoc);
                        _this._$spinner.hide();
                    });
                }
            });
        };
        PDFCenterPanel.prototype._render = function (num) {
            var _this = this;
            if (!Utils.Bools.getBool(this.extension.data.config.options.usePdfJs, false)) {
                return;
            }
            this._pageRendering = true;
            this._$zoomOutButton.enable();
            this._$zoomInButton.enable();
            //disable zoom if not possible
            var lowScale = this._scale - 0.5;
            var highScale = this._scale + 0.5;
            if (lowScale < this._minScale) {
                this._$zoomOutButton.disable();
            }
            if (highScale > this._maxScale) {
                this._$zoomInButton.disable();
            }
            //this._pdfDoc.getPage(num).then((page: any) => {
            this._pdfDoc.getPage(num).then(function (page) {
                if (_this._renderTask) {
                    _this._renderTask.cancel();
                }
                // how to fit to the available space
                // const height: number = this.$content.height();
                // this._canvas.height = height;
                // this._viewport = page.getViewport(this._canvas.height / page.getViewport(1.0).height);
                // const width: number = this._viewport.width;
                // this._canvas.width = width;
                // this._$canvas.css({
                //     left: (this.$content.width() / 2) - (width / 2)
                // });
                // scale viewport
                _this._viewport = page.getViewport(_this._scale);
                _this._canvas.height = _this._viewport.height;
                _this._canvas.width = _this._viewport.width;
                // Render PDF page into canvas context
                var renderContext = {
                    canvasContext: _this._ctx,
                    viewport: _this._viewport
                };
                _this._renderTask = page.render(renderContext);
                // Wait for rendering to finish
                _this._renderTask.promise.then(function () {
                    _this.component.publish(Events_1.Events.PAGE_INDEX_CHANGED, _this._pageIndex);
                    _this._pageRendering = false;
                    if (_this._pageIndexPending !== null) {
                        // New page rendering is pending
                        _this._render(_this._pageIndexPending);
                        _this._pageIndexPending = null;
                    }
                    if (_this._pageIndex === 1) {
                        _this.disablePrevButton();
                    }
                    else {
                        _this.enablePrevButton();
                    }
                    if (_this._pageIndex === _this._pdfDoc.numPages) {
                        _this.disableNextButton();
                    }
                    else {
                        _this.enableNextButton();
                    }
                }).catch(function (err) {
                    //console.log(err);
                });
            });
        };
        PDFCenterPanel.prototype._queueRenderPage = function (num) {
            if (this._pageRendering) {
                this._pageIndexPending = num;
            }
            else {
                this._render(num);
            }
        };
        PDFCenterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            this._$pdfContainer.width(this.$content.width());
            this._$pdfContainer.height(this.$content.height());
            this._$spinner.css('top', (this.$content.height() / 2) - (this._$spinner.height() / 2));
            this._$spinner.css('left', (this.$content.width() / 2) - (this._$spinner.width() / 2));
            this._$prevButton.css({
                top: (this.$content.height() - this._$prevButton.height()) / 2,
                left: this._$prevButton.horizontalMargins()
            });
            this._$nextButton.css({
                top: (this.$content.height() - this._$nextButton.height()) / 2,
                left: this.$content.width() - (this._$nextButton.width() + this._$nextButton.horizontalMargins())
            });
            if (!this._viewport) {
                return;
            }
            this._render(this._pageIndex);
        };
        return PDFCenterPanel;
    }(CenterPanel_1.CenterPanel));
    exports.PDFCenterPanel = PDFCenterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-pdfheaderpanel-module/PDFHeaderPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../../extensions/uv-pdf-extension/Events", "../uv-shared-module/HeaderPanel"], function (require, exports, BaseEvents_1, Events_1, HeaderPanel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PDFHeaderPanel = /** @class */ (function (_super) {
        __extends(PDFHeaderPanel, _super);
        function PDFHeaderPanel($element) {
            var _this = _super.call(this, $element) || this;
            _this.firstButtonEnabled = false;
            _this.lastButtonEnabled = false;
            _this.nextButtonEnabled = false;
            _this.prevButtonEnabled = false;
            _this._pageIndex = 0;
            _this._pdfDoc = null;
            return _this;
        }
        PDFHeaderPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('pdfHeaderPanel');
            _super.prototype.create.call(this);
            this.component.subscribe(Events_1.Events.PAGE_INDEX_CHANGED, function (pageIndex) {
                _this._pageIndex = pageIndex;
                _this.render();
            });
            this.component.subscribe(Events_1.Events.PDF_LOADED, function (pdfDoc) {
                _this._pdfDoc = pdfDoc;
            });
            this.$prevOptions = $('<div class="prevOptions"></div>');
            this.$centerOptions.append(this.$prevOptions);
            this.$firstButton = $("\n          <button class=\"btn imageBtn first\" tabindex=\"0\" title=\"" + this.content.first + "\">\n            <i class=\"uv-icon-first\" aria-hidden=\"true\"></i>" + this.content.first + "\n          </button>\n        ");
            this.$prevOptions.append(this.$firstButton);
            this.$firstButton.disable();
            this.$prevButton = $("\n          <button class=\"btn imageBtn prev\" tabindex=\"0\" title=\"" + this.content.previous + "\">\n            <i class=\"uv-icon-prev\" aria-hidden=\"true\"></i>" + this.content.previous + "\n          </button>\n        ");
            this.$prevOptions.append(this.$prevButton);
            this.$prevButton.disable();
            this.$search = $('<div class="search"></div>');
            this.$centerOptions.append(this.$search);
            this.$searchText = $('<input class="searchText" maxlength="50" type="text" tabindex="0" aria-label="' + this.content.pageSearchLabel + '"/>');
            this.$search.append(this.$searchText);
            this.$total = $('<span class="total"></span>');
            this.$search.append(this.$total);
            this.$searchButton = $('<a class="go btn btn-primary" tabindex="0">' + this.content.go + '</a>');
            this.$search.append(this.$searchButton);
            this.$searchButton.disable();
            this.$nextOptions = $('<div class="nextOptions"></div>');
            this.$centerOptions.append(this.$nextOptions);
            this.$nextButton = $("\n          <button class=\"btn imageBtn next\" tabindex=\"0\" title=\"" + this.content.next + "\">\n            <i class=\"uv-icon-next\" aria-hidden=\"true\"></i>" + this.content.next + "\n          </button>\n        ");
            this.$nextOptions.append(this.$nextButton);
            this.$nextButton.disable();
            this.$lastButton = $("\n          <button class=\"btn imageBtn last\" tabindex=\"0\" title=\"" + this.content.last + "\">\n            <i class=\"uv-icon-last\" aria-hidden=\"true\"></i>" + this.content.last + "\n          </button>\n        ");
            this.$nextOptions.append(this.$lastButton);
            this.$lastButton.disable();
            // ui event handlers.
            this.$firstButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.FIRST);
            });
            this.$prevButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.PREV);
            });
            this.$nextButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.NEXT);
            });
            this.$lastButton.onPressed(function () {
                _this.component.publish(BaseEvents_1.BaseEvents.LAST);
            });
            this.$searchText.onEnter(function () {
                _this.$searchText.blur();
                _this.search(_this.$searchText.val());
            });
            this.$searchText.click(function () {
                $(this).select();
            });
            this.$searchButton.onPressed(function () {
                _this.search(_this.$searchText.val());
            });
        };
        PDFHeaderPanel.prototype.render = function () {
            // check if the book has more than one page, otherwise hide prev/next options.
            if (this._pdfDoc.numPages === 1) {
                this.$centerOptions.hide();
            }
            else {
                this.$centerOptions.show();
            }
            this.$searchText.val(this._pageIndex);
            var of = this.content.of;
            this.$total.html(Utils.Strings.format(of, this._pdfDoc.numPages.toString()));
            this.$searchButton.enable();
            if (this._pageIndex === 1) {
                this.$firstButton.disable();
                this.$prevButton.disable();
            }
            else {
                this.$firstButton.enable();
                this.$prevButton.enable();
            }
            if (this._pageIndex === this._pdfDoc.numPages) {
                this.$lastButton.disable();
                this.$nextButton.disable();
            }
            else {
                this.$lastButton.enable();
                this.$nextButton.enable();
            }
        };
        PDFHeaderPanel.prototype.search = function (value) {
            if (!value) {
                this.extension.showMessage(this.content.emptyValue);
                return;
            }
            var index = parseInt(this.$searchText.val(), 10);
            if (isNaN(index)) {
                this.extension.showMessage(this.extension.data.config.modules.genericDialogue.content.invalidNumber);
                return;
            }
            this.component.publish(Events_1.Events.SEARCH, index);
        };
        PDFHeaderPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return PDFHeaderPanel;
    }(HeaderPanel_1.HeaderPanel));
    exports.PDFHeaderPanel = PDFHeaderPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-pdf-extension/SettingsDialogue',["require", "exports", "../../modules/uv-dialogues-module/SettingsDialogue"], function (require, exports, SettingsDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsDialogue = /** @class */ (function (_super) {
        __extends(SettingsDialogue, _super);
        function SettingsDialogue($element) {
            return _super.call(this, $element) || this;
        }
        SettingsDialogue.prototype.create = function () {
            this.setConfig('settingsDialogue');
            _super.prototype.create.call(this);
        };
        return SettingsDialogue;
    }(SettingsDialogue_1.SettingsDialogue));
    exports.SettingsDialogue = SettingsDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-pdf-extension/ShareDialogue',["require", "exports", "../../modules/uv-dialogues-module/ShareDialogue"], function (require, exports, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShareDialogue = /** @class */ (function (_super) {
        __extends(ShareDialogue, _super);
        function ShareDialogue($element) {
            return _super.call(this, $element) || this;
        }
        ShareDialogue.prototype.create = function () {
            this.setConfig('shareDialogue');
            _super.prototype.create.call(this);
        };
        ShareDialogue.prototype.update = function () {
            _super.prototype.update.call(this);
            this.code = this.extension.getEmbedScript(this.options.embedTemplate, this.currentWidth, this.currentHeight);
            this.$code.val(this.code);
        };
        ShareDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ShareDialogue;
    }(ShareDialogue_1.ShareDialogue));
    exports.ShareDialogue = ShareDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-pdf-extension/Extension',["require", "exports", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-shared-module/BaseExtension", "../../modules/uv-shared-module/Bookmark", "./DownloadDialogue", "../../modules/uv-shared-module/FooterPanel", "../../modules/uv-moreinforightpanel-module/MoreInfoRightPanel", "../../modules/uv-pdfcenterpanel-module/PDFCenterPanel", "../../modules/uv-pdfheaderpanel-module/PDFHeaderPanel", "../../modules/uv-resourcesleftpanel-module/ResourcesLeftPanel", "./SettingsDialogue", "./ShareDialogue"], function (require, exports, BaseEvents_1, BaseExtension_1, Bookmark_1, DownloadDialogue_1, FooterPanel_1, MoreInfoRightPanel_1, PDFCenterPanel_1, PDFHeaderPanel_1, ResourcesLeftPanel_1, SettingsDialogue_1, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Extension = /** @class */ (function (_super) {
        __extends(Extension, _super);
        function Extension() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Extension.prototype.create = function () {
            var _this = this;
            requirejs.config({ paths: { 'pdfjs-dist/build/pdf.combined': this.data.root + '/lib/' + 'pdf.combined' } });
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.viewCanvas(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.THUMB_SELECTED, function (thumb) {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, thumb.index);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_EXPAND_FULL_START, function () {
                _this.shell.$centerPanel.hide();
                _this.shell.$rightPanel.hide();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.LEFTPANEL_COLLAPSE_FULL_FINISH, function () {
                _this.shell.$centerPanel.show();
                _this.shell.$rightPanel.show();
                _this.resize();
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.SHOW_OVERLAY, function () {
                if (_this.IsOldIE()) {
                    _this.centerPanel.$element.hide();
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.HIDE_OVERLAY, function () {
                if (_this.IsOldIE()) {
                    _this.centerPanel.$element.show();
                }
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.EXIT_FULLSCREEN, function () {
                setTimeout(function () {
                    _this.resize();
                }, 10); // allow time to exit full screen, then resize
            });
        };
        Extension.prototype.render = function () {
            _super.prototype.render.call(this);
        };
        Extension.prototype.IsOldIE = function () {
            var browser = window.browserDetect.browser;
            var version = window.browserDetect.version;
            if (browser === 'Explorer' && version <= 9)
                return true;
            return false;
        };
        Extension.prototype.isHeaderPanelEnabled = function () {
            return _super.prototype.isHeaderPanelEnabled.call(this) && Utils.Bools.getBool(this.data.config.options.usePdfJs, true);
        };
        Extension.prototype.createModules = function () {
            _super.prototype.createModules.call(this);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel = new PDFHeaderPanel_1.PDFHeaderPanel(this.shell.$headerPanel);
            }
            else {
                this.shell.$headerPanel.hide();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel = new ResourcesLeftPanel_1.ResourcesLeftPanel(this.shell.$leftPanel);
            }
            this.centerPanel = new PDFCenterPanel_1.PDFCenterPanel(this.shell.$centerPanel);
            if (this.isRightPanelEnabled()) {
                this.rightPanel = new MoreInfoRightPanel_1.MoreInfoRightPanel(this.shell.$rightPanel);
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel = new FooterPanel_1.FooterPanel(this.shell.$footerPanel);
            }
            else {
                this.shell.$footerPanel.hide();
            }
            this.$downloadDialogue = $('<div class="overlay download" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$downloadDialogue);
            this.downloadDialogue = new DownloadDialogue_1.DownloadDialogue(this.$downloadDialogue);
            this.$shareDialogue = $('<div class="overlay share" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$shareDialogue);
            this.shareDialogue = new ShareDialogue_1.ShareDialogue(this.$shareDialogue);
            this.$settingsDialogue = $('<div class="overlay settings" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$settingsDialogue);
            this.settingsDialogue = new SettingsDialogue_1.SettingsDialogue(this.$settingsDialogue);
            if (this.isLeftPanelEnabled()) {
                this.leftPanel.init();
            }
            if (this.isRightPanelEnabled()) {
                this.rightPanel.init();
            }
        };
        Extension.prototype.bookmark = function () {
            _super.prototype.bookmark.call(this);
            var canvas = this.helper.getCurrentCanvas();
            var bookmark = new Bookmark_1.Bookmark();
            bookmark.index = this.helper.canvasIndex;
            bookmark.label = Manifesto.LanguageMap.getValue(canvas.getLabel());
            bookmark.thumb = canvas.getProperty('thumbnail');
            bookmark.title = this.helper.getLabel();
            bookmark.trackingLabel = window.trackingLabel;
            bookmark.type = manifesto.ResourceType.document().toString();
            this.fire(BaseEvents_1.BaseEvents.BOOKMARK, bookmark);
        };
        Extension.prototype.dependencyLoaded = function (index, dep) {
            if (index === 0) {
                window.PDFObject = dep;
            }
        };
        Extension.prototype.getEmbedScript = function (template, width, height) {
            //const configUri = this.data.config.uri || '';
            //const script = String.format(template, this.getSerializedLocales(), configUri, this.helper.iiifResourceUri, this.helper.collectionIndex, this.helper.manifestIndex, this.helper.sequenceIndex, this.helper.canvasIndex, width, height, this.data.embedScriptUri);
            var appUri = this.getAppUri();
            var iframeSrc = appUri + "#?manifest=" + this.helper.iiifResourceUri + "&c=" + this.helper.collectionIndex + "&m=" + this.helper.manifestIndex + "&s=" + this.helper.sequenceIndex + "&cv=" + this.helper.canvasIndex;
            var script = Utils.Strings.format(template, iframeSrc, width.toString(), height.toString());
            return script;
        };
        return Extension;
    }(BaseExtension_1.BaseExtension));
    exports.Extension = Extension;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-virtex-extension/DownloadDialogue',["require", "exports", "../../modules/uv-dialogues-module/DownloadDialogue"], function (require, exports, DownloadDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownloadDialogue = /** @class */ (function (_super) {
        __extends(DownloadDialogue, _super);
        function DownloadDialogue($element) {
            return _super.call(this, $element) || this;
        }
        DownloadDialogue.prototype.create = function () {
            this.setConfig('downloadDialogue');
            _super.prototype.create.call(this);
        };
        DownloadDialogue.prototype.open = function (triggerButton) {
            _super.prototype.open.call(this, triggerButton);
            this.addEntireFileDownloadOptions();
            this.updateNoneAvailable();
            this.resize();
        };
        DownloadDialogue.prototype.isDownloadOptionAvailable = function (option) {
            return _super.prototype.isDownloadOptionAvailable.call(this, option);
        };
        return DownloadDialogue;
    }(DownloadDialogue_1.DownloadDialogue));
    exports.DownloadDialogue = DownloadDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-virtex-extension/SettingsDialogue',["require", "exports", "../../modules/uv-dialogues-module/SettingsDialogue"], function (require, exports, SettingsDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsDialogue = /** @class */ (function (_super) {
        __extends(SettingsDialogue, _super);
        function SettingsDialogue($element) {
            return _super.call(this, $element) || this;
        }
        SettingsDialogue.prototype.create = function () {
            this.setConfig('settingsDialogue');
            _super.prototype.create.call(this);
        };
        return SettingsDialogue;
    }(SettingsDialogue_1.SettingsDialogue));
    exports.SettingsDialogue = SettingsDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-virtex-extension/ShareDialogue',["require", "exports", "../../modules/uv-dialogues-module/ShareDialogue"], function (require, exports, ShareDialogue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShareDialogue = /** @class */ (function (_super) {
        __extends(ShareDialogue, _super);
        function ShareDialogue($element) {
            return _super.call(this, $element) || this;
        }
        ShareDialogue.prototype.create = function () {
            this.setConfig('shareDialogue');
            _super.prototype.create.call(this);
        };
        ShareDialogue.prototype.update = function () {
            _super.prototype.update.call(this);
            this.code = this.extension.getEmbedScript(this.options.embedTemplate, this.currentWidth, this.currentHeight);
            this.$code.val(this.code);
        };
        ShareDialogue.prototype.resize = function () {
            _super.prototype.resize.call(this);
        };
        return ShareDialogue;
    }(ShareDialogue_1.ShareDialogue));
    exports.ShareDialogue = ShareDialogue;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('modules/uv-virtexcenterpanel-module/VirtexCenterPanel',["require", "exports", "../uv-shared-module/BaseEvents", "../uv-shared-module/CenterPanel", "../../Utils"], function (require, exports, BaseEvents_1, CenterPanel_1, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VirtexCenterPanel = /** @class */ (function (_super) {
        __extends(VirtexCenterPanel, _super);
        function VirtexCenterPanel($element) {
            return _super.call(this, $element) || this;
        }
        VirtexCenterPanel.prototype.create = function () {
            var _this = this;
            this.setConfig('virtexCenterPanel');
            _super.prototype.create.call(this);
            var that = this;
            this.component.subscribe(BaseEvents_1.BaseEvents.OPEN_EXTERNAL_RESOURCE, function (resources) {
                that.openMedia(resources);
            });
            this.$navigation = $('<div class="navigation"></div>');
            this.$content.prepend(this.$navigation);
            this.$zoomInButton = $("\n          <button class=\"btn imageBtn zoomIn\" title=\"" + this.content.zoomIn + "\">\n            <i class=\"uv-icon-zoom-in\" aria-hidden=\"true\"></i>" + this.content.zoomIn + "\n          </button>\n        ");
            this.$navigation.append(this.$zoomInButton);
            this.$zoomOutButton = $("\n          <button class=\"btn imageBtn zoomOut\" title=\"" + this.content.zoomOut + "\">\n            <i class=\"uv-icon-zoom-out\" aria-hidden=\"true\"></i>" + this.content.zoomOut + "\n          </button>\n        ");
            this.$navigation.append(this.$zoomOutButton);
            this.$vrButton = $("\n          <button class=\"btn imageBtn vr\" title=\"" + this.content.vr + "\">\n            <i class=\"uv-icon-vr\" aria-hidden=\"true\"></i>" + this.content.vr + "\n          </button>\n        ");
            this.$navigation.append(this.$vrButton);
            this.$viewport = $('<div class="virtex"></div>');
            this.$content.prepend(this.$viewport);
            this.title = this.extension.helper.getLabel();
            this.$zoomInButton.on('click', function (e) {
                e.preventDefault();
                if (_this.viewport) {
                    _this.viewport.zoomIn();
                }
            });
            this.$zoomOutButton.on('click', function (e) {
                e.preventDefault();
                if (_this.viewport) {
                    _this.viewport.zoomOut();
                }
            });
            this.$vrButton.on('click', function (e) {
                e.preventDefault();
                if (_this.viewport) {
                    _this.viewport.toggleVR();
                }
            });
            if (!this._isVREnabled()) {
                this.$vrButton.hide();
            }
        };
        VirtexCenterPanel.prototype.openMedia = function (resources) {
            var _this = this;
            this.extension.getExternalResources(resources).then(function () {
                _this.$viewport.empty();
                var mediaUri = null;
                var canvas = _this.extension.helper.getCurrentCanvas();
                var formats = _this.extension.getMediaFormats(canvas);
                var resourceType = null;
                // default to threejs format.
                var fileType = new Virtex.FileType("application/vnd.threejs+json");
                if (formats && formats.length) {
                    mediaUri = formats[0].id;
                    resourceType = formats[0].getFormat();
                }
                else {
                    mediaUri = canvas.id;
                }
                if (resourceType) {
                    fileType = new Virtex.FileType(resourceType.toString());
                }
                var isAndroid = navigator.userAgent.toLowerCase().indexOf("android") > -1;
                _this.viewport = new Virtex.Viewport({
                    target: _this.$viewport[0],
                    data: {
                        antialias: !isAndroid,
                        file: mediaUri,
                        fullscreenEnabled: false,
                        type: fileType,
                        showStats: _this.options.showStats
                    }
                });
                if (_this.viewport) {
                    _this.viewport.on('vravailable', function () {
                        _this.$vrButton.show();
                    }, false);
                    _this.viewport.on('vrunavailable', function () {
                        _this.$vrButton.hide();
                    }, false);
                }
                _this.resize();
            });
        };
        VirtexCenterPanel.prototype._isVREnabled = function () {
            return (Utils.Bools.getBool(this.config.options.vrEnabled, false) && WEBVR.isAvailable());
        };
        VirtexCenterPanel.prototype.resize = function () {
            _super.prototype.resize.call(this);
            if (this.title) {
                this.$title.text(Utils_1.UVUtils.sanitize(this.title));
            }
            this.$viewport.width(this.$content.width());
            this.$viewport.height(this.$content.height());
            if (this.viewport) {
                this.viewport.resize();
            }
        };
        return VirtexCenterPanel;
    }(CenterPanel_1.CenterPanel));
    exports.VirtexCenterPanel = VirtexCenterPanel;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('extensions/uv-virtex-extension/Extension',["require", "exports", "../../modules/uv-shared-module/BaseEvents", "../../modules/uv-shared-module/BaseExtension", "../../modules/uv-shared-module/Bookmark", "../../modules/uv-contentleftpanel-module/ContentLeftPanel", "./DownloadDialogue", "../../modules/uv-shared-module/FooterPanel", "../../modules/uv-shared-module/HeaderPanel", "../../modules/uv-moreinforightpanel-module/MoreInfoRightPanel", "./SettingsDialogue", "./ShareDialogue", "../../modules/uv-virtexcenterpanel-module/VirtexCenterPanel"], function (require, exports, BaseEvents_1, BaseExtension_1, Bookmark_1, ContentLeftPanel_1, DownloadDialogue_1, FooterPanel_1, HeaderPanel_1, MoreInfoRightPanel_1, SettingsDialogue_1, ShareDialogue_1, VirtexCenterPanel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Extension = /** @class */ (function (_super) {
        __extends(Extension, _super);
        function Extension() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Extension.prototype.create = function () {
            var _this = this;
            _super.prototype.create.call(this);
            this.component.subscribe(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, function (canvasIndex) {
                _this.viewCanvas(canvasIndex);
            });
            this.component.subscribe(BaseEvents_1.BaseEvents.THUMB_SELECTED, function (canvasIndex) {
                _this.component.publish(BaseEvents_1.BaseEvents.CANVAS_INDEX_CHANGED, canvasIndex);
            });
        };
        Extension.prototype.createModules = function () {
            _super.prototype.createModules.call(this);
            if (this.isHeaderPanelEnabled()) {
                this.headerPanel = new HeaderPanel_1.HeaderPanel(this.shell.$headerPanel);
            }
            else {
                this.shell.$headerPanel.hide();
            }
            if (this.isLeftPanelEnabled()) {
                this.leftPanel = new ContentLeftPanel_1.ContentLeftPanel(this.shell.$leftPanel);
            }
            this.centerPanel = new VirtexCenterPanel_1.VirtexCenterPanel(this.shell.$centerPanel);
            if (this.isRightPanelEnabled()) {
                this.rightPanel = new MoreInfoRightPanel_1.MoreInfoRightPanel(this.shell.$rightPanel);
            }
            if (this.isFooterPanelEnabled()) {
                this.footerPanel = new FooterPanel_1.FooterPanel(this.shell.$footerPanel);
            }
            else {
                this.shell.$footerPanel.hide();
            }
            this.$downloadDialogue = $('<div class="overlay download" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$downloadDialogue);
            this.downloadDialogue = new DownloadDialogue_1.DownloadDialogue(this.$downloadDialogue);
            this.$shareDialogue = $('<div class="overlay share" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$shareDialogue);
            this.shareDialogue = new ShareDialogue_1.ShareDialogue(this.$shareDialogue);
            this.$settingsDialogue = $('<div class="overlay settings" aria-hidden="true"></div>');
            this.shell.$overlays.append(this.$settingsDialogue);
            this.settingsDialogue = new SettingsDialogue_1.SettingsDialogue(this.$settingsDialogue);
            if (this.isLeftPanelEnabled()) {
                this.leftPanel.init();
            }
            else {
                this.shell.$leftPanel.hide();
            }
            if (this.isRightPanelEnabled()) {
                this.rightPanel.init();
            }
            else {
                this.shell.$rightPanel.hide();
            }
        };
        Extension.prototype.render = function () {
            _super.prototype.render.call(this);
        };
        Extension.prototype.dependencyLoaded = function (index, dep) {
            if (index === 0) {
                window.THREE = dep; //https://github.com/mrdoob/three.js/issues/9602
            }
        };
        Extension.prototype.isLeftPanelEnabled = function () {
            return Utils.Bools.getBool(this.data.config.options.leftPanelEnabled, true)
                && (this.helper.isMultiCanvas() || this.helper.isMultiSequence());
        };
        Extension.prototype.bookmark = function () {
            _super.prototype.bookmark.call(this);
            var canvas = this.helper.getCurrentCanvas();
            var bookmark = new Bookmark_1.Bookmark();
            bookmark.index = this.helper.canvasIndex;
            bookmark.label = Manifesto.LanguageMap.getValue(canvas.getLabel());
            bookmark.thumb = canvas.getProperty('thumbnail');
            bookmark.title = this.helper.getLabel();
            bookmark.trackingLabel = window.trackingLabel;
            bookmark.type = manifesto.ResourceType.physicalobject().toString();
            this.fire(BaseEvents_1.BaseEvents.BOOKMARK, bookmark);
        };
        Extension.prototype.getEmbedScript = function (template, width, height) {
            //const configUri: string = this.data.config.uri || '';
            //const script: string = String.format(template, this.getSerializedLocales(), configUri, this.helper.iiifResourceUri, this.helper.collectionIndex, this.helper.manifestIndex, this.helper.sequenceIndex, this.helper.canvasIndex, width, height, this.data.embedScriptUri);
            var appUri = this.getAppUri();
            var iframeSrc = appUri + "#?manifest=" + this.helper.iiifResourceUri + "&c=" + this.helper.collectionIndex + "&m=" + this.helper.manifestIndex + "&s=" + this.helper.sequenceIndex + "&cv=" + this.helper.canvasIndex;
            var script = Utils.Strings.format(template, iframeSrc, width.toString(), height.toString());
            return script;
        };
        return Extension;
    }(BaseExtension_1.BaseExtension));
    exports.Extension = Extension;
});

define('PubSub',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PubSub = /** @class */ (function () {
        function PubSub() {
            this.events = {};
        }
        PubSub.prototype.publish = function (name, args) {
            var _this = this;
            var handlers = this.events[name];
            if (handlers === undefined)
                return;
            handlers.forEach(function (handler) {
                handler.call(_this, args);
            });
        };
        PubSub.prototype.subscribe = function (name, handler) {
            var handlers = this.events[name];
            if (handlers === undefined) {
                handlers = this.events[name] = [];
            }
            handlers.push(handler);
        };
        PubSub.prototype.unsubscribe = function (name, handler) {
            var handlers = this.events[name];
            if (handlers === undefined)
                return;
            var handlerIdx = handlers.indexOf(handler);
            handlers.splice(handlerIdx);
        };
        PubSub.prototype.dispose = function () {
            this.events = {};
        };
        return PubSub;
    }());
    exports.PubSub = PubSub;
});

if (!Element.prototype.scrollIntoViewIfNeeded) {
    Element.prototype.scrollIntoViewIfNeeded = function (centerIfNeeded) {
        centerIfNeeded = arguments.length === 0 ? true : !!centerIfNeeded;
        var parent = this.parentNode, parentComputedStyle = window.getComputedStyle(parent, undefined), parentBorderTopWidth = parseInt(parentComputedStyle.getPropertyValue("border-top-width")), parentBorderLeftWidth = parseInt(parentComputedStyle.getPropertyValue("border-left-width")), overTop = this.offsetTop - parent.offsetTop < parent.scrollTop, overBottom = this.offsetTop -
            parent.offsetTop +
            this.clientHeight -
            parentBorderTopWidth >
            parent.scrollTop + parent.clientHeight, overLeft = this.offsetLeft - parent.offsetLeft < parent.scrollLeft, overRight = this.offsetLeft -
            parent.offsetLeft +
            this.clientWidth -
            parentBorderLeftWidth >
            parent.scrollLeft + parent.clientWidth, alignWithTop = overTop && !overBottom;
        if ((overTop || overBottom) && centerIfNeeded) {
            parent.scrollTop =
                this.offsetTop -
                    parent.offsetTop -
                    parent.clientHeight / 2 -
                    parentBorderTopWidth +
                    this.clientHeight / 2;
        }
        if ((overLeft || overRight) && centerIfNeeded) {
            parent.scrollLeft =
                this.offsetLeft -
                    parent.offsetLeft -
                    parent.clientWidth / 2 -
                    parentBorderLeftWidth +
                    this.clientWidth / 2;
        }
        if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {
            this.scrollIntoView(alignWithTop);
        }
    };
}

define("Polyfills", function(){});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('UVComponent',["require", "exports", "./modules/uv-shared-module/BaseEvents", "./extensions/uv-av-extension/Extension", "./extensions/uv-default-extension/Extension", "./extensions/uv-mediaelement-extension/Extension", "./extensions/uv-seadragon-extension/Extension", "./extensions/uv-pdf-extension/Extension", "./extensions/uv-virtex-extension/Extension", "./Utils", "./PubSub", "./Polyfills"], function (require, exports, BaseEvents_1, Extension_1, Extension_2, Extension_3, Extension_4, Extension_5, Extension_6, Utils_1, PubSub_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UVComponent = /** @class */ (function (_super) {
        __extends(UVComponent, _super);
        function UVComponent(options) {
            var _this = _super.call(this, options) || this;
            _this.isFullScreen = false;
            _this._pubsub = new PubSub_1.PubSub();
            _this._init();
            _this._resize();
            return _this;
        }
        UVComponent.prototype._init = function () {
            var success = _super.prototype._init.call(this);
            if (!success) {
                console.error("UV failed to initialise");
            }
            this._extensions = {};
            this._extensions[manifesto.ResourceType.canvas().toString()] = {
                type: Extension_4.Extension,
                name: 'uv-seadragon-extension'
            };
            this._extensions[manifesto.ResourceType.image().toString()] = {
                type: Extension_4.Extension,
                name: 'uv-seadragon-extension'
            };
            this._extensions[manifesto.ResourceType.movingimage().toString()] = {
                type: Extension_3.Extension,
                name: 'uv-mediaelement-extension'
            };
            this._extensions[manifesto.ResourceType.physicalobject().toString()] = {
                type: Extension_6.Extension,
                name: 'uv-virtex-extension'
            };
            this._extensions[manifesto.ResourceType.sound().toString()] = {
                type: Extension_3.Extension,
                name: 'uv-mediaelement-extension'
            };
            this._extensions[manifesto.RenderingFormat.pdf().toString()] = {
                type: Extension_5.Extension,
                name: 'uv-pdf-extension'
            };
            // presentation 3
            this._extensions[manifesto.MediaType.jpg().toString()] = {
                type: Extension_4.Extension,
                name: 'uv-seadragon-extension'
            };
            this._extensions[manifesto.MediaType.pdf().toString()] = {
                type: Extension_5.Extension,
                name: 'uv-pdf-extension'
            };
            this._extensions[manifesto.MediaType.mp4().toString()] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions[manifesto.MediaType.webm().toString()] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions[manifesto.MediaType.threejs().toString()] = {
                type: Extension_6.Extension,
                name: 'uv-virtex-extension'
            };
            this._extensions['av'] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions['video'] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions['audio/mp3'] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions['audio/mp4'] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions['application/vnd.apple.mpegurl'] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions['application/dash+xml'] = {
                type: Extension_1.Extension,
                name: 'uv-av-extension'
            };
            this._extensions['default'] = {
                type: Extension_2.Extension,
                name: 'uv-default-extension'
            };
            this.set(this.options.data);
            return success;
        };
        UVComponent.prototype.data = function () {
            return {
                annotations: undefined,
                root: "./uv",
                canvasIndex: 0,
                collectionIndex: undefined,
                config: undefined,
                configUri: undefined,
                embedded: false,
                iiifResourceUri: '',
                isLightbox: false,
                isReload: false,
                limitLocales: false,
                locales: [
                    {
                        name: 'en-GB'
                    }
                ],
                manifestIndex: 0,
                rangeId: undefined,
                rotation: 0,
                sequenceIndex: 0,
                xywh: ''
            };
        };
        UVComponent.prototype.set = function (data) {
            // if this is the first set
            if (!this.extension) {
                if (!data.iiifResourceUri) {
                    this._error("iiifResourceUri is required.");
                    return;
                }
                // remove '/' from root
                if (data.root && data.root.endsWith('/')) {
                    data.root = data.root.substring(0, data.root.length - 1);
                }
                this._reload(data);
            }
            else {
                // changing any of these data properties forces the UV to reload.
                if (Utils_1.UVUtils.propertiesChanged(data, this.extension.data, ['collectionIndex', 'manifestIndex', 'config', 'configUri', 'domain', 'embedDomain', 'embedScriptUri', 'iiifResourceUri', 'isHomeDomain', 'isLightbox', 'isOnlyInstance', 'isReload', 'locales', 'root'])) {
                    this.extension.data = Object.assign({}, this.extension.data, data);
                    this._reload(this.extension.data);
                }
                else {
                    // no need to reload, just update.
                    this.extension.data = Object.assign({}, this.extension.data, data);
                    this.extension.render();
                }
            }
        };
        UVComponent.prototype.get = function (key) {
            if (this.extension) {
                return this.extension.data[key];
            }
        };
        UVComponent.prototype.publish = function (event, args) {
            this._pubsub.publish(event, args);
        };
        UVComponent.prototype.subscribe = function (event, cb) {
            this._pubsub.subscribe(event, cb);
        };
        UVComponent.prototype._reload = function (data) {
            var _this = this;
            this._pubsub.dispose(); // remove any existing event listeners
            this.subscribe(BaseEvents_1.BaseEvents.RELOAD, function (data) {
                _this.fire(BaseEvents_1.BaseEvents.RELOAD, data);
            });
            var $elem = $(this.options.target);
            // empty the containing element
            $elem.empty();
            // add loading class
            $elem.addClass('loading');
            jQuery.support.cors = true;
            var that = this;
            Manifold.loadManifest({
                iiifResourceUri: data.iiifResourceUri,
                collectionIndex: data.collectionIndex,
                manifestIndex: data.manifestIndex || 0,
                sequenceIndex: data.sequenceIndex || 0,
                canvasIndex: data.canvasIndex || 0,
                rangeId: data.rangeId,
                locale: (data.locales) ? data.locales[0].name : undefined
            }).then(function (helper) {
                var trackingLabel = helper.getTrackingLabel();
                trackingLabel += ', URI: ' + (window.location !== window.parent.location) ? document.referrer : document.location;
                window.trackingLabel = trackingLabel;
                var sequence;
                if (data.sequenceIndex !== undefined) {
                    sequence = helper.getSequenceByIndex(data.sequenceIndex);
                    if (!sequence) {
                        that._error("Sequence " + data.sequenceIndex + " not found.");
                        return;
                    }
                }
                var canvas;
                if (data.canvasIndex !== undefined) {
                    canvas = helper.getCanvasByIndex(data.canvasIndex);
                }
                if (!canvas) {
                    that._error("Canvas " + data.canvasIndex + " not found.");
                    return;
                }
                var extension = undefined;
                // if the canvas has a duration, use the uv-av-extension
                // const duration: number | null = canvas.getDuration();
                // if (typeof(duration) !== 'undefined') {
                //     extension = that._extensions["av"];
                // } else {
                // canvasType will always be "canvas" in IIIF presentation 3.0
                // to determine the correct extension to use, we need to inspect canvas.content.items[0].format
                // which is an iana media type: http://www.iana.org/assignments/media-types/media-types.xhtml
                var content = canvas.getContent();
                if (content.length) {
                    var annotation = content[0];
                    var body = annotation.getBody();
                    if (body && body.length) {
                        var format = body[0].getFormat();
                        if (format) {
                            extension = that._extensions[format.toString()];
                            if (!extension) {
                                // try type
                                var type = body[0].getType();
                                if (type) {
                                    extension = that._extensions[type.toString()];
                                }
                            }
                        }
                        else {
                            var type = body[0].getType();
                            if (type) {
                                extension = that._extensions[type.toString()];
                            }
                        }
                    }
                }
                else {
                    var canvasType = canvas.getType();
                    if (canvasType) {
                        // try using canvasType
                        extension = that._extensions[canvasType.toString()];
                    }
                    // if there isn't an extension for the canvasType, try the format
                    if (!extension) {
                        var format = canvas.getProperty('format');
                        extension = that._extensions[format];
                    }
                }
                //}
                // if there still isn't a matching extension, use the default extension.
                if (!extension) {
                    extension = that._extensions['default'];
                }
                that._configure(data, extension, function (config) {
                    data.config = config;
                    that._injectCss(data, extension, function () {
                        that._createExtension(extension, data, helper);
                    });
                });
            }).catch(function () {
                that._error('Failed to load manifest.');
            });
        };
        UVComponent.prototype._isCORSEnabled = function () {
            return Modernizr.cors;
        };
        UVComponent.prototype._error = function (message) {
            this.fire(BaseEvents_1.BaseEvents.ERROR, message);
        };
        UVComponent.prototype._configure = function (data, extension, cb) {
            var _this = this;
            this._getConfigExtension(data, extension, function (configExtension) {
                if (data.locales) {
                    var configPath = data.root + '/lib/' + extension.name + '.' + data.locales[0].name + '.config.json';
                    $.getJSON(configPath, function (config) {
                        _this._extendConfig(data, extension, config, configExtension, cb);
                    });
                }
            });
        };
        UVComponent.prototype._extendConfig = function (data, extension, config, configExtension, cb) {
            config.name = extension.name;
            // if configUri has been set, extend the existing config object.
            if (configExtension) {
                // save a reference to the config extension uri.
                config.uri = data.configUri;
                $.extend(true, config, configExtension);
                //$.extend(true, config, configExtension, data.config);
            }
            cb(config);
        };
        UVComponent.prototype._getConfigExtension = function (data, extension, cb) {
            if (!data.locales) {
                return;
            }
            var sessionConfig = sessionStorage.getItem(extension.name + '.' + data.locales[0].name);
            var configUri = data.configUri;
            if (sessionConfig) {
                cb(JSON.parse(sessionConfig));
            }
            else if (configUri) {
                if (this._isCORSEnabled()) {
                    $.getJSON(configUri, function (configExtension) {
                        cb(configExtension);
                    });
                }
                else {
                    // use jsonp
                    var settings = {
                        url: configUri,
                        type: 'GET',
                        dataType: 'jsonp',
                        jsonp: 'callback',
                        jsonpCallback: 'configExtensionCallback'
                    };
                    $.ajax(settings);
                    window.configExtensionCallback = function (configExtension) {
                        cb(configExtension);
                    };
                }
            }
            else {
                cb(null);
            }
        };
        UVComponent.prototype._injectCss = function (data, extension, cb) {
            if (!data.locales) {
                return;
            }
            var cssPath = data.root + '/themes/' + data.config.options.theme + '/css/' + extension.name + '/theme.css';
            var locale = data.locales[0].name;
            var themeName = extension.name.toLowerCase() + '-theme-' + locale.toLowerCase();
            var $existingCSS = $('#' + themeName.toLowerCase());
            if (!$existingCSS.length) {
                $('head').append('<link rel="stylesheet" id="' + themeName + '" href="' + cssPath.toLowerCase() + '" />');
                cb();
            }
            else {
                cb();
            }
        };
        UVComponent.prototype._createExtension = function (extension, data, helper) {
            this.extension = new extension.type();
            if (this.extension) {
                this.extension.component = this;
                this.extension.data = data;
                this.extension.helper = helper;
                this.extension.name = extension.name;
                this.extension.create();
            }
        };
        UVComponent.prototype.exitFullScreen = function () {
            if (this.extension) {
                this.extension.exitFullScreen();
            }
        };
        UVComponent.prototype.resize = function () {
            if (this.extension) {
                this.extension.resize();
            }
        };
        return UVComponent;
    }(_Components.BaseComponent));
    exports.default = UVComponent;
});

if (typeof jQuery === "function") {
    define('jquery', [], function () {
        return jQuery;
    });
}
// IE CustomEvent Polyfill
// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
(function () {
    if (typeof window.CustomEvent === "function")
        return false;
    function CustomEvent(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    }
    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
    return;
})();
// bundled into dist/uv.js
// - things in src/lib that are generic to all extensions
// - bundled data providers
// - UVComponent
requirejs([
    './lib/base64.min.js',
    './lib/browserdetect.js',
    './lib/detectmobilebrowser.js',
    './lib/jquery.xdomainrequest.js',
    './lib/modernizr.js',
    './lib/ex.es3.min.js',
    './lib/BaseComponent.js',
    './lib/KeyCodes.js',
    './lib/HTTPStatusCode.js',
    './lib/jquery-plugins.js',
    './lib/ba-tiny-pubsub.js',
    './lib/manifesto.js',
    './lib/manifold.js',
    './lib/Utils.js',
    './lib/xss.min.js',
    'URLDataProvider',
    'UVComponent'
], function (base64, browserdetect, detectmobilebrowser, xdomainrequest, modernizr, sanitize, exjs, basecomponent, keycodes, httpstatuscodes, jqueryplugins, pubsub, manifesto, manifold, utils, URLDataProvider, UVComponent) {
    window.UV = UVComponent.default;
    window.UV.URLDataProvider = URLDataProvider.default;
    window.dispatchEvent(new CustomEvent('uvLoaded', {}));
});

define("app", function(){});


//# sourceMappingURL=build.js.map
